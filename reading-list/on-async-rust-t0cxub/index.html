<!DOCTYPE html><html lang="zh-CN" data-astro-cid-sckkx6r4> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.16.1"><meta name="description" content="I started using Rust in 2017, before the stabilisation of async/await. When it was stabilised I managed to avoid it for a few more years before it was time to grapple with it. It‚Äôs fair to say that as"><link rel="canonical" href="https://blog.yuyins.com/reading-list/on-async-rust-t0cxub/"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://blog.yuyins.com/reading-list/on-async-rust-t0cxub/"><meta property="og:title" content="On Async Rust"><meta property="og:description" content="I started using Rust in 2017, before the stabilisation of async/await. When it was stabilised I managed to avoid it for a few more years before it was time to grapple with it. It‚Äôs fair to say that as"><meta property="og:image" content="https://blog.yuyins.com/favicon.svg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://blog.yuyins.com/reading-list/on-async-rust-t0cxub/"><meta property="twitter:title" content="On Async Rust"><meta property="twitter:description" content="I started using Rust in 2017, before the stabilisation of async/await. When it was stabilised I managed to avoid it for a few more years before it was time to grapple with it. It‚Äôs fair to say that as"><meta property="twitter:image" content="https://blog.yuyins.com/favicon.svg"><title>On Async Rust</title><!-- Theme and color scheme script (runs before page loads to prevent flash) --><script>
			// ÂàùÂßãÂåñÈÖçËâ≤ÊñπÊ°à - ÈªòËÆ§‰ΩøÁî® stone-amber
			const colorScheme = localStorage.getItem('colorScheme') || 'stone-amber';
			document.documentElement.setAttribute('data-color', colorScheme);

			// Âº∫Âà∂‰ΩøÁî®ÊµÖËâ≤‰∏ªÈ¢ò
			document.documentElement.setAttribute('data-theme', 'light');
		</script><link rel="stylesheet" href="/_astro/_slug_.C-G01a-E.css">
<style>.hidden[data-astro-cid-wrgicudb]{display:none!important}.translate-btn[data-astro-cid-wrgicudb]{margin-left:auto;display:inline-flex;align-items:center;gap:.25rem;padding:.25rem .75rem;border-radius:9999px;background-color:var(--muted);color:var(--foreground);font-size:.75rem;font-weight:500;cursor:pointer;border:none;transition:all .2s}.translate-btn[data-astro-cid-wrgicudb]:hover{background-color:var(--accent);color:#fff}.blog-post-container[data-astro-cid-wrgicudb]{width:100%;margin:0 auto;padding:2rem 0}.blog-post[data-astro-cid-wrgicudb]{width:100%;min-width:0;max-width:42rem;margin:0 auto}.article-header[data-astro-cid-wrgicudb]{margin-bottom:2rem;padding-bottom:1rem;border-bottom:1px solid var(--border)}.article-header[data-astro-cid-wrgicudb] h1[data-astro-cid-wrgicudb]{font-size:2rem;line-height:1.3;margin-bottom:1rem;font-weight:700;color:var(--foreground);word-break:break-word}.article-meta[data-astro-cid-wrgicudb]{display:flex;align-items:center;gap:.5rem;font-size:.875rem;color:var(--muted-foreground)}.source-tag[data-astro-cid-wrgicudb]{background-color:var(--muted);color:var(--foreground);padding:.125rem .5rem;border-radius:9999px;font-weight:500;font-size:.75rem;text-decoration:none;transition:opacity .2s}.source-tag[data-astro-cid-wrgicudb]:hover{opacity:.8}.separator[data-astro-cid-wrgicudb]{color:var(--border)}.article-content[data-astro-cid-wrgicudb]{line-height:1.8;margin-bottom:3rem;font-size:1.0625rem;color:var(--foreground)}.article-content[data-astro-cid-wrgicudb] h2{margin-top:2rem;margin-bottom:1rem;font-size:1.5rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] h3{margin-top:1.5rem;margin-bottom:.75rem;font-size:1.25rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] p{margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] a{color:var(--accent);text-decoration:underline;text-underline-offset:2px}.article-content[data-astro-cid-wrgicudb] img{max-width:100%;height:auto;border-radius:.5rem;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] blockquote{border-left:4px solid var(--border);padding-left:1rem;margin:1.5rem 0;color:var(--muted-foreground);font-style:italic}.article-content[data-astro-cid-wrgicudb] pre{background:var(--muted);padding:1rem;border-radius:.5rem;overflow-x:auto;font-family:monospace;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] ul,.article-content[data-astro-cid-wrgicudb] ol{padding-left:1.5rem;margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] li{margin-bottom:.5rem}.article-footer[data-astro-cid-wrgicudb]{padding-top:2rem;border-top:1px solid var(--border);display:flex;flex-direction:column;gap:1.5rem;align-items:center}.action-row[data-astro-cid-wrgicudb]{display:flex;justify-content:center}.read-original-btn[data-astro-cid-wrgicudb]{display:inline-flex;align-items:center;gap:.5rem;padding:.75rem 1.5rem;background-color:var(--foreground);color:var(--background);border-radius:.5rem;font-weight:500;text-decoration:none;transition:opacity .2s}.read-original-btn[data-astro-cid-wrgicudb]:hover{opacity:.9}.back-to-list[data-astro-cid-wrgicudb]{text-align:center}.back-link[data-astro-cid-wrgicudb]{color:var(--muted-foreground);text-decoration:none;font-size:.875rem;transition:color .2s}.back-link[data-astro-cid-wrgicudb]:hover{color:var(--foreground)}
</style></head> <body data-astro-cid-sckkx6r4> <a id="skip-to-content" href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-accent focus:text-background" data-astro-cid-sckkx6r4>Skip to content</a> <header class="header" data-astro-cid-3ef6ksr2> <nav class="header-nav" aria-label="Main navigation" data-astro-cid-3ef6ksr2> <a href="/" class="header-logo" data-astro-cid-3ef6ksr2>
AstroBlog
</a> <div class="header-links" data-astro-cid-3ef6ksr2> <ul class="nav-list" data-astro-cid-3ef6ksr2> <li data-astro-cid-3ef6ksr2> <a href="/" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> ÊñáÁ´† </a> </li><li data-astro-cid-3ef6ksr2> <a href="/category" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> ÂàÜÁ±ª </a> </li><li data-astro-cid-3ef6ksr2> <a href="/reading-list" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> ËÆ¢ÈòÖ </a> </li><li data-astro-cid-3ef6ksr2> <a href="/about" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> ÂÖ≥‰∫é </a> </li> </ul> <div class="header-actions" data-astro-cid-3ef6ksr2> <div id="search" data-astro-cid-otpdt6jm> <button id="search-button" class="search-toggle" aria-label="ÊâìÂºÄÊêúÁ¥¢" title="ÊêúÁ¥¢ (‚åòK)" data-astro-cid-otpdt6jm> <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></circle> <path d="M20 20L16.5 16.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></path> </svg> </button> <dialog id="search-dialog" class="search-modal" data-astro-cid-otpdt6jm> <div class="modal-content" data-astro-cid-otpdt6jm> <div class="modal-header" data-astro-cid-otpdt6jm> <h2 class="modal-title" data-astro-cid-otpdt6jm>ÊêúÁ¥¢ÊñáÁ´†</h2> <button id="close-search" class="close-button" aria-label="ÂÖ≥Èó≠ÊêúÁ¥¢" data-astro-cid-otpdt6jm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-otpdt6jm></path> </svg> </button> </div> <div id="pagefind-ui" data-astro-cid-otpdt6jm></div> </div> </dialog> </div> <script type="module">let d=!1;const c="pagefind-loaded";async function l(t=0){if(sessionStorage.getItem(c)==="true")return g(),!0;const r=document.getElementById("pagefind-ui");if(!r)return!1;r.innerHTML='<div style="padding: 2rem; text-align: center; color: var(--muted-foreground);">Âä†ËΩΩ‰∏≠...</div>';try{return await new Promise((o,s)=>{const a=document.createElement("script");a.src="/pagefind/pagefind-ui.js",a.onload=o,a.onerror=s,document.head.appendChild(a)}),g(),sessionStorage.setItem(c,"true"),!0}catch(i){return console.error("Failed to load search:",i),t<2?(console.log(`Retrying search load... (${t+1}/2)`),await new Promise(o=>setTimeout(o,1e3)),l(t+1)):(r&&(r.innerHTML=`
          <div style="padding: 2rem; text-align: center;">
            <p style="color: var(--muted-foreground); margin-bottom: 1rem;">ÊêúÁ¥¢ÂäüËÉΩÂä†ËΩΩÂ§±Ë¥•</p>
            <button id="retry-search" style="padding: 0.5rem 1rem; background: var(--accent); color: var(--accent-foreground); border: none; border-radius: 0.375rem; cursor: pointer;">
              ÈáçËØï
            </button>
          </div>
        `,document.getElementById("retry-search")?.addEventListener("click",()=>{sessionStorage.removeItem(c),l(0)})),!1)}}function g(){typeof PagefindUI<"u"&&(new PagefindUI({element:"#pagefind-ui",showSubResults:!0,showImages:!1,excerptLength:15,translations:{placeholder:"ÊêúÁ¥¢ÊñáÁ´†...",clear_search:"Ê∏ÖÈô§",load_more:"Âä†ËΩΩÊõ¥Â§ö",search_label:"ÊêúÁ¥¢Ê≠§Á´ôÁÇπ",filters_label:"Á≠õÈÄâ",zero_results:"Êú™ÊâæÂà∞ÁªìÊûú [SEARCH_TERM]",many_results:"ÊâæÂà∞ [COUNT] ‰∏™ÁªìÊûú [SEARCH_TERM]",one_result:"ÊâæÂà∞ [COUNT] ‰∏™ÁªìÊûú [SEARCH_TERM]",alt_search:"Êú™ÊâæÂà∞ [SEARCH_TERM] ÁöÑÁªìÊûú„ÄÇÊòæÁ§∫ [DIFFERENT_TERM] ÁöÑÁªìÊûú",search_suggestion:"Êú™ÊâæÂà∞ [SEARCH_TERM] ÁöÑÁªìÊûú„ÄÇÂ∞ùËØï‰ª•‰∏ãÊêúÁ¥¢Ôºö",searching:"ÊêúÁ¥¢‰∏≠ [SEARCH_TERM]..."}}),setTimeout(()=>{const t=document.querySelector(".pagefind-ui__search-input");t instanceof HTMLElement&&t.focus()},100))}function u(){if(d)return;d=!0;const t=document.getElementById("search-button"),n=document.getElementById("search-dialog"),r=document.getElementById("close-search");if(!t||!n||!r)return;let i=sessionStorage.getItem(c)==="true";const o=async()=>{n.showModal(),document.body.style.overflow="hidden",i?setTimeout(()=>{const e=document.querySelector(".pagefind-ui__search-input");e instanceof HTMLElement&&e.focus()},100):await l()&&(i=!0)},s=()=>{n.close(),document.body.style.overflow=""},a=e=>{e.target===n&&s()},m=e=>{e.key==="Escape"&&n.open&&s()},f=e=>{(e.metaKey||e.ctrlKey)&&e.key==="k"&&(e.preventDefault(),n.open?s():o())};t.addEventListener("click",o),r.addEventListener("click",s),n.addEventListener("click",a),document.addEventListener("keydown",m),document.addEventListener("keydown",f),document.addEventListener("astro:before-swap",()=>{t.removeEventListener("click",o),r.removeEventListener("click",s),n.removeEventListener("click",a),document.removeEventListener("keydown",m),document.removeEventListener("keydown",f),d=!1},{once:!0})}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",u):u();document.addEventListener("astro:page-load",u);</script> <link href="/pagefind/pagefind-ui.css" rel="stylesheet">  </div> </div> </nav> </header>  <main id="main-content" data-pagefind-body class="main-content main-content--wide" data-astro-cid-sckkx6r4>  <div class="blog-post-container" data-astro-cid-wrgicudb> <article class="blog-post" data-astro-cid-wrgicudb> <header class="article-header" data-astro-cid-wrgicudb> <h1 class="title-en" data-astro-cid-wrgicudb>On Async Rust</h1>  <div class="article-meta" data-astro-cid-wrgicudb> <a href="https://hugotunius.se" target="_blank" rel="noopener noreferrer" class="source-tag" data-astro-cid-wrgicudb>hugotunius.se</a> <span class="separator" data-astro-cid-wrgicudb>¬∑</span> <time data-astro-cid-wrgicudb>2024Âπ¥3Êúà8Êó•</time>  </div> </header> <!-- Render HTML content from RSS feed --> <div class="article-content content-en app-prose" data-astro-cid-wrgicudb><p>I started using Rust in 2017, before the stabilisation of async/await. When it was stabilised I managed to avoid it for a few more years before it was time to grapple with it. It‚Äôs fair to say that async Rust is one of the hairiest parts of the language, not because the async model is poorly designed, but because of the inherent complexity of it in combination with Rust‚Äôs goals. There have been many blog post written about async and its perceived shortcomings, as well as excellent explainers and history lessons, mostly from <a href="https://without.boats/"><code class="language-plaintext highlighter-rouge">withoutboats</code></a>.</p>

<p>In this post I want to reflect on my experience and journey with async and my thoughts on some of the criticisms levied against async. Starting with: do we really need <code class="language-plaintext highlighter-rouge">N:M</code> threading anyway?</p>

<h2 id="do-we-really-need-nm-threading"><a class="heading-anchor" aria-hidden="true" href="#do-we-really-need-nm-threading"><img src="/assets/icons/link.svg?1761515323" /></a>Do we Really Need N:M threading?</h2>

<p>A favourite maxim of mine is: ‚ÄúComputers are fast actually‚Äù. My point being that, as an industry, we have lost touch of quite how much modern computers are capable of. Thus, I‚Äôm naturally favourable to the idea that N:M threading is oftentimes overkill and most applications would be well-served by just using OS threads and blocking syscalls. After all the C10k(and more) problem is trivially solvable with just OS threads. Many applications could avoid the complexity of async Rust and still be plenty performant with regular threads.</p>

<p>However, it doesn‚Äôt really matter what I think, or even if it‚Äôs true that most applications don‚Äôt need N:M threading, because developers, for better or worse, <strong>want</strong> N:M threading . Therefore, for Rust to be competitive with Go, C++, et al. it must offer it. Rust has a very unique set of constraints that makes solving this problem challenging, one of which is zero-cost abstractions.</p>

<h2 id="zero-cost-abstractions"><a class="heading-anchor" aria-hidden="true" href="#zero-cost-abstractions"><img src="/assets/icons/link.svg?1761515323" /></a>Zero-Cost Abstractions</h2>

<p>Rust‚Äôs goal of providing zero-cost abstractions, i.e. abstractions that are no worse than writing the optimal lower level code yourself, often comes up in discussions around async Rust and is sometimes misunderstood. For example, the idea that async Rust is a big ecosystem with many crates and building all of those crates as part of your application is a violation of the zero-cost abstractions principle. It isn‚Äôt, zero-cost is about runtime performance.</p>

<p>The zero-cost goal helps guide us when discussing alternative async models. For example, Go is lauded for its lack of function-colouring and its sometimes suggested Rust should copy its approach. This is a no-go(üòÖ) because Go‚Äôs approach is decidedly <strong>not</strong> zero-cost and requires a heavy runtime. Rust did actually feature green threads, which are similar to coroutines, in an earlier version of the language, but these were <a href="https://github.com/rust-lang/rfcs/blob/master/text/0230-remove-runtime.md">removed</a> precisely because of the runtime requirement.</p>

<h2 id="the-arcmutex-in-the-room"><a class="heading-anchor" aria-hidden="true" href="#the-arcmutex-in-the-room"><img src="/assets/icons/link.svg?1761515323" /></a>The <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&gt;</code> in the room</h2>

<p>Another common point of contention is the tendency for async Rust to require a lot, and I do mean <strong>a lot</strong>, of types like <code class="language-plaintext highlighter-rouge">Arc</code> and <code class="language-plaintext highlighter-rouge">Mutex</code>, often in combination. I experienced this myself when starting out with async Rust, it‚Äôs easy to solve local state synchronisation problems with these constructs without properly thinking about the wider design of your application. The result is a mess that soon comes back to bite you. However, discussing this in the context of async Rust and as an ‚Äúasync problem‚Äù is unfair, it‚Äôs really a concurrency problem and it will manifest in applications that achieve concurrency with OS threads too. Fundamentally, if you want to have shared state, whether between tasks or threads, you have to contend with the synchronisation  problem. One of my big lessons in learning async Rust is to not blindly follow compilers errors to ‚Äúsolve‚Äù shared state, instead take a step back and properly considered if the state should be shared at all.</p>

<p>This problem is similar to the notorious borrow checker problems Rust is infamous for. When I started learning Rust I often ran into borrow checker problems because I wasn‚Äôt thinking thoroughly about ownership, only about my desire to borrow data. <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&gt;</code> and friends sometimes betray a similar lack of consideration for ownership.</p>

<h2 id="critiquing-async-rust"><a class="heading-anchor" aria-hidden="true" href="#critiquing-async-rust"><img src="/assets/icons/link.svg?1761515323" /></a>Critiquing Async Rust</h2>

<p>All of the above form the context to be considered when critiquing async rust. Simply stating that Rust should abandon zero-cost abstractions is easy, while providing constructive feedback that takes this goal into consideration is not. The same is true about the suggestion that Rust should not have an async programming model at all. Within these bounds, constructive criticism of Rust‚Äôs async model is great, only by examining what‚Äôs not working well can lessons be learned for the future and the language improved. All this said, there are definitely problems with async Rust.</p>

<p>When you go looking for crates to perform anything remotely related to IO e.g. making HTTP requests, interfacing with databases, implementing web servers, you‚Äôll find that there is an abundance of async crates, but rarely any that are sync. Even when sync crates exist they are often implemented in terms of the async version, meaning you‚Äôll have to pull in a large number of transitive dependencies from the async ecosystem into your ostensibly sync program. This is an extension of the function colouring problem, it‚Äôs <strong>crate colouring</strong>. The choice of IO model pollutes both a crate‚Äôs API and it‚Äôs dependency hierarchy. In the rare instances when only a sync crate exists the opposite problem occurs for sync programs, yes there‚Äôs <code class="language-plaintext highlighter-rouge">block_on</code> and friends, but this is band-aid at best.</p>

<p>Even within the async ecosystem there‚Äôs a problem, the dominance of Tokio. Tokio is a great piece of software and has become the de facto default executor. However, ‚Äúdefault‚Äù implies the possibility of choosing a different executor, which in reality is not possible. The third party crate ecosystem isn‚Äôt just dominated by async crates, but by crates that only work with Tokio. Use a different executor? Tough luck. You‚Äôll need to switch to Tokio or redundantly implement the crates you need for yourself. Not only do we have a crate colouring problem, but there are also more than <a href="https://without.boats/blog/let-futures-be-futures/#the-function-non-coloring-problem">3 colours</a> because <code class="language-plaintext highlighter-rouge">async-tokio</code> and <code class="language-plaintext highlighter-rouge">async-async-std</code> are distinct colours.</p>

<p><a href="https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html">Async traits are slowly being stabilised</a>, but this is just one place where the language and standard library lacks proper support for async. Drop still cannot be async and neither can closures. Async is a second-class citizen within Rust because the tools that are usually available to us, are off limits in async. There is interesting work happening to address this, namely <a href="https://www.youtube.com/watch?v=MTnIexTt9Dk">extensions to Rust‚Äôs effect system</a>.</p>

<h2 id="inverting-expectations"><a class="heading-anchor" aria-hidden="true" href="#inverting-expectations"><img src="/assets/icons/link.svg?1761515323" /></a>Inverting Expectations</h2>

<style type="text/css">
:root {
    --light-blue-color: rgba(38, 140, 234, 1);
    --light-green-color: rgba(38, 234, 46, 1);
    --light-red-color: rgba(234, 38, 73, 1);
    --light-orange-color: rgba(234, 120, 38, 1);

    --dark-blue-color: rgba(115, 188, 255, 1);
    --dark-green-color: rgba(115, 255, 120, 1);
    --dark-red-color: rgba(255, 115, 140, 1);
    --dark-orange-color: rgba(255, 174, 115, 1);

    --blue-color: var(--light-blue-color);
    --green-color: var(--light-green-color);
    --red-color: var(--light-red-color);
    --orange-color: var(--light-orange-color);
}

@media (prefers-color-scheme: dark) {
    :root {
        --blue-color: var(--dark-blue-color);
        --green-color: var(--dark-green-color);
        --red-color: var(--dark-red-color);
        --orange-color: var(--dark-orange-color);
    }
    
    span.c {
        color: var(--background-color);
    }
}

span.c {
    padding: 0.1em 0.2em;
    border-radius: 2px;
}

span.b {
    background-color: var(--blue-color);
}

span.g {
    background-color: var(--green-color);
}

span.r {
    background-color: var(--red-color);
}

span.o {
    background-color: var(--orange-color);
}
</style>

<p>The problems of function and crate colouring are intimately tied to how code is structured. When IO is internal to a piece of code, abstracting over its asyncness, or lack thereof, becomes complicated due to colouring. The colouring is infectious, if some code abstracts over the colours red and green, then that code needs to become a chameleon, changing its colour based on the internal colour of the IO. At the moment this chameleon behaviour is not achievable in Rust, although the effects extensions would allow it. Abstracting over the asyncness of IO is complicated, what if we instead were to avoid it with inversion of control.</p>

<p>The <a href="https://sans-io.readthedocs.io/">sans-IO pattern</a> sidesteps the colouring problem by moving the IO out. Instead of abstracting over IO we implement the core logic and expect the caller to handle IO. Concretely this means that a set of crates implementing a HTTP client would be split into a <code class="language-plaintext highlighter-rouge">http-client-proto</code> crate and several user facing crates <code class="language-plaintext highlighter-rouge">http-client-sync</code>, <code class="language-plaintext highlighter-rouge">http-client-tokio</code>, <code class="language-plaintext highlighter-rouge">http-client-async-std</code>. Borrowing from <code class="language-plaintext highlighter-rouge">withoutboat</code>‚Äôs colour definitions, <code class="language-plaintext highlighter-rouge">http-client-proto</code> would be a <span class="c b">blue crate</span>, it does no IO and never blocks the calling thread, it implements the protocol level HTTP concerns such as request parsing, response generation etc. <code class="language-plaintext highlighter-rouge">http-client-sync</code> would be a <span class="c g">green crate</span> and <code class="language-plaintext highlighter-rouge">http-client-tokio</code> would be a <span class="c r">red crate</span>. As I hinted to before, a different async executor, at least in the absence of the aforementioned abstractions, is a different colour too so <code class="language-plaintext highlighter-rouge">http-client-async-std</code> would be an <span class="c o">orange crate</span>. This pattern has several benefits, it enables code sharing between differing IO models without bloating dependency trees or relying on the likes of <code class="language-plaintext highlighter-rouge">block_on</code>. A user that finds the crates <code class="language-plaintext highlighter-rouge">foo-proto</code> and <code class="language-plaintext highlighter-rouge">foo-tokio</code> can leverage <code class="language-plaintext highlighter-rouge">foo-proto</code> to contribute <code class="language-plaintext highlighter-rouge">foo-sync</code>, requiring less duplication. If every crate that deals with IO followed this pattern the problem of crate colouring would be greatly alleviated and significant portions of code could be shared between sync and async implementations.</p></div>  <footer class="article-footer" data-astro-cid-wrgicudb> <div class="action-row" data-astro-cid-wrgicudb> <a href="https://hugotunius.se/2024/03/08/on-async-rust.html" target="_blank" rel="noopener noreferrer" class="read-original-btn" data-astro-cid-wrgicudb>
ÈòÖËØªÂéüÊñá ‚Üó
</a> </div> <div class="back-to-list" data-astro-cid-wrgicudb> <a href="/reading-list" class="back-link" data-astro-cid-wrgicudb>‚Üê ËøîÂõûËÆ¢ÈòÖÂàóË°®</a> </div> </footer> </article> </div>  </main> <footer class="site-footer" aria-label="Site footer" data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <p class="footer-text" data-astro-cid-sz7xmlte>
&copy; 2026 AstroBlog
</p> <p class="footer-text" data-astro-cid-sz7xmlte>
Built with  <a href="https://astro.build/" target="_blank" rel="noopener noreferrer" class="footer-link" data-astro-cid-sz7xmlte>
Astro
</a> </p> </div> </footer>  </body></html> <script type="module">const t=document.getElementById("translate-btn");t&&t.addEventListener("click",()=>{document.querySelector(".title-en")?.classList.toggle("hidden"),document.querySelector(".title-zh")?.classList.toggle("hidden"),document.querySelector(".content-en")?.classList.toggle("hidden"),document.querySelector(".content-zh")?.classList.toggle("hidden");const e=t.querySelector(".btn-text");if(e){const n=!document.querySelector(".title-zh")?.classList.contains("hidden");e.textContent=n?"ÂéüÊñá":"‰∏≠Êñá"}});</script> 