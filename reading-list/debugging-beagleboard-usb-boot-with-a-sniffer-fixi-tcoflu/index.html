<!DOCTYPE html><html lang="zh-CN" data-astro-cid-sckkx6r4> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.17.1"><meta name="description" content="本文讨论的是2008年推出的原始OMAP3530 BeagleBoard。是的，老到在BeagleBoard.org的板子列表中都找不到了。是BeagleBoard，不是BeagleBone。在"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self'; font-src 'self' data:;"><link rel="canonical" href="https://blog.yuyins.com/reading-list/debugging-beagleboard-usb-boot-with-a-sniffer-fixi-tcoflu/"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://blog.yuyins.com/reading-list/debugging-beagleboard-usb-boot-with-a-sniffer-fixi-tcoflu/"><meta property="og:title" content="使用嗅探器调试BeagleBoard USB启动：修复现代PC上的omap_loader"><meta property="og:description" content="本文讨论的是2008年推出的原始OMAP3530 BeagleBoard。是的，老到在BeagleBoard.org的板子列表中都找不到了。是BeagleBoard，不是BeagleBone。在"><meta property="og:image" content="https://blog.yuyins.com/favicon.svg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://blog.yuyins.com/reading-list/debugging-beagleboard-usb-boot-with-a-sniffer-fixi-tcoflu/"><meta property="twitter:title" content="使用嗅探器调试BeagleBoard USB启动：修复现代PC上的omap_loader"><meta property="twitter:description" content="本文讨论的是2008年推出的原始OMAP3530 BeagleBoard。是的，老到在BeagleBoard.org的板子列表中都找不到了。是BeagleBoard，不是BeagleBone。在"><meta property="twitter:image" content="https://blog.yuyins.com/favicon.svg"><title>使用嗅探器调试BeagleBoard USB启动：修复现代PC上的omap_loader</title><!-- Theme and color scheme script (runs before page loads to prevent flash) --><script>
			// 初始化配色方案 - 默认使用 stone-amber
			const colorScheme = localStorage.getItem('colorScheme') || 'stone-amber';
			document.documentElement.setAttribute('data-color', colorScheme);

			// 强制使用浅色主题
			document.documentElement.setAttribute('data-theme', 'light');
		</script><link rel="stylesheet" href="/_astro/_slug_.BZEkEaL-.css">
<style>.blog-post-container[data-astro-cid-wrgicudb]{width:100%;margin:0 auto;padding:2rem 0}.blog-post[data-astro-cid-wrgicudb]{width:100%;min-width:0;max-width:42rem;margin:0 auto}.article-header[data-astro-cid-wrgicudb]{margin-bottom:2rem;padding-bottom:1rem;border-bottom:1px solid var(--border)}.article-header[data-astro-cid-wrgicudb] h1[data-astro-cid-wrgicudb]{font-size:2rem;line-height:1.3;margin-bottom:1rem;font-weight:700;color:var(--foreground);word-break:break-word}.article-meta[data-astro-cid-wrgicudb]{display:flex;align-items:center;gap:.5rem;font-size:.875rem;color:var(--muted-foreground)}.source-tag[data-astro-cid-wrgicudb]{background-color:var(--muted);color:var(--foreground);padding:.125rem .5rem;border-radius:9999px;font-weight:500;font-size:.75rem;text-decoration:none;transition:opacity .2s}.source-tag[data-astro-cid-wrgicudb]:hover{opacity:.8}.separator[data-astro-cid-wrgicudb]{color:var(--border)}.article-content[data-astro-cid-wrgicudb]{line-height:1.8;margin-bottom:3rem;font-size:1.0625rem;color:var(--foreground)}.article-content[data-astro-cid-wrgicudb] h2{margin-top:2rem;margin-bottom:1rem;font-size:1.5rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] h3{margin-top:1.5rem;margin-bottom:.75rem;font-size:1.25rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] p{margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] a{color:var(--accent);text-decoration:underline;text-underline-offset:2px}.article-content[data-astro-cid-wrgicudb] img{max-width:100%;height:auto;border-radius:.5rem;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] blockquote{border-left:4px solid var(--border);padding-left:1rem;margin:1.5rem 0;color:var(--muted-foreground);font-style:italic}.article-content[data-astro-cid-wrgicudb] pre{background:var(--muted);padding:1rem;border-radius:.5rem;overflow-x:auto;font-family:monospace;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] ul,.article-content[data-astro-cid-wrgicudb] ol{padding-left:1.5rem;margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] li{margin-bottom:.5rem}.article-footer[data-astro-cid-wrgicudb]{padding-top:2rem;border-top:1px solid var(--border);display:flex;flex-direction:column;gap:1.5rem;align-items:center}.action-row[data-astro-cid-wrgicudb]{display:flex;justify-content:center}.read-original-btn[data-astro-cid-wrgicudb]{display:inline-flex;align-items:center;gap:.5rem;padding:.75rem 1.5rem;background-color:var(--foreground);color:var(--background);border-radius:.5rem;font-weight:500;text-decoration:none;transition:opacity .2s}.read-original-btn[data-astro-cid-wrgicudb]:hover{opacity:.9}.back-to-list[data-astro-cid-wrgicudb]{text-align:center}.back-link[data-astro-cid-wrgicudb]{color:var(--muted-foreground);text-decoration:none;font-size:.875rem;transition:color .2s}.back-link[data-astro-cid-wrgicudb]:hover{color:var(--foreground)}
</style></head> <body data-astro-cid-sckkx6r4> <a id="skip-to-content" href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-accent focus:text-background" data-astro-cid-sckkx6r4>Skip to content</a> <header class="header" data-astro-cid-3ef6ksr2> <nav class="header-nav" aria-label="Main navigation" data-astro-cid-3ef6ksr2> <a href="/" class="header-logo" data-astro-cid-3ef6ksr2>
AstroBlog
</a> <div class="header-links" data-astro-cid-3ef6ksr2> <ul class="nav-list" data-astro-cid-3ef6ksr2> <li data-astro-cid-3ef6ksr2> <a href="/" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 文章 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/category" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 分类 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/reading-list" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 订阅 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/about" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 关于 </a> </li> </ul> <div class="header-actions" data-astro-cid-3ef6ksr2> <div id="search" data-astro-cid-otpdt6jm> <button id="search-button" class="search-toggle" aria-label="打开搜索" title="搜索 (⌘K)" data-astro-cid-otpdt6jm> <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></circle> <path d="M20 20L16.5 16.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></path> </svg> </button> <dialog id="search-dialog" class="search-modal" data-astro-cid-otpdt6jm> <div class="modal-content" data-astro-cid-otpdt6jm> <div class="modal-header" data-astro-cid-otpdt6jm> <h2 class="modal-title" data-astro-cid-otpdt6jm>搜索文章</h2> <button id="close-search" class="close-button" aria-label="关闭搜索" data-astro-cid-otpdt6jm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-otpdt6jm></path> </svg> </button> </div> <div id="pagefind-ui" data-astro-cid-otpdt6jm></div> </div> </dialog> </div> <script type="module">let d=!1;const c="pagefind-loaded";async function l(t=0){if(sessionStorage.getItem(c)==="true")return g(),!0;const r=document.getElementById("pagefind-ui");if(!r)return!1;r.innerHTML='<div style="padding: 2rem; text-align: center; color: var(--muted-foreground);">加载中...</div>';try{return await new Promise((o,s)=>{const a=document.createElement("script");a.src="/pagefind/pagefind-ui.js",a.onload=o,a.onerror=s,document.head.appendChild(a)}),g(),sessionStorage.setItem(c,"true"),!0}catch(i){return console.error("Failed to load search:",i),t<2?(console.log(`Retrying search load... (${t+1}/2)`),await new Promise(o=>setTimeout(o,1e3)),l(t+1)):(r&&(r.innerHTML=`
          <div style="padding: 2rem; text-align: center;">
            <p style="color: var(--muted-foreground); margin-bottom: 1rem;">搜索功能加载失败</p>
            <button id="retry-search" style="padding: 0.5rem 1rem; background: var(--accent); color: var(--accent-foreground); border: none; border-radius: 0.375rem; cursor: pointer;">
              重试
            </button>
          </div>
        `,document.getElementById("retry-search")?.addEventListener("click",()=>{sessionStorage.removeItem(c),l(0)})),!1)}}function g(){typeof PagefindUI<"u"&&(new PagefindUI({element:"#pagefind-ui",showSubResults:!0,showImages:!1,excerptLength:15,translations:{placeholder:"搜索文章...",clear_search:"清除",load_more:"加载更多",search_label:"搜索此站点",filters_label:"筛选",zero_results:"未找到结果 [SEARCH_TERM]",many_results:"找到 [COUNT] 个结果 [SEARCH_TERM]",one_result:"找到 [COUNT] 个结果 [SEARCH_TERM]",alt_search:"未找到 [SEARCH_TERM] 的结果。显示 [DIFFERENT_TERM] 的结果",search_suggestion:"未找到 [SEARCH_TERM] 的结果。尝试以下搜索：",searching:"搜索中 [SEARCH_TERM]..."}}),setTimeout(()=>{const t=document.querySelector(".pagefind-ui__search-input");t instanceof HTMLElement&&t.focus()},100))}function u(){if(d)return;d=!0;const t=document.getElementById("search-button"),n=document.getElementById("search-dialog"),r=document.getElementById("close-search");if(!t||!n||!r)return;let i=sessionStorage.getItem(c)==="true";const o=async()=>{n.showModal(),document.body.style.overflow="hidden",i?setTimeout(()=>{const e=document.querySelector(".pagefind-ui__search-input");e instanceof HTMLElement&&e.focus()},100):await l()&&(i=!0)},s=()=>{n.close(),document.body.style.overflow=""},a=e=>{e.target===n&&s()},m=e=>{e.key==="Escape"&&n.open&&s()},f=e=>{(e.metaKey||e.ctrlKey)&&e.key==="k"&&(e.preventDefault(),n.open?s():o())};t.addEventListener("click",o),r.addEventListener("click",s),n.addEventListener("click",a),document.addEventListener("keydown",m),document.addEventListener("keydown",f),document.addEventListener("astro:before-swap",()=>{t.removeEventListener("click",o),r.removeEventListener("click",s),n.removeEventListener("click",a),document.removeEventListener("keydown",m),document.removeEventListener("keydown",f),d=!1},{once:!0})}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",u):u();document.addEventListener("astro:page-load",u);</script> <link href="/pagefind/pagefind-ui.css" rel="stylesheet">  </div> </div> </nav> </header>  <main id="main-content" data-pagefind-body class="main-content main-content--wide" data-astro-cid-sckkx6r4>  <div class="blog-post-container" data-astro-cid-wrgicudb> <article class="blog-post" data-astro-cid-wrgicudb> <header class="article-header" data-astro-cid-wrgicudb> <h1 data-astro-cid-wrgicudb>使用嗅探器调试BeagleBoard USB启动：修复现代PC上的omap_loader</h1> <div class="article-meta" data-astro-cid-wrgicudb> <a href="https://downtowndougbrown.com" target="_blank" rel="noopener noreferrer" class="source-tag" data-astro-cid-wrgicudb>downtowndougbrown.com</a> <span class="separator" data-astro-cid-wrgicudb>·</span> <time data-astro-cid-wrgicudb>2025年11月8日</time> </div> </header> <!-- 使用清洗后的安全 HTML 内容 --> <div class="article-content app-prose" data-astro-cid-wrgicudb>
<p>This post is about the original <a href="https://www.beagleboard.org/boards/beagleboard" target="_blank" rel="noopener noreferrer">OMAP3530 BeagleBoard</a> from 2008. Yes, the one so old that it doesn’t even show up in <a href="https://www.beagleboard.org/boards" target="_blank" rel="noopener noreferrer">the board list on BeagleBoard.org</a> anymore. The Beagle<strong>Board</strong>, not the BeagleBone. During my Chumby 8 kernel escapades, at one point <a href="https://www.downtowndougbrown.com/2024/07/upgrading-my-chumby-8-kernel-part-12-uart-woes/" target="_blank" rel="noopener noreferrer">I ran into a UART bug that affected multiple drivers</a>, including the omap-serial driver. This led me to buy a BeagleBoard so I could verify the omap-serial bug on hardware.</p>



<figure><a href="https://www.downtowndougbrown.com/wp-content/uploads/2024/07/beagleboard.jpg" target="_blank" rel="noopener noreferrer"><img width="1024" height="1014" src="https://www.downtowndougbrown.com/wp-content/uploads/2024/07/beagleboard.jpg" alt="" /></a></figure>



<p>After I figured out the bug with the UART driver, I realized that the OMAP3530 has support for booting from USB, so I decided to go off on a random tangent to get USB boot working. There was no problem I was trying to solve or anything like that. I just thought it would be a fun experiment (am I a masochist?). Little did I know, I would be getting myself into some tricky USB packet analysis.</p>



<span></span>



<p>I struggled to find info about this process because of how old the OMAP is today. The main utility I found was a program called <a href="https://github.com/grant-h/omap_loader" target="_blank" rel="noopener noreferrer">omap_loader</a> by Grant Hernandez, which is a newer rewrite of Martin Mueller’s original <a href="https://groups.google.com/g/beagleboard/c/K56ZiGu3p0c" target="_blank" rel="noopener noreferrer">omap3_usbload</a> circa 2008. Thanks to some lucky searching combined with the Internet Archive, I connected the dots between 2008 and the present. At some point before 2013, Rick Bronson <a href="https://web.archive.org/web/20120905211155/http://elinux.org/BeagleBoard#Serial_and_USB_boot" target="_blank" rel="noopener noreferrer">provided an update to omap3_usbload (along with a patch to TI’s X-Loader bootloader)</a> that enabled uploading additional files like a full U-Boot and Linux kernel into RAM after X-Loader, all through USB. This unlocked the ability to boot all the way to Linux from a completely blank BeagleBoard. Grant’s newer omap_loader utility also incorporates these same improvements.</p>



<p>All of this research was difficult. Many of the links I found pointed to sites like gitorious.org and arago-project.org, both of which no longer exist (although Arago’s Git repos are now <a href="https://git.ti.com/cgit/" target="_blank" rel="noopener noreferrer">hosted by TI</a>). eLinux.org’s BeagleBoard wiki was totally rearranged at some point and lost its info about USB recovery, and Rick’s site no longer exists, but as usual, the Internet Archive saved the day.</p>



<p>At some point later on, X-Loader was replaced by U-Boot SPL, so I think that is partially why so much of this info eventually disappeared from the web. But it’s a darn shame. This USB booting functionality is really cool, and it seems like most of the documentation for it has slowly gone by the wayside! The main breadcrumbs remaining on modern Google are the newer omap_loader utility, and also some references to Nest thermostats. For example, <a href="https://nest-open-source.googlesource.com/nest-learning-thermostat/5.9.4/x-loader/+/refs/heads/master/x-loader/drivers/usb/usb.c" target="_blank" rel="noopener noreferrer">Nest’s X-Loader had the USB patch applied</a> (with some tweaks added).</p>



<p>With all that research out of the way, I was ready to try it all out. I compiled omap_loader, grabbed the pre-built binary of x-load.bin that was included with Rick’s patchset, and also used a u-boot.bin that I had compiled myself using Buildroot while performing my UART tests with a modern kernel on the BeagleBoard. Then, I tried to load it:</p>



<pre>$ sudo ./omap_loader -p 0xd009 -f x-load.bin -f u-boot.bin -a 0x80800000 -j 0x80800000 -v<br />OMAP Loader 1.0.0<br />File 'x-load.bin' at 0x40200000, size 26956<br />File 'u-boot.bin' at 0x80800000, size 777760<br />[+] scanning for USB device matching 0451:d009...</pre>



<p>The idea behind this command is it sends X-Loader (x-load.bin) as the main payload that the OMAP’s on-chip bootloader is listening for over USB. Then, X-Loader starts up. Next, omap_loader sends any additional files using X-Loader’s USB protocol. In this case, I’ve supplied one extra file: u-boot.bin, which I told it to load into RAM at 0x80800000. Finally, the <code>-j 0x80800000</code> argument tells X-Loader to jump into U-Boot rather than hanging around doing nothing afterward.</p>



<p>The output of the command looked normal so far. I plugged in my BeagleBoard, which didn’t have an SD card inserted and also had its NAND flash erased, so it had no bootloader installed and thus it would attempt a USB boot.</p>



<pre>[+] successfully opened 0451:d009 (Texas Instruments OMAP3430)<br />[+] got ASIC ID - Num Subblocks [05], Device ID Info [01050134300757], Reserved [13020100], Ident Data [1215010000000000000000000000000000000000000000], Reserved [1415010000000000000000000000000000000000000000], CRC (4 bytes) [150901f7488f2800000000]<br />[-] fatal transfer error (BULK_OUT) for 26956 bytes (0 made it): LIBUSB_ERROR_PIPE<br />[-] failed to send file 'x-load.bin' (size 26956)<br />[-] failed to transfer the first stage file 'x-load.bin'</pre>



<p>Darn. The utility recognized the BeagleBoard being plugged in, but libusb errored out with a pipe error. Long story short, I messed around with a few other computers, and I found that a few of my older computers, old enough that they didn’t have USB 3.0 ports on their motherboards, actually worked perfectly fine with omap_loader. I couldn’t get it to work properly with most of my modern machines though, AMD or Intel.</p>



<p>I thought this would be a great application for a <a href="https://www.downtowndougbrown.com/2023/08/building-alex-taradovs-open-source-usb-sniffer/" target="_blank" rel="noopener noreferrer">USB sniffer</a>, so I decided to record some traces of success versus failure.</p>



<figure><a href="https://www.downtowndougbrown.com/wp-content/uploads/2025/11/img_5086.jpg" target="_blank" rel="noopener noreferrer"><img width="300" height="225" src="https://www.downtowndougbrown.com/wp-content/uploads/2025/11/img_5086-300x225.jpg" alt="" /></a></figure>



<p><a href="https://github.com/grant-h/omap_loader/issues/1#issuecomment-2138675431" target="_blank" rel="noopener noreferrer">Here’s a link to my in-depth investigation comparing success versus failure</a> on the GitHub issue about this problem. Yep, it turns out I wasn’t the only one running into this exact same issue. Grant himself was seeing similar problems, and had come to a similar conclusion that it seemed to be machine-dependent. Other people had mentioned that adding delays at certain points in the code seemed to help. I was intrigued, so I tried to get to the bottom of it.</p>



<p>Here’s what the USB boot process is supposed to look like, according to TI’s <a href="https://www.ti.com/lit/ug/spruf98y/spruf98y.pdf" target="_blank" rel="noopener noreferrer">OMAP35x Technical Reference Manual</a>:</p>



<ul>
<li>The OMAP device enumerates as a USB device.</li>



<li>Within 300 ms, the host needs to read an “ASIC ID” structure from the OMAP or else it will disconnect from USB.</li>



<li>Then, the host sends a 4-byte command: 0xF0030002 means to continue booting through USB.</li>



<li>Next, the host sends the 4-byte length of bootloader data it wants to transfer.</li>



<li>Finally, the host sends the bootloader (X-Loader in this case), which will be loaded into internal SRAM starting at 0x40200000.</li>



<li>After the OMAP device receives all of the data, it runs the received bootloader by jumping to 0x40200000.</li>
</ul>



<p>Again, this process worked perfectly fine on my older computers that don’t support USB 3.0, but on my newer computers with USB 3.0, it was hanging up. I did notice that the newer computers were trying to fit a lot more data into a single USB frame. For example, the start of my older computer’s communication with the OMAP looked like this:</p>



<ul>
<li><strong>Frame 1</strong>
<ul>
<li>Host sends boot command</li>



<li>OMAP confirms it</li>
</ul>
</li>



<li><strong>Frame 2</strong>
<ul>
<li>Host sends length</li>



<li>OMAP confirms it</li>
</ul>
</li>



<li><strong>Frame 3</strong>
<ul>
<li>Host sends first packet of bootloader data</li>



<li>OMAP confirms it</li>



<li>Host sends second packet of bootloader data</li>



<li>OMAP says it’s not ready</li>



<li>Host pings</li>



<li>OMAP says it’s ready now</li>



<li>Host sends second packet of bootloader data again</li>



<li>OMAP confirms it</li>
</ul>
</li>
</ul>



<p>And then from that point on, it was just a process of sending the rest of the data like that. About 5 data packets would fit into each frame. My newer computer’s traffic looked like this instead:</p>



<ul>
<li><strong>Frame 1</strong>
<ul>
<li>Host sends boot command</li>



<li>OMAP confirms it</li>



<li>Host sends length</li>



<li>OMAP says it’s not ready</li>



<li>Host pings a few times until the OMAP is ready</li>



<li>Host sends length again</li>



<li>OMAP confirms it</li>



<li>Host sends first packet of bootloader data</li>



<li>OMAP confirms it</li>



<li>Host sends second packet of bootloader data</li>



<li>OMAP says it’s not ready</li>



<li>Host pings several times, OMAP never says it’s ready during the rest of this frame</li>
</ul>
</li>



<li><strong>Frame 2</strong>
<ul>
<li>Host pings</li>



<li>OMAP responds with a STALL packet</li>
</ul>
</li>
</ul>



<p>The newer xHCI host controller was trying its best to efficiently squeeze a lot of packets into the first frame. Even though this is a pattern that should be perfectly valid to follow when communicating with a USB device, the OMAP bootloader was clearly not happy about something, and eventually sent a STALL packet before omap_loader made much progress. Various USB packet traces on different modern computers revealed similar issues. It would either STALL after the second packet, or just NAK forever and never accept additional incoming data.</p>



<p>Inspired by other comments about adding delays, I tried to work around this by inserting an artificial 1 ms delay before every <code>libusb_bulk_transfer()</code> call. This would force modern machines to slow down a little bit. As soon as I added those delays, all of my new computers had no trouble uploading X-Loader to the OMAP. So yeah, I think the OMAP just doesn’t like receiving USB data too quickly.</p>



<p>That wasn’t the end of this little project, though. The 1 ms delay fixed the issue with getting X-Loader to run, but the newer computers also ran into problems while trying to upload U-Boot through X-Loader!</p>



<pre>[-] device timed out while transfering in 512 bytes (got 0)<br />[-] device timed out while transfering in 512 bytes (got 0)<br />[-] device timed out while transfering in 512 bytes (got 0)<br />[-] failed to read command from X-Loader<br />[-] failed to transfer the additional files in to memory</pre>



<p>Rats. I went back to the USB sniffer for more research.</p>



<p>This time, it was a different problem. I found the point where the host would try to read the initial request from X-Loader: <code>USBf</code>. On my older computer, this worked fine; it received a 13-byte string from X-Loader: <code>USBffile req</code> followed by a null terminator. It was happy with this, and omap_usbload kept going on with the rest of the file load process and everything succeeded.</p>



<p>On the newer computer, some shenanigans were going on. Let’s look at the USB trace in depth:</p>



<figure><a href="https://www.downtowndougbrown.com/wp-content/uploads/2025/11/image-1.png" target="_blank" rel="noopener noreferrer"><img width="640" height="512" src="https://www.downtowndougbrown.com/wp-content/uploads/2025/11/image-1.png" alt="" /></a></figure>



<p>The 335-byte packet contains 332 actual bytes of data (the packet ID and CRC account for the other 3 bytes), and is the final chunk of X-Loader. It was successfully received and confirmed by the OMAP with an ACK. At that point, we can assume that the OMAP has begun jumping into X-Loader to start it up.</p>



<p>A millisecond later (due to the delay I added), we start trying to read from X-Loader. It’s clearly too soon, though; I don’t think X-Loader has finished starting up yet. There’s nothing ready to read. So these IN/NAK packets continue on for about 5 more milliseconds, which is totally normal. But then, something finally happens: the OMAP stops responding to our IN packets. My computer’s USB host controller tries three times (see the three IN packets in a row below?) and then it gives up. I’m guessing this is around the same time that X-Loader is doing its own hardware initialization, so maybe the OMAP’s USB controller is temporarily disabled.</p>



<figure><a href="https://www.downtowndougbrown.com/wp-content/uploads/2025/11/image-2.png" target="_blank" rel="noopener noreferrer"><img width="621" height="392" src="https://www.downtowndougbrown.com/wp-content/uploads/2025/11/image-2.png" alt="" /></a></figure>



<p>This all makes sense so far. We tried to read too quickly before X-Loader finished starting up, so when it did finally load, there was a brief moment where it would not respond to IN packets. The host controller didn’t like this and stopped trying, so all we saw from that point on was SOF packets because we weren’t attempting any more USB reads. Some of my other computers gave up after 15 unanswered IN packets instead of 3. I’m not sure if that’s a difference in the host controller or what, but it’s the same root problem.</p>



<p>You may be wondering: why didn’t the older computers run into this same issue? They were also trying to talk with X-Loader too early, so why wouldn’t they run into this same roadblock? The answer is that their older host controllers are more tolerant of the missing NAKs. I recorded a similar trace with one of my older computers that works fine without any patches to omap_loader. It also immediately began sending IN packets trying to read from X-Loader way too soon. Just like the problematic computers, it experienced a brief period where the OMAP stopped responding to INs with NAKs. The difference is that it didn’t abandon hope so quickly. There were 33 unanswered IN packets. After that, the OMAP continued responding with NAKs again and everything was fine from that point on. 17 ms after we had originally finished sending out X-Loader, the OMAP finally responded with an actual data packet. So that’s the total time it took for X-Loader to launch.</p>



<p>Back to the newer computers that weren’t playing nicely. I was still confused. Even though this is a problem with newer host controllers, omap_loader has a retry mechanism! If it fails to read X-Loader’s initial data, it will try again 2 seconds later. You’d think it would succeed at that point. Let’s see what happens:</p>



<figure><a href="https://www.downtowndougbrown.com/wp-content/uploads/2025/11/image-3.png" target="_blank" rel="noopener noreferrer"><img width="641" height="339" src="https://www.downtowndougbrown.com/wp-content/uploads/2025/11/image-3.png" alt="" /></a></figure>



<p>Ah, interesting. The retry is actually 3 seconds later. I’m guessing the first failed read attempt had a 1-second timeout, so then with a 2-second retry timer, that adds up to 3 seconds total.</p>



<p>Anyway, something funky happens here. The USB host <strong>finally </strong>reads the 13-byte string from X-Loader as a DATA1 packet (again, it shows up as 16 bytes because of the packet ID and CRC). The host then acknowledges reception with an ACK, but for some bizarre reason, it immediately continues attempting to read more data! I won’t show the whole trace, but the host keeps polling with IN packets for a whole second. And of course, they’re all NAKed. X-Loader knows it successfully sent data to us, so it has shifted over to waiting for the host to send an OUT packet instead. It’s like the host controller gets confused and expects X-Loader to send more data. The kernel never reports those 13 bytes back to libusb, even after the 1-second transfer timeout expires.</p>



<p>I don’t consider myself to be a USB expert, so maybe I’m misunderstanding something. This behavior just seems wrong, though. When my computer finally reads 13 bytes (proven by the sniffer trace shown above), why isn’t this data reported back to libusb? I would have expected the reception of a short DATA0/1 packet to cause the host controller to stop reading and return the data back immediately. Is this some kind of strange bug in the Linux kernel or the host controller hardware or something? I don’t know for sure. I find this behavior to be very odd, and I can’t explain it. My off-the-cuff guess is that the initial failure to respond to the three IN packets results in something getting out of sync in the host controller, but I really don’t know for sure. In my opinion, the retry <em>should</em> have worked, but clearly, something got confused. Not sure what. I don’t think it’s libusb’s fault, though.</p>



<p>I hate adding arbitrary delays in order to fix things, but a 20-millisecond delay between uploading X-Loader and attempting to read from it fixes this final issue. It ensures that the OMAP has been given ample time to launch X-Loader before we try reading from it, preventing the host controller from encountering the weird situation with unanswered IN packets.</p>



<p>After all of this tinkering and patching that I did to get things to play nicely on newer machines, here is a successful run of omap_loader:</p>



<pre>[+] successfully opened 0451:d009 (Texas Instruments OMAP3430)<br />[+] got ASIC ID - Num Subblocks [05], Device ID Info [01050134300757], Reserved [13020100], Ident Data [1215010000000000000000000000000000000000000000], Reserved [1415010000000000000000000000000000000000000000], CRC (4 bytes) [150901f7488f2800000000]<br />[+] uploading 'u-boot.bin' (size 777760) to 0x80800000<br />[+] jumping to address 0x80800000<br />[+] successfully transfered 2 files</pre>



<p>Meanwhile, the following output pops up on the BeagleBoard’s UART:</p>



<pre>Texas Instruments X-Loader 1.5.1 (Nov 15 2011 - 09:36:31)<br />Beagle Rev C4<br />Trying load from USB<br />USBLOAD_CMD_FILE total = 12 addr = 0x73425355 val = 0xbde20 val = 0x80800000<br />got file addr = 0x808bde20<br />USBLOAD_CMD_JUMP total = 8 addr = 0x6a425355 val = 0x80800000<br /><br /><br />U-Boot 2023.10 (May 25 2024 - 22:05:27 -0700)<br /><br />OMAP3530-GP ES3.1, CPU-OPP2, L3-165MHz, Max CPU Clock 720 MHz<br />Model: TI OMAP3 BeagleBoard<br />OMAP3 Beagle board + LPDDR/NAND<br />I2C:   ready<br />DRAM:  256 MiB<br />Core:  44 devices, 18 uclasses, devicetree: separate<br />NAND:  256 MiB<br />MMC:   OMAP SD/MMC: 0<br />Loading Environment from NAND... *** Warning - bad CRC, using default environment<br /><br />Beagle Rev C4<br />Timed out in wait_for_event: status=0000<br />Check if pads/pull-ups of bus are properly configured<br />No EEPROM on expansion board<br />OMAP die ID: 79b8000400000000040398da1401c009<br />Net:   No ethernet found.<br />Hit any key to stop autoboot:  2</pre>



<p>I believe the “Timed out in wait_for_event” error is harmless. Anyway, success! It loads U-Boot! You can imagine that I could have easily transmitted a Linux kernel and initramfs as well, and fully booted this thing over USB. Once U-Boot is running, I can do whatever I want.</p>



<p>With these simple delay tweaks, omap_loader works great on all modern computers I’ve thrown at it, including Raspberry Pis. The only “gotcha” I’ve encountered is that some slower computers (my i3-7100U laptop and a Raspberry Pi Zero) don’t forward the USB hotplug event through udev quickly enough before the BeagleBoard decides it’s not being asked to boot over USB. omap_loader never gets past scanning for a device, even though the <code>dmesg</code> log clearly shows that it was detected:</p>



<pre>[4076310.258842] usb 11-5: new high-speed USB device number 65 using xhci_hcd<br />[4076310.407944] usb 11-5: unable to get BOS descriptor or descriptor too short<br />[4076310.410041] usb 11-5: New USB device found, idVendor=0451, idProduct=d009, bcdDevice= 0.00<br />[4076310.410046] usb 11-5: New USB device strings: Mfr=33, Product=37, SerialNumber=0<br />[4076310.410051] usb 11-5: Product: OMAP3430<br />[4076310.410054] usb 11-5: Manufacturer: Texas Instruments<br />[4076310.710703] usb 11-5: USB disconnect, device number 65</pre>



<p>As you can see, it’s a very short timeframe; just like TI’s manual says, it only stays connected for about 300 ms if it doesn’t hear from the host. I guess that’s not enough time for udev on some computers. The only solution I found for this issue on my slower machines was to compile a custom version of libusb with udev disabled, which forces it to directly use netlink for hotplug detection instead.</p>



<p>My patch also limits libusb transfers to 512 bytes at a time. I don’t think this change is critical, though. It fixed an issue I ran into where my bus was really loaded and libusb reported a memory error. I don’t think it actually helps anything in most cases as long as people aren’t performing crazy big USB transfers at the same time.</p>



<p>In summary:</p>



<ul>
<li>Trying to write USB data to the OMAP’s on-chip bootloader too quickly seems to hit some edge cases that it doesn’t handle correctly. A 1 ms delay fixes this.</li>



<li>Trying to read from X-Loader before it’s ready to go irritates newer USB host controllers when they send out several IN packets without receiving any response (not even a NAK). A 20 ms delay fixes this.
<ul>
<li>Even retries afterward fail; the host controller gets out of sync due to the unanswered IN packets or something like that.</li>
</ul>
</li>



<li>On some slower computers, udev doesn’t give you enough time to respond to the OMAP’s 300 ms timeout, so libusb never detects the hotplug. This can be solved with a custom libusb that uses netlink instead of udev.</li>
</ul>



<p>I <a href="https://github.com/grant-h/omap_loader/pull/7" target="_blank" rel="noopener noreferrer">opened up a PR to submit these fixes (except for the udev thing) upstream to omap_loader in 2024</a>. Why am I writing about this now? Well, remember when I mentioned Nest earlier? <a href="https://support.google.com/googlenest/answer/16233096?hl=en" target="_blank" rel="noopener noreferrer">Google ended support for older Nest thermostats last month</a>, which <a href="https://github.com/grant-h/omap_loader/pull/7#issuecomment-3479819869" target="_blank" rel="noopener noreferrer">renewed some interest in merging my reliability improvements</a> so that people can flash custom firmware to their Nest thermostats. Those old Nest devices also use OMAP processors.</p>



<p>What it boils down to is: all this tinkering I did last year with pointlessly booting old BeagleBoards over USB accidentally ended up being useful. It helped out some <a href="https://github.com/codykociemba/NoLongerEvil-Thermostat" target="_blank" rel="noopener noreferrer">Nest thermostat revival projects</a> that have been <a href="https://github.com/cuckoo-nest/cuckoo_loader" target="_blank" rel="noopener noreferrer">popping up in the last month</a>. So I thought now might be a fun time to talk about my tiny involvement with that. Yay! It’s always fun when a random side project unexpectedly helps other people.</p>
</div> <footer class="article-footer" data-astro-cid-wrgicudb> <div class="action-row" data-astro-cid-wrgicudb> <a href="https://www.downtowndougbrown.com/2025/11/debugging-beagleboard-usb-boot-with-a-sniffer-fixing-omap_loader-on-modern-pcs/" target="_blank" rel="noopener noreferrer" class="read-original-btn" data-astro-cid-wrgicudb>
阅读原文 ↗
</a> </div> <div class="back-to-list" data-astro-cid-wrgicudb> <a href="/reading-list" class="back-link" data-astro-cid-wrgicudb>← 返回订阅列表</a> </div> </footer> </article> </div>  </main> <footer class="site-footer" aria-label="Site footer" data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <p class="footer-text" data-astro-cid-sz7xmlte>
&copy; 2026 AstroBlog
</p> <p class="footer-text" data-astro-cid-sz7xmlte>
Built with  <a href="https://astro.build/" target="_blank" rel="noopener noreferrer" class="footer-link" data-astro-cid-sz7xmlte>
Astro
</a> </p> </div> </footer>  </body></html> 