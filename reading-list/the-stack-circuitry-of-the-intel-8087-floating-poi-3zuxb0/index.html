<!DOCTYPE html><html lang="zh-CN" data-astro-cid-sckkx6r4> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.17.1"><meta name="description" content="早期微处理器在处理浮点数时非常缓慢。但1980年，英特尔推出了8087浮点协处理器，可执行浮点运算，速度最高可提升至100倍"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self'; font-src 'self' data:;"><link rel="canonical" href="https://blog.yuyins.com/reading-list/the-stack-circuitry-of-the-intel-8087-floating-poi-3zuxb0/"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://blog.yuyins.com/reading-list/the-stack-circuitry-of-the-intel-8087-floating-poi-3zuxb0/"><meta property="og:title" content="英特尔8087浮点芯片的堆栈电路，逆向工程"><meta property="og:description" content="早期微处理器在处理浮点数时非常缓慢。但1980年，英特尔推出了8087浮点协处理器，可执行浮点运算，速度最高可提升至100倍"><meta property="og:image" content="https://blog.yuyins.com/favicon.svg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://blog.yuyins.com/reading-list/the-stack-circuitry-of-the-intel-8087-floating-poi-3zuxb0/"><meta property="twitter:title" content="英特尔8087浮点芯片的堆栈电路，逆向工程"><meta property="twitter:description" content="早期微处理器在处理浮点数时非常缓慢。但1980年，英特尔推出了8087浮点协处理器，可执行浮点运算，速度最高可提升至100倍"><meta property="twitter:image" content="https://blog.yuyins.com/favicon.svg"><title>英特尔8087浮点芯片的堆栈电路，逆向工程</title><!-- Theme and color scheme script (runs before page loads to prevent flash) --><script>
			// 初始化配色方案 - 默认使用 stone-amber
			const colorScheme = localStorage.getItem('colorScheme') || 'stone-amber';
			document.documentElement.setAttribute('data-color', colorScheme);

			// 强制使用浅色主题
			document.documentElement.setAttribute('data-theme', 'light');
		</script><link rel="stylesheet" href="/_astro/_slug_.Da6PdEKR.css">
<style>.blog-post-container[data-astro-cid-wrgicudb]{width:100%;margin:0 auto;padding:2rem 0}.blog-post[data-astro-cid-wrgicudb]{width:100%;min-width:0;max-width:42rem;margin:0 auto}.article-header[data-astro-cid-wrgicudb]{margin-bottom:2rem;padding-bottom:1rem;border-bottom:1px solid var(--border)}.article-header[data-astro-cid-wrgicudb] h1[data-astro-cid-wrgicudb]{font-size:2rem;line-height:1.3;margin-bottom:1rem;font-weight:700;color:var(--foreground);word-break:break-word}.article-meta[data-astro-cid-wrgicudb]{display:flex;align-items:center;gap:.5rem;font-size:.875rem;color:var(--muted-foreground)}.source-tag[data-astro-cid-wrgicudb]{background-color:var(--muted);color:var(--foreground);padding:.125rem .5rem;border-radius:9999px;font-weight:500;font-size:.75rem;text-decoration:none;transition:opacity .2s}.source-tag[data-astro-cid-wrgicudb]:hover{opacity:.8}.separator[data-astro-cid-wrgicudb]{color:var(--border)}.article-content[data-astro-cid-wrgicudb]{line-height:1.8;margin-bottom:3rem;font-size:1.0625rem;color:var(--foreground)}.article-content[data-astro-cid-wrgicudb] h2{margin-top:2rem;margin-bottom:1rem;font-size:1.5rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] h3{margin-top:1.5rem;margin-bottom:.75rem;font-size:1.25rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] p{margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] a{color:var(--accent);text-decoration:underline;text-underline-offset:2px}.article-content[data-astro-cid-wrgicudb] img{max-width:100%;height:auto;border-radius:.5rem;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] blockquote{border-left:4px solid var(--border);padding-left:1rem;margin:1.5rem 0;color:var(--muted-foreground);font-style:italic}.article-content[data-astro-cid-wrgicudb] pre{background:var(--muted);padding:1rem;border-radius:.5rem;overflow-x:auto;font-family:monospace;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] ul,.article-content[data-astro-cid-wrgicudb] ol{padding-left:1.5rem;margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] li{margin-bottom:.5rem}.article-footer[data-astro-cid-wrgicudb]{padding-top:2rem;border-top:1px solid var(--border);display:flex;flex-direction:column;gap:1.5rem;align-items:center}.action-row[data-astro-cid-wrgicudb]{display:flex;justify-content:center}.read-original-btn[data-astro-cid-wrgicudb]{display:inline-flex;align-items:center;gap:.5rem;padding:.75rem 1.5rem;background-color:var(--foreground);color:var(--background);border-radius:.5rem;font-weight:500;text-decoration:none;transition:opacity .2s}.read-original-btn[data-astro-cid-wrgicudb]:hover{opacity:.9}.back-to-list[data-astro-cid-wrgicudb]{text-align:center}.back-link[data-astro-cid-wrgicudb]{color:var(--muted-foreground);text-decoration:none;font-size:.875rem;transition:color .2s}.back-link[data-astro-cid-wrgicudb]:hover{color:var(--foreground)}
</style></head> <body data-astro-cid-sckkx6r4> <a id="skip-to-content" href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-accent focus:text-background" data-astro-cid-sckkx6r4>Skip to content</a> <header class="header" data-astro-cid-3ef6ksr2> <nav class="header-nav" aria-label="Main navigation" data-astro-cid-3ef6ksr2> <a href="/" class="header-logo" data-astro-cid-3ef6ksr2>
AstroBlog
</a> <div class="header-links" data-astro-cid-3ef6ksr2> <ul class="nav-list" data-astro-cid-3ef6ksr2> <li data-astro-cid-3ef6ksr2> <a href="/" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 文章 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/category" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 分类 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/reading-list" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 订阅 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/about" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 关于 </a> </li> </ul> <div class="header-actions" data-astro-cid-3ef6ksr2> <div id="search" data-astro-cid-otpdt6jm> <button id="search-button" class="search-toggle" aria-label="打开搜索" title="搜索 (⌘K)" data-astro-cid-otpdt6jm> <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></circle> <path d="M20 20L16.5 16.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></path> </svg> </button> <dialog id="search-dialog" class="search-modal" data-astro-cid-otpdt6jm> <div class="modal-content" data-astro-cid-otpdt6jm> <div class="modal-header" data-astro-cid-otpdt6jm> <h2 class="modal-title" data-astro-cid-otpdt6jm>搜索文章</h2> <button id="close-search" class="close-button" aria-label="关闭搜索" data-astro-cid-otpdt6jm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-otpdt6jm></path> </svg> </button> </div> <div id="pagefind-ui" data-astro-cid-otpdt6jm></div> </div> </dialog> </div> <script type="module">let d=!1;const c="pagefind-loaded";async function l(t=0){if(sessionStorage.getItem(c)==="true")return g(),!0;const r=document.getElementById("pagefind-ui");if(!r)return!1;r.innerHTML='<div style="padding: 2rem; text-align: center; color: var(--muted-foreground);">加载中...</div>';try{return await new Promise((o,s)=>{const a=document.createElement("script");a.src="/pagefind/pagefind-ui.js",a.onload=o,a.onerror=s,document.head.appendChild(a)}),g(),sessionStorage.setItem(c,"true"),!0}catch(i){return console.error("Failed to load search:",i),t<2?(console.log(`Retrying search load... (${t+1}/2)`),await new Promise(o=>setTimeout(o,1e3)),l(t+1)):(r&&(r.innerHTML=`
          <div style="padding: 2rem; text-align: center;">
            <p style="color: var(--muted-foreground); margin-bottom: 1rem;">搜索功能加载失败</p>
            <button id="retry-search" style="padding: 0.5rem 1rem; background: var(--accent); color: var(--accent-foreground); border: none; border-radius: 0.375rem; cursor: pointer;">
              重试
            </button>
          </div>
        `,document.getElementById("retry-search")?.addEventListener("click",()=>{sessionStorage.removeItem(c),l(0)})),!1)}}function g(){typeof PagefindUI<"u"&&(new PagefindUI({element:"#pagefind-ui",showSubResults:!0,showImages:!1,excerptLength:15,translations:{placeholder:"搜索文章...",clear_search:"清除",load_more:"加载更多",search_label:"搜索此站点",filters_label:"筛选",zero_results:"未找到结果 [SEARCH_TERM]",many_results:"找到 [COUNT] 个结果 [SEARCH_TERM]",one_result:"找到 [COUNT] 个结果 [SEARCH_TERM]",alt_search:"未找到 [SEARCH_TERM] 的结果。显示 [DIFFERENT_TERM] 的结果",search_suggestion:"未找到 [SEARCH_TERM] 的结果。尝试以下搜索：",searching:"搜索中 [SEARCH_TERM]..."}}),setTimeout(()=>{const t=document.querySelector(".pagefind-ui__search-input");t instanceof HTMLElement&&t.focus()},100))}function u(){if(d)return;d=!0;const t=document.getElementById("search-button"),n=document.getElementById("search-dialog"),r=document.getElementById("close-search");if(!t||!n||!r)return;let i=sessionStorage.getItem(c)==="true";const o=async()=>{n.showModal(),document.body.style.overflow="hidden",i?setTimeout(()=>{const e=document.querySelector(".pagefind-ui__search-input");e instanceof HTMLElement&&e.focus()},100):await l()&&(i=!0)},s=()=>{n.close(),document.body.style.overflow=""},a=e=>{e.target===n&&s()},m=e=>{e.key==="Escape"&&n.open&&s()},f=e=>{(e.metaKey||e.ctrlKey)&&e.key==="k"&&(e.preventDefault(),n.open?s():o())};t.addEventListener("click",o),r.addEventListener("click",s),n.addEventListener("click",a),document.addEventListener("keydown",m),document.addEventListener("keydown",f),document.addEventListener("astro:before-swap",()=>{t.removeEventListener("click",o),r.removeEventListener("click",s),n.removeEventListener("click",a),document.removeEventListener("keydown",m),document.removeEventListener("keydown",f),d=!1},{once:!0})}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",u):u();document.addEventListener("astro:page-load",u);</script> <link href="/pagefind/pagefind-ui.css" rel="stylesheet">  </div> </div> </nav> </header>  <main id="main-content" data-pagefind-body class="main-content main-content--wide" data-astro-cid-sckkx6r4>  <div class="blog-post-container" data-astro-cid-wrgicudb> <article class="blog-post" data-astro-cid-wrgicudb> <header class="article-header" data-astro-cid-wrgicudb> <h1 data-astro-cid-wrgicudb>英特尔8087浮点芯片的堆栈电路，逆向工程</h1> <div class="article-meta" data-astro-cid-wrgicudb> <a href="https://righto.com" target="_blank" rel="noopener noreferrer" class="source-tag" data-astro-cid-wrgicudb>righto.com</a> <span class="separator" data-astro-cid-wrgicudb>·</span> <time data-astro-cid-wrgicudb>2025年12月9日</time> </div> </header> <!-- 使用清洗后的安全 HTML 内容 --> <div class="article-content app-prose" data-astro-cid-wrgicudb><p>Early microprocessors were very slow when operating with floating-point numbers.
But in 1980, Intel introduced the 8087 floating-point coprocessor, performing
floating-point operations up
to 100 times faster.
This was a huge benefit for IBM PC
applications such as AutoCAD, spreadsheets, and flight simulators.
The 8087 was so effective that today's computers still use a floating-point system based on the 8087.<span><a href="#fn:ieee-754" target="_blank" rel="noopener noreferrer">1</a></span></p>


<p>The 8087 was an extremely complex chip for its time, containing somewhere between
40,000 and 75,000 transistors, depending on the source.<span><a href="#fn:count" target="_blank" rel="noopener noreferrer">2</a></span>
To explore how the 8087 works, I opened up a chip and took numerous photos of the silicon die with a microscope.
Around the edges of the die, you can see the hair-thin bond wires that connect the chip to its 40 external pins.
The complex patterns on the die are formed by its metal wiring, as well as the polysilicon and silicon underneath.
The bottom half of the chip is the "datapath", the circuitry that performs calculations on 80-bit floating point values. 
At the left of the datapath, a <a href="https://www.righto.com/2020/05/extracting-rom-constants-from-8087-math.html" target="_blank" rel="noopener noreferrer">constant ROM</a> holds important constants such as π.
At the right are the eight registers that form the stack, along with the stack control circuitry.</p>
<p><a href="https://static.righto.com/images/8087-stack/8087-die-labeled.jpg" target="_blank" rel="noopener noreferrer"><img alt="Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5mm×6mm.  Click for a larger image." height="587" src="https://static.righto.com/images/8087-stack/8087-die-labeled-w450.jpg" title="Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5mm×6mm.  Click for a larger image." width="450" /></a></p><div>Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5mm×6mm.  Click for a larger image.</div><p></p>
<p>The chip's instructions are defined by the large <a href="https://www.righto.com/2018/09/two-bits-per-transistor-high-density.html" target="_blank" rel="noopener noreferrer">microcode ROM</a> in the middle.
This ROM is very unusual; it is semi-analog, storing two bits per transistor by using four transistor sizes.
To execute a floating-point instruction, the 8087 decodes the instruction and the microcode engine starts executing
the appropriate micro-instructions from the microcode ROM.
The decode circuitry to the right of the ROM generates the appropriate control signals from each micro-instruction.
The bus registers and control circuitry handle interactions with the main 8086 processor and the rest of the system.
Finally, the <a href="https://www.righto.com/2018/08/inside-die-of-intels-8087-coprocessor.html" target="_blank" rel="noopener noreferrer">bias generator</a>
uses a charge pump to create a negative voltage to bias the chip's substrate, the underlying silicon.</p>
<p>The stack registers and control circuitry (in red above) are the subject of this blog post. 
Unlike most processors, the 8087 organizes its registers in a stack, with instructions operating on the top of the stack.
For instance, the square root instruction replaces the value on the top of the stack with its square root.
You can also access a register relative to the top of the stack, for instance, adding the top value to the value two positions down from the top.
The stack-based architecture was intended to improve the instruction set, simplify compiler design, and make function
calls more efficient, although it didn't work as well as hoped.</p>
<p><a href="https://static.righto.com/images/8087-stack/stack-diagram.jpg" target="_blank" rel="noopener noreferrer"><img alt="The stack on the 8087. From The 8087 Primer, page 60." height="204" src="https://static.righto.com/images/8087-stack/stack-diagram-w350.jpg" title="The stack on the 8087. From The 8087 Primer, page 60." width="350" /></a></p><div>The stack on the 8087. From <i>The 8087 Primer</i>, page 60.</div><p></p>
<p>The diagram above shows how the stack operates. The stack consists of eight registers, with the Stack Top
(ST) indicating the current top of the stack.
To push a floating-point value onto the stack, the Stack Top is decremented and then the value is stored in the new top register.
A pop is performed by copying the value from the stack top and then incrementing the Stack Top.
In comparison, most processors specify registers directly, so register 2 is always the same register.</p>
<h2>The registers</h2>
<p>The stack registers occupy a substantial area on the die of the 8087 because floating-point numbers take many bits.
A floating-point number consists of a fractional part (sometimes called the mantissa or significand), along with
the exponent part; the exponent allows floating-point numbers to cover a range from extremely small to extremely
large.
In the 8087, floating-point numbers are 80 bits: 64 bits of significand, 15 bits of exponent, and a sign bit.
An 80-bit register was very large in the era of 8-bit or 16-bit computers; the eight registers in the 8087
would be equivalent to 40 registers in the 8086 processor.</p>
<p><a href="https://static.righto.com/images/8087-stack/registers.jpg" target="_blank" rel="noopener noreferrer"><img alt="The registers in the 8087 form an 8×80 grid of cells. The close-up shows an 8×8 block. I removed the metal layer with acid to reveal the underlying silicon circuitry." height="684" src="https://static.righto.com/images/8087-stack/registers-w500.jpg" title="The registers in the 8087 form an 8×80 grid of cells. The close-up shows an 8×8 block. I removed the metal layer with acid to reveal the underlying silicon circuitry." width="500" /></a></p><div>The registers in the 8087 form an 8×80 grid of cells. The close-up shows an 8×8 block. I removed the metal layer with acid to reveal the underlying silicon circuitry.</div><p></p>
<p>The registers store each bit in a static RAM cell. Each cell has two inverters connected in a loop.
This circuit forms a stable feedback loop, with one inverter on and one inverter off.
Depending on which inverter is on, the circuit stores a 0 or a 1.
To write a new value into the circuit, one of the lines is pulled low, flipping the loop into the desired state.
The trick is that each inverter uses a very weak transistor to pull the output high, so its output is easily overpowered
to change the state.</p>
<p><a href="https://static.righto.com/images/8087-stack/inverter-loop.png" target="_blank" rel="noopener noreferrer"><img alt="Two inverters in a loop can store a 0 or a 1." height="121" src="https://static.righto.com/images/8087-stack/inverter-loop-w250.png" title="Two inverters in a loop can store a 0 or a 1." width="250" /></a></p><div>Two inverters in a loop can store a 0 or a 1.</div><p></p>
<p>These inverter pairs are arranged in an 8 × 80 grid that implements eight words of 80 bits. Each of the 80 rows has two <em>bitlines</em> that provide access to a bit.
The bitlines provide both read and write access to a bit; the pair of bitlines allows either inverter to be pulled low to store the desired bit value.
Eight vertical <em>wordlines</em> enable access to one word, one column of 80 bits.
Each wordline turns on 160 pass transistors, connecting the bitlines to the inverters in the selected column.
Thus, when a wordline is enabled, the bitlines can be used to read or write that word.</p>
<p>Although the chip looks two-dimensional, it actually consists of multiple layers.
The bottom layer is silicon.
The pinkish regions below are where the silicon has been "doped" to change its electrical properties, making it an active
part of the circuit.
The doped silicon forms a grid of horizontal and vertical wiring, with larger doped regions in the middle.
On top of the silicon, polysilicon wiring provides two functions. First, it provides a layer of wiring to connect the circuit.
But more importantly, when polysilicon crosses doped silicon, it forms a transistor. The polysilicon provides the gate, turning the transistor on and off.
In this photo, the polysilicon is barely visible, so I've highlighted part of it in red.
Finally, horizontal metal wires provide a third layer of interconnecting wiring.
Normally, the metal hides the underlying circuitry, so I removed the metal with acid for this photo.
I've drawn blue lines to represent the metal layer.
Contacts provide connections between the various layers.</p>
<p><a href="https://static.righto.com/images/8087-stack/memory-cell-layers.jpg" target="_blank" rel="noopener noreferrer"><img alt="A close-up of a storage cell in the registers. The metal layer and most of the polysilicon have been removed to show the underlying silicon." height="336" src="https://static.righto.com/images/8087-stack/memory-cell-layers-w500.jpg" title="A close-up of a storage cell in the registers. The metal layer and most of the polysilicon have been removed to show the underlying silicon." width="500" /></a></p><div>A close-up of a storage cell in the registers. The metal layer and most of the polysilicon have been removed to show the underlying silicon.</div><p></p>
<p>The layers combine to form the inverters and selection transistors of a memory cell, indicated with the dotted line below.
There are six transistors (yellow), where polysilicon crosses doped silicon. Each inverter has a transistor that
pulls the output low and a weak transistor to pull the output high.
When the word line (vertical polysilicon) is active, it connects the selected inverters to the bit lines (horizontal metal) through the two selection
transistors.
This allows the bit to be read or written.</p>
<p><a href="https://static.righto.com/images/8087-stack/memory-cell-labeled.jpg" target="_blank" rel="noopener noreferrer"><img alt="The function of the circuitry in a storage cell." height="303" src="https://static.righto.com/images/8087-stack/memory-cell-labeled-w500.jpg" title="The function of the circuitry in a storage cell." width="500" /></a></p><div>The function of the circuitry in a storage cell.</div><p></p>
<p>Each register has two tag bits associated with it, an unusual form of metadata to indicate
if the register is empty, contains zero, contains a valid value, or
contains a special value such as infinity.
The tag bits are used to optimize performance internally and are mostly irrelevant to the programmer.
As well as being accessed with a register, the tag bits can be accessed in parallel as a 16-bit "Tag Word".
This allows the tags to be saved or loaded as part of the 8087's state, for instance,
during interrupt handling.</p>
<h2>The decoder</h2>
<p>The decoder circuit, wedged into the middle of the register file, selects one of the registers.
A register is specified internally with a 3-bit value. The decoder circuit energizes one of the eight register select
lines based on this value.</p>
<p>The decoder circuitry is straightforward: it has eight 3-input NOR gates to match one of the eight bit patterns.
The select line is then powered through a high-current driver that uses large transistors.
(In the photo below, you can compare the large serpentine driver transistors to the small transistors in a bit cell.)</p>
<p><a href="https://static.righto.com/images/8087-stack/decoder.jpg" target="_blank" rel="noopener noreferrer"><img alt="The decoder circuitry has eight similar blocks to drive the eight select lines." height="273" src="https://static.righto.com/images/8087-stack/decoder-w600.jpg" title="The decoder circuitry has eight similar blocks to drive the eight select lines." width="600" /></a></p><div>The decoder circuitry has eight similar blocks to drive the eight select lines.</div><p></p>
<p>The decoder has an interesting electrical optimization.
As shown earlier, the register select lines are eight polysilicon lines running vertically, the length of the
register file. 
Unfortunately, polysilicon has fairly high resistance, better than silicon but much worse than metal.
The problem is that the resistance of a long polysilicon line will slow down the system.
That is, the capacitance of transistor gates in combination with high resistance causes an RC (resistive-capacitive) delay in the signal.</p>
<p>The solution is that the register select lines also run in the metal layer, a second set of lines immediately to the
right of the register file.
These lines branch off from the register file about 1/3 of the way down, run to the bottom, and then connect back
to the polysilicon select lines at the bottom.
This reduces the maximum resistance through a select line, increasing the speed.</p>
<p><a href="https://static.righto.com/images/8087-stack/select.jpg" target="_blank" rel="noopener noreferrer"><img alt="A diagram showing how 8 metal lines run parallel to the main select lines. The register file is much taller than shown; the middle has been removed to make the diagram fit." height="419" src="https://static.righto.com/images/8087-stack/select-w300.jpg" title="A diagram showing how 8 metal lines run parallel to the main select lines. The register file is much taller than shown; the middle has been removed to make the diagram fit." width="300" /></a></p><div>A diagram showing how 8 metal lines run parallel to the main select lines. The register file is much taller than shown; the middle has been removed to make the diagram fit.</div><p></p>
<h2>The stack control circuitry</h2>
<p>A stack needs more control circuitry than a regular register file, since the circuitry must keep track of the
position of the top of the stack.<span><a href="#fn:status-word" target="_blank" rel="noopener noreferrer">3</a></span>
The control circuitry increments and decrements the top of stack (TOS) pointer as values are pushed or popped
(purple).<span><a href="#fn:patents" target="_blank" rel="noopener noreferrer">4</a></span>
Moreover, an 8087 instruction can access a register based on its offset, for instance the third register
from the top.
To support this, the control circuitry can temporarily add an offset to the top of stack position (green).
A multiplexer (red) selects either the top of stack or the adder output, and feeds it to the decoder (blue),
which selects one of the eight stack registers in the register file (yellow), as described earlier.</p>
<p><a href="https://static.righto.com/images/8087-stack/patent-diagram.jpg" target="_blank" rel="noopener noreferrer"><img alt="The register stack in the 8087. Adapted from Patent USRE33629E. I don't know what the GRX field is. I also don't know why this shows a subtractor and not an adder." height="378" src="https://static.righto.com/images/8087-stack/patent-diagram-w700.jpg" title="The register stack in the 8087. Adapted from Patent USRE33629E. I don't know what the GRX field is. I also don't know why this shows a subtractor and not an adder." width="700" /></a></p><div>The register stack in the 8087. Adapted from <a href="https://patents.google.com/patent/USRE33629E" target="_blank" rel="noopener noreferrer">Patent USRE33629E</a>. I don't know what the GRX field is. I also don't know why this shows a subtractor and not an adder.</div><p></p>


<p>The physical implementation of the stack circuitry is shown below.
The logic at the top selects the stack operation based on the 16-bit micro-instruction.<span><a href="#fn:microcode" target="_blank" rel="noopener noreferrer">5</a></span>
Below that are the three latches that hold the top of stack value.
(The large white squares look important, but they are simply "jumpers" from the ground line to the circuitry, passing
under metal wires.)</p>
<p><a href="https://static.righto.com/images/8087-stack/stack-circuitry.jpg" target="_blank" rel="noopener noreferrer"><img alt="The stack control circuitry. The blue regions on the right are oxide residue that remained when I dissolved the metal rail for the 5V power.
" height="653" src="https://static.righto.com/images/8087-stack/stack-circuitry-w350.jpg" title="The stack control circuitry. The blue regions on the right are oxide residue that remained when I dissolved the metal rail for the 5V power.
" width="350" /></a></p><div>The stack control circuitry. The blue regions on the right are oxide residue that remained when I dissolved the metal rail for the 5V power.
</div><p></p>
<p>The three-bit adder is at the bottom, along with the multiplexer.
You might expect the adder to use a simple "full adder" circuit. Instead, it is
a faster <a href="https://en.wikipedia.org/wiki/Carry-lookahead_adder" target="_blank" rel="noopener noreferrer">carry-lookahead</a> adder.
I won't go into details here, but the summary is that at each bit position, an AND gate produces a Carry Generate
signal while an XOR gate produces a Carry Propagate signal.
Logic gates combine these signals to produce the output bits in parallel, avoiding the slowdown of the carry rippling
through the bits.</p>
<p>The incrementer/decrementer uses a completely different approach.
Each of the three bits uses a toggle flip-flop.
A few logic gates determine if each bit should be toggled or should keep its previous value.
For instance, when incrementing, the top bit is toggled if the lower bits are 11 (e.g. incrementing from 011 to 100).
For decrementing, the top bit is toggled if the lower bits are 00 (e.g. 100 to 011).
Simpler logic determines if the middle bit should be toggled.
The bottom bit is easier, toggling every time whether incrementing or decrementing.</p>
<p>The schematic below shows the circuitry for one bit of the stack.
Each bit is implemented with a moderately complicated flip-flop that can be cleared, loaded with
a value, or toggled, based on control signals from the microcode.
The flip-flop is constructed from two set-reset (SR) latches. Note that the flip-flop outputs are crossed when fed back
to the input, providing the inversion for the toggle action.
At the right, the multiplexer selects either the register value or the sum from the adder (not shown), generating the signals
to the decoder.</p>
<p><a href="https://static.righto.com/images/8087-stack/stack-schematic.jpg" target="_blank" rel="noopener noreferrer"><img alt="Schematic of one bit of the stack." height="294" src="https://static.righto.com/images/8087-stack/stack-schematic-w700.jpg" title="Schematic of one bit of the stack." width="700" /></a></p><div>Schematic of one bit of the stack.</div><p></p>
<h2>Drawbacks of the stack approach</h2>
<p>According to the designers of the 8087,<span><a href="#fn:references" target="_blank" rel="noopener noreferrer">7</a></span>
the main motivation for using a stack rather than a flat register set was that instructions didn't have enough bits to address multiple register operands.
In addition, a stack has "advantages over general registers for expression parsing and nested function calls."
That is, a stack works well for a mathematical expression since sub-expressions can be evaluated on the top
of the stack.
And for function calls, you avoid the cost of saving registers to memory, since the subroutine can use the stack without disturbing the values underneath.
At least that was the idea.</p>


<p>The main problem is "stack overflow".
The 8087's stack has eight entries, so if you push a ninth value onto the stack, the stack will overflow.
Specifically, the top-of-stack pointer will wrap around, obliterating the bottom value on the stack.
The 8087 is designed to detect a stack overflow using the register tags:
pushing a value to a non-empty register triggers an invalid operation exception.<span><a href="#fn:underflow" target="_blank" rel="noopener noreferrer">6</a></span></p>
<p>The designers expected that stack overflow would be rare and could be handled by the operating system (or library code).
After detecting a stack overflow, the software should dump the existing stack to memory to
provide the illusion of an infinite stack.
Unfortunately, bad design decisions made it difficult "both technically and commercially" to handle stack overflow.</p>
<p>One of the 8087's designers (Kahan) attributes the 8087's stack problems to the time difference between California,
where the designers lived, and Israel, where the 8087 was implemented.
Due to a lack of communication, each team thought the other was implementing the overflow software.
It wasn't until the
8087 was in production that they realized that "it might not be possible to handle 8087 stack underflow/overflow in a reasonable way. It's not impossible, just impossible to do it in a reasonable way."</p>
<p>As a result, the stack was largely a problem rather than a solution.
Most 8087 software saved the full stack to memory before performing
a function call, creating more memory traffic.
Moreover, compilers turned out to work better with regular registers than a stack,
so compiler writers awkwardly used the stack to emulate regular registers.
The <code>GCC</code> compiler <a href="https://langdev.stackexchange.com/a/2408" target="_blank" rel="noopener noreferrer">reportedly</a> needs 3000 lines of extra code to support the x87 stack.</p>
<p>In the 1990s, Intel introduced a new floating-point system called <a href="https://www.cs.uaf.edu/2012/fall/cs301/lecture/11_02_other_float.html" target="_blank" rel="noopener noreferrer">SSE</a>, followed by AVX in 2011.
These systems use regular (non-stack) registers and provide parallel operations for higher performance,
making the 8087's stack instructions largely obsolete.</p>
<h2>The success of the 8087</h2>
<p>At the start, Intel was unenthusiastic about producing the 8087, viewing it as unlikely to be a success.
John Palmar, a principal architect of the chip, had little success convincing
skeptical Intel management that the market for the 8087 was enormous.
Eventually,
he said, "I'll tell you what. I'll relinquish my salary, provided you'll write down your number of how many you expect to sell, then give me a dollar for every one you sell beyond that."<span><a href="#fn:references" target="_blank" rel="noopener noreferrer">7</a></span>
Intel didn't agree to the deal—which would have made a fortune for Palmer—but they reluctantly agreed to produce the chip.</p>
<p>Intel's Santa Clara engineers shunned the 8087, considering it unlikely to work:
the 8087 would be two to three times more complex than the 8086,
with a die so large that a wafer might not have a single working die.
Instead, Rafi Nave, at Intel's Israel site, took on the risky project: “Listen, everybody knows it's not going to work, so if it won't work, I would just fulfill their expectations or their assessment.
If, by chance, it works, okay, then we'll gain tremendous respect and tremendous breakthrough on our abilities.”</p>
<p>A small team of seven engineers developed the 8087 in Israel.
They designed the chip on Mylar sheets: a millimeter on Mylar represented a micron on the physical chip.
The drawings were then digitized on a Calma system by clicking on each polygon to create the layout.
When the chip was moved into production,
the yield was very low but better than feared: two working dies per four-inch wafer.</p>
<p>The 8087 ended up being a large success, said to have been Intel's most profitable product line at times.
The success of the 8087 (along with the 8088) cemented the reputation of Intel Israel, which eventually became Israel's largest tech employer.
The benefits of floating-point hardware proved to be so great that Intel integrated the floating-point unit into later processors
starting with the 80486 (1989).
Nowadays, most modern computers, from cellphones to mainframes, provide floating point based on the
8087,
so I consider the 8087 one of the most influential chips ever created.</p>
<p>For more, follow me on
 Bluesky (<a href="https://bsky.app/profile/righto.com" target="_blank" rel="noopener noreferrer">@righto.com</a>),
Mastodon (<a href="https://oldbytes.space/@kenshirriff" target="_blank" rel="noopener noreferrer">@kenshirriff@oldbytes.space</a>),
or <a href="http://www.righto.com/feeds/posts/default" target="_blank" rel="noopener noreferrer">RSS</a>.
I wrote some articles about the 8087 a few years ago, including <a href="https://www.righto.com/2018/08/inside-die-of-intels-8087-coprocessor.html" target="_blank" rel="noopener noreferrer">the die</a>,
<a href="https://www.righto.com/2018/09/two-bits-per-transistor-high-density.html" target="_blank" rel="noopener noreferrer">the ROM</a>,
the <a href="https://www.righto.com/2020/05/die-analysis-of-8087-math-coprocessors.html" target="_blank" rel="noopener noreferrer">bit shifter</a>,
and <a href="https://www.righto.com/2020/05/extracting-rom-constants-from-8087-math.html" target="_blank" rel="noopener noreferrer">the constants</a>, so you may have seen some of this material before.</p>
<h2>Notes and references</h2>
<div>
<ol>
<li>
<p>Most computers now use the <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener noreferrer">IEEE 754</a> floating-point standard,
which is based on the 8087.
This standard has been awarded a
<a href="https://ethw.org/Milestones:IEEE_Standard_754_for_Binary_Floating-Point_Arithmetic,_1985" target="_blank" rel="noopener noreferrer">milestone</a> in computation. <a href="#fnref:ieee-754" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>Curiously, reliable sources differ on the number of transistors in the 8087 by almost a factor of 2.
  Intel says <a href="https://www.intel.com/content/dam/www/public/us/en/documents/case-studies/floating-point-case-study.pdf?page=5" target="_blank" rel="noopener noreferrer">40,000</a>, as does designer William Kahan (<a href="https://web.archive.org/web/20190301193516/http://www.drdobbs.com/architecture-and-design/a-conversation-with-william-kahan/184410314" target="_blank" rel="noopener noreferrer">link</a>).
  But in <a href="https://doi.org/10.1109/ISSCC.1980.1156144" target="_blank" rel="noopener noreferrer">A Numeric Data Processor</a>, designers Rafi Nave and John Palmer wrote that the chip contains "the equivalent of over 65,000 devices" (whatever "equivalent" means).
  This number is echoed by a contemporary <a href="https://www.worldradiohistory.com/Archive-Electronics/80s/80/Electronics-1980-02-14.pdf" target="_blank" rel="noopener noreferrer">article</a> in <em>Electronics</em> (1980) that says "over 65,000 H-MOS transistors on a 78,000-mil<sup>2</sup> die."
  Many other sources, such as <a href="https://vtda.org/books/Computing/Hardware/Upgrading%20and%20Repairing%20PCs/URP_4th_edition.pdf?page=238" target="_blank" rel="noopener noreferrer">Upgrading &amp; Repairing PCs</a>, specify 45,000 transistors.
  Designer Rafi Nave <a href="https://www.computerhistory.org/collections/catalog/300000148/" target="_blank" rel="noopener noreferrer">stated</a> that the 8087 has
  63,000 or 64,000 transistors if you count the ROM transistors directly, but if you count ROM transistors as
  equivalent to two transistors, then you get about 75,000 transistors. <a href="#fnref:count" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>The 8087 has a 16-bit Status Word that
contains the stack top pointer, exception flags, the four-bit
condition code, and other values.
Although the Status Word appears to be a 16-bit register, it is not implemented as a register.
Instead, parts of the Status Word are stored in various places around the chip: the stack top pointer is
in the stack circuitry, the exception flags are part of the interrupt circuitry, the condition code bits are
next to the datapath, and so on.
When the Status Word is read or written, these various circuits are connected to the 8087's internal data
bus, making the Status Word appear to be a monolithic entity.
Thus, the stack circuitry includes support for reading and writing it. <a href="#fnref:status-word" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>Intel filed several patents on the 8087, including <a href="https://patents.google.com/patent/USRE33629E" target="_blank" rel="noopener noreferrer">Numeric data processor</a>,
another <a href="https://patents.google.com/patent/US4338675A" target="_blank" rel="noopener noreferrer">Numeric data processor</a>,
<a href="https://patents.google.com/patent/US4509144A" target="_blank" rel="noopener noreferrer">Programmable bidirectional shifter</a>,
<a href="https://patents.google.com/patent/US4484259A" target="_blank" rel="noopener noreferrer">Fraction bus for use in a numeric data processor</a>, and
<a href="https://patents.google.com/patent/US4257095A" target="_blank" rel="noopener noreferrer">System bus arbitration, circuitry and methodology</a>. <a href="#fnref:patents" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>I started looking at the stack in detail to reverse engineer the micro-instruction format and determine how the
8087's microcode works.
I'm working with the "Opcode Collective" on Discord on this project, but progress is slow due to the complexity of
the micro-instructions. <a href="#fnref:microcode" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>The 8087 detects stack underflow in a similar manner. If you pop more values from the stack than are present,
the tag will indicate that the register is empty and shouldn't be accessed. This triggers an invalid operation
exception. <a href="#fnref:underflow" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>The 8087 is described in detail in <a href="https://ethw.org/w/images/2/2f/Intel_8086_family_users_numeric_supp.pdf" target="_blank" rel="noopener noreferrer">The 8086 Family User's Manual, Numerics Supplement</a>.
  An overview of the stack is on page 60 of <em>The 8087 Primer</em> by Palmer and Morse.
  More details are in Kahan's <a href="https://web.archive.org/web/20170118054747/https://cims.nyu.edu/~dbindel/class/cs279/87stack.pdf" target="_blank" rel="noopener noreferrer">On the Advantages of the 8087's Stack</a>, 
  an unpublished course note (maybe for <a href="https://www.researchgate.net/profile/David-Bindel/publication/2585992_CS_279_Annotated_Course_Bibliography/links/545794630cf26d5090ab49a6/CS-279-Annotated-Course-Bibliography.pdf" target="_blank" rel="noopener noreferrer">CS 279</a>?) with a date of Nov 2, 1990 or perhaps <a href="https://www.netlib.org/bibnet/authors/k/kahan-william-m.pdf#page=21" target="_blank" rel="noopener noreferrer">August 23, 1994</a>.
  Kahan discusses why the 8087's design makes it hard to handle stack overflow in <a href="https://web.archive.org/web/20190301193516/http://www.drdobbs.com/architecture-and-design/a-conversation-with-william-kahan/184410314" target="_blank" rel="noopener noreferrer">How important is numerical accuracy</a>, Dr. Dobbs, Nov. 1997.
  Another information source is the <a href="https://www.youtube.com/watch?v=JRSUmuWiTOs" target="_blank" rel="noopener noreferrer">Oral History of Rafi Nave</a> <a href="#fnref:references" target="_blank" rel="noopener noreferrer">↩</a><a href="#fnref2:references" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
</ol>
</div>
</div> <footer class="article-footer" data-astro-cid-wrgicudb> <div class="action-row" data-astro-cid-wrgicudb> <a href="http://www.righto.com/2025/12/8087-stack-circuitry.html" target="_blank" rel="noopener noreferrer" class="read-original-btn" data-astro-cid-wrgicudb>
阅读原文 ↗
</a> </div> <div class="back-to-list" data-astro-cid-wrgicudb> <a href="/reading-list" class="back-link" data-astro-cid-wrgicudb>← 返回订阅列表</a> </div> </footer> </article> </div>  </main> <footer class="site-footer" aria-label="Site footer" data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <p class="footer-text" data-astro-cid-sz7xmlte>
&copy; 2026 AstroBlog
</p> <p class="footer-text" data-astro-cid-sz7xmlte>
Built with  <a href="https://astro.build/" target="_blank" rel="noopener noreferrer" class="footer-link" data-astro-cid-sz7xmlte>
Astro
</a> </p> </div> </footer>  </body></html> 