<!DOCTYPE html><html lang="zh-CN" data-astro-cid-sckkx6r4> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.17.1"><meta name="description" content="在完成Sebastian Raschka《从头开始构建大语言模型》主体内容后，我继续推进'附加课题'研究。通过成功训练GPT-2小模型验证方案可行性（目前云平台的基准模型已可从头开始训练）。"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self'; font-src 'self' data:;"><link rel="canonical" href="https://blog.yuyins.com/reading-list/writing-an-llm-from-scratch-part-29----using-distr-2osfty/"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://blog.yuyins.com/reading-list/writing-an-llm-from-scratch-part-29----using-distr-2osfty/"><meta property="og:title" content="从零开始构建大语言模型第29部分——在云端使用DistributedDataParallel从头训练基础模型"><meta property="og:description" content="在完成Sebastian Raschka《从头开始构建大语言模型》主体内容后，我继续推进'附加课题'研究。通过成功训练GPT-2小模型验证方案可行性（目前云平台的基准模型已可从头开始训练）。"><meta property="og:image" content="https://blog.yuyins.com/favicon.svg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://blog.yuyins.com/reading-list/writing-an-llm-from-scratch-part-29----using-distr-2osfty/"><meta property="twitter:title" content="从零开始构建大语言模型第29部分——在云端使用DistributedDataParallel从头训练基础模型"><meta property="twitter:description" content="在完成Sebastian Raschka《从头开始构建大语言模型》主体内容后，我继续推进'附加课题'研究。通过成功训练GPT-2小模型验证方案可行性（目前云平台的基准模型已可从头开始训练）。"><meta property="twitter:image" content="https://blog.yuyins.com/favicon.svg"><title>从零开始构建大语言模型第29部分——在云端使用DistributedDataParallel从头训练基础模型</title><!-- Theme and color scheme script (runs before page loads to prevent flash) --><script>
			// 初始化配色方案 - 默认使用 stone-amber
			const colorScheme = localStorage.getItem('colorScheme') || 'stone-amber';
			document.documentElement.setAttribute('data-color', colorScheme);

			// 强制使用浅色主题
			document.documentElement.setAttribute('data-theme', 'light');
		</script><link rel="stylesheet" href="/_astro/_slug_.Da6PdEKR.css">
<style>.blog-post-container[data-astro-cid-wrgicudb]{width:100%;margin:0 auto;padding:2rem 0}.blog-post[data-astro-cid-wrgicudb]{width:100%;min-width:0;max-width:42rem;margin:0 auto}.article-header[data-astro-cid-wrgicudb]{margin-bottom:2rem;padding-bottom:1rem;border-bottom:1px solid var(--border)}.article-header[data-astro-cid-wrgicudb] h1[data-astro-cid-wrgicudb]{font-size:2rem;line-height:1.3;margin-bottom:1rem;font-weight:700;color:var(--foreground);word-break:break-word}.article-meta[data-astro-cid-wrgicudb]{display:flex;align-items:center;gap:.5rem;font-size:.875rem;color:var(--muted-foreground)}.source-tag[data-astro-cid-wrgicudb]{background-color:var(--muted);color:var(--foreground);padding:.125rem .5rem;border-radius:9999px;font-weight:500;font-size:.75rem;text-decoration:none;transition:opacity .2s}.source-tag[data-astro-cid-wrgicudb]:hover{opacity:.8}.separator[data-astro-cid-wrgicudb]{color:var(--border)}.article-content[data-astro-cid-wrgicudb]{line-height:1.8;margin-bottom:3rem;font-size:1.0625rem;color:var(--foreground)}.article-content[data-astro-cid-wrgicudb] h2{margin-top:2rem;margin-bottom:1rem;font-size:1.5rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] h3{margin-top:1.5rem;margin-bottom:.75rem;font-size:1.25rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] p{margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] a{color:var(--accent);text-decoration:underline;text-underline-offset:2px}.article-content[data-astro-cid-wrgicudb] img{max-width:100%;height:auto;border-radius:.5rem;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] blockquote{border-left:4px solid var(--border);padding-left:1rem;margin:1.5rem 0;color:var(--muted-foreground);font-style:italic}.article-content[data-astro-cid-wrgicudb] pre{background:var(--muted);padding:1rem;border-radius:.5rem;overflow-x:auto;font-family:monospace;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] ul,.article-content[data-astro-cid-wrgicudb] ol{padding-left:1.5rem;margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] li{margin-bottom:.5rem}.article-footer[data-astro-cid-wrgicudb]{padding-top:2rem;border-top:1px solid var(--border);display:flex;flex-direction:column;gap:1.5rem;align-items:center}.action-row[data-astro-cid-wrgicudb]{display:flex;justify-content:center}.read-original-btn[data-astro-cid-wrgicudb]{display:inline-flex;align-items:center;gap:.5rem;padding:.75rem 1.5rem;background-color:var(--foreground);color:var(--background);border-radius:.5rem;font-weight:500;text-decoration:none;transition:opacity .2s}.read-original-btn[data-astro-cid-wrgicudb]:hover{opacity:.9}.back-to-list[data-astro-cid-wrgicudb]{text-align:center}.back-link[data-astro-cid-wrgicudb]{color:var(--muted-foreground);text-decoration:none;font-size:.875rem;transition:color .2s}.back-link[data-astro-cid-wrgicudb]:hover{color:var(--foreground)}
</style></head> <body data-astro-cid-sckkx6r4> <a id="skip-to-content" href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-accent focus:text-background" data-astro-cid-sckkx6r4>Skip to content</a> <header class="header" data-astro-cid-3ef6ksr2> <nav class="header-nav" aria-label="Main navigation" data-astro-cid-3ef6ksr2> <a href="/" class="header-logo" data-astro-cid-3ef6ksr2>
AstroBlog
</a> <div class="header-links" data-astro-cid-3ef6ksr2> <ul class="nav-list" data-astro-cid-3ef6ksr2> <li data-astro-cid-3ef6ksr2> <a href="/" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 文章 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/category" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 分类 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/reading-list" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 订阅 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/about" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 关于 </a> </li> </ul> <div class="header-actions" data-astro-cid-3ef6ksr2> <div id="search" data-astro-cid-otpdt6jm> <button id="search-button" class="search-toggle" aria-label="打开搜索" title="搜索 (⌘K)" data-astro-cid-otpdt6jm> <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></circle> <path d="M20 20L16.5 16.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></path> </svg> </button> <dialog id="search-dialog" class="search-modal" data-astro-cid-otpdt6jm> <div class="modal-content" data-astro-cid-otpdt6jm> <div class="modal-header" data-astro-cid-otpdt6jm> <h2 class="modal-title" data-astro-cid-otpdt6jm>搜索文章</h2> <button id="close-search" class="close-button" aria-label="关闭搜索" data-astro-cid-otpdt6jm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-otpdt6jm></path> </svg> </button> </div> <div id="pagefind-ui" data-astro-cid-otpdt6jm></div> </div> </dialog> </div> <script type="module">let d=!1;const c="pagefind-loaded";async function l(t=0){if(sessionStorage.getItem(c)==="true")return g(),!0;const r=document.getElementById("pagefind-ui");if(!r)return!1;r.innerHTML='<div style="padding: 2rem; text-align: center; color: var(--muted-foreground);">加载中...</div>';try{return await new Promise((o,s)=>{const a=document.createElement("script");a.src="/pagefind/pagefind-ui.js",a.onload=o,a.onerror=s,document.head.appendChild(a)}),g(),sessionStorage.setItem(c,"true"),!0}catch(i){return console.error("Failed to load search:",i),t<2?(console.log(`Retrying search load... (${t+1}/2)`),await new Promise(o=>setTimeout(o,1e3)),l(t+1)):(r&&(r.innerHTML=`
          <div style="padding: 2rem; text-align: center;">
            <p style="color: var(--muted-foreground); margin-bottom: 1rem;">搜索功能加载失败</p>
            <button id="retry-search" style="padding: 0.5rem 1rem; background: var(--accent); color: var(--accent-foreground); border: none; border-radius: 0.375rem; cursor: pointer;">
              重试
            </button>
          </div>
        `,document.getElementById("retry-search")?.addEventListener("click",()=>{sessionStorage.removeItem(c),l(0)})),!1)}}function g(){typeof PagefindUI<"u"&&(new PagefindUI({element:"#pagefind-ui",showSubResults:!0,showImages:!1,excerptLength:15,translations:{placeholder:"搜索文章...",clear_search:"清除",load_more:"加载更多",search_label:"搜索此站点",filters_label:"筛选",zero_results:"未找到结果 [SEARCH_TERM]",many_results:"找到 [COUNT] 个结果 [SEARCH_TERM]",one_result:"找到 [COUNT] 个结果 [SEARCH_TERM]",alt_search:"未找到 [SEARCH_TERM] 的结果。显示 [DIFFERENT_TERM] 的结果",search_suggestion:"未找到 [SEARCH_TERM] 的结果。尝试以下搜索：",searching:"搜索中 [SEARCH_TERM]..."}}),setTimeout(()=>{const t=document.querySelector(".pagefind-ui__search-input");t instanceof HTMLElement&&t.focus()},100))}function u(){if(d)return;d=!0;const t=document.getElementById("search-button"),n=document.getElementById("search-dialog"),r=document.getElementById("close-search");if(!t||!n||!r)return;let i=sessionStorage.getItem(c)==="true";const o=async()=>{n.showModal(),document.body.style.overflow="hidden",i?setTimeout(()=>{const e=document.querySelector(".pagefind-ui__search-input");e instanceof HTMLElement&&e.focus()},100):await l()&&(i=!0)},s=()=>{n.close(),document.body.style.overflow=""},a=e=>{e.target===n&&s()},m=e=>{e.key==="Escape"&&n.open&&s()},f=e=>{(e.metaKey||e.ctrlKey)&&e.key==="k"&&(e.preventDefault(),n.open?s():o())};t.addEventListener("click",o),r.addEventListener("click",s),n.addEventListener("click",a),document.addEventListener("keydown",m),document.addEventListener("keydown",f),document.addEventListener("astro:before-swap",()=>{t.removeEventListener("click",o),r.removeEventListener("click",s),n.removeEventListener("click",a),document.removeEventListener("keydown",m),document.removeEventListener("keydown",f),d=!1},{once:!0})}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",u):u();document.addEventListener("astro:page-load",u);</script> <link href="/pagefind/pagefind-ui.css" rel="stylesheet">  </div> </div> </nav> </header>  <main id="main-content" data-pagefind-body class="main-content main-content--wide" data-astro-cid-sckkx6r4>  <div class="blog-post-container" data-astro-cid-wrgicudb> <article class="blog-post" data-astro-cid-wrgicudb> <header class="article-header" data-astro-cid-wrgicudb> <h1 data-astro-cid-wrgicudb>从零开始构建大语言模型第29部分——在云端使用DistributedDataParallel从头训练基础模型</h1> <div class="article-meta" data-astro-cid-wrgicudb> <a href="https://gilesthomas.com" target="_blank" rel="noopener noreferrer" class="source-tag" data-astro-cid-wrgicudb>gilesthomas.com</a> <span class="separator" data-astro-cid-wrgicudb>·</span> <time data-astro-cid-wrgicudb>2026年1月7日</time> </div> </header> <!-- 使用清洗后的安全 HTML 内容 --> <div class="article-content app-prose" data-astro-cid-wrgicudb><p>I'm carrying on with my <a href="/2025/11/llm-from-scratch-27-whats-left-and-whats-next" target="_blank" rel="noopener noreferrer">"extra credit" projects</a> after finishing the main body of
<a href="https://sebastianraschka.com/" target="_blank" rel="noopener noreferrer">Sebastian Raschka</a>'s book
"<a href="https://www.manning.com/books/build-a-large-language-model-from-scratch" target="_blank" rel="noopener noreferrer">Build a Large Language Model (from Scratch)</a>".
Having proven that I could <a href="/2025/12/llm-from-scratch-28-training-a-base-model-from-scratch" target="_blank" rel="noopener noreferrer">train a GPT-2 small scale base model from scratch
on my RTX 3090</a>
in 48 hours, I wanted to try training it on a multi-GPU machine on Lambda Labs.
There are two benefits I see in doing that:</p>

<ol>
<li>I can learn what you need to change in a simple single-GPU training loop to
make it multi-GPU.</li>
<li>If I can get the training time for a full base model down from 48 hours
to something more manageable (and hopefully not too expensive) -- then I
can try a few experiments to see how I can improve the quality of the trained
model.  I have
<a href="/2025/12/llm-from-scratch-28-training-a-base-model-from-scratch#but-why-is-our-model-worse-than-openais" target="_blank" rel="noopener noreferrer">a bunch of ideas</a>
about why my own base model wasn't as good as
the original OpenAI one, and it would be good to know which (if any) of them
are right.</li>
</ol>

<p>In addition, I wanted to see if anything unexpected dropped out of it; after all,
there were four different sizes of machines that I wanted to try, so I'd be doing
four from-scratch trains on the same dataset.  Does the machine size affect the quality
of the model in some way?</p>

<p>Here's what happened.  As with the last post, this is a set of tidied-up lab notes,
so you can see the full journey.  There's a lot to it!  I was considering splitting
it into multiple posts -- "writing the code", "building the datasets", "running the trains" --
but they're interleaved.  Each train taught me something about how to structure the code
to make it easier to use, so the code kept changing.</p>

<p>So I think it's worth documenting
the process as it really was.  If at some point I want to write a how-to document on
porting single-GPU code to multi-GPU, I'll be able to mine this for resources, and in
the meantime, hopefully this will be of use to readers -- even if it's just at the level of
"I got this error message, how do I fix it?"</p>

<p>Anyway, once again I don't want to bury the lede, so: after spending US$215.16 on various
trains on various servers, I was able to find that a reasonably
cheap instance on Lambda Labs, with 8x A100 GPUs, each of which has 40 GiB of VRAM,
is the sweet spot for this particular 163M-parameter, ~Chinchilla-optimal single-epoch run.  They can train the model in less than
four hours, they happen to be the right size for batches that minimise loss (more on that later),
and can do that train for about US$35, excluding validation.</p>

<p>If you'd like to read the gory details of what I did, then read on -- but if you
prefer, you can jump straight to <a href="#the-results" target="_blank" rel="noopener noreferrer">the results</a>.</p>
<h3>Which multi-GPU technique?</h3>

<p>Back when I was <a href="/fine-tuning" target="_blank" rel="noopener noreferrer">messing around with fine-tuning LLMs</a> using the Hugging Face ecosystem
-- <a href="https://huggingface.co/docs/transformers/en/index" target="_blank" rel="noopener noreferrer">their "Transformers" library</a> and so on --
one of the experiments I did was to <a href="/2024/05/fine-tuning-3" target="_blank" rel="noopener noreferrer">fine-tune a 0.5B Qwen model on an 8x GPU machine</a>.
As part of that, I came across
<a href="https://huggingface.co/docs/transformers/en/perf_train_gpu_many" target="_blank" rel="noopener noreferrer">this excellent HF page summarising different kinds of multi-GPU training techniques</a>.
The three that are relevant are:</p>

<ol>
<li>DataParallel (DP).  With this:
<ul>
<li>The default GPU (normally <code>gpu0</code>) is in charge of the process.  It gets a batch
of data, divides it up into per-GPU "micro-batches", and sends each of those to
a thread for each of the other GPUs.</li>
<li>It then sends an up-to-date version of the model to each GPU.</li>
<li>Next, all of the per-GPU threads do a forward pass on their replica using their specific micro-batch, and send their outputs to the thread for the default GPU.</li>
<li>The default GPU thread aggregates all of those outputs (similarly to how the losses
across all of our batches and the prefix sequences
<a href="/2025/10/llm-from-scratch-20-starting-training-cross-entropy-loss" target="_blank" rel="noopener noreferrer">are aggregated in the normal single-GPU case</a>)
to work out an overall loss.</li>
<li>It then does a backward pass.  This will start on the default GPU, as the
aggregation step is the first thing that it will come to when going backwards
through the steps that came up with that overall loss.  However, it will then
come to operations that happened on the other GPUs and those are (somehow)
parallelised.</li>
<li>Once that is done, each GPU has gradients that represent how their copies of the model
contributed to the overall loss.</li>
<li>Finally, they send those gradients back to the default GPU, which combines them
(I think of this as just being an average, though I gather it's more complex)
and applies them, producing an updated model.</li>
<li>Then the process repeats; the updated model on the default GPU will be sent
to the other GPUs in the second step of the next iteration.</li>
</ul></li>
<li>DistributedDataParallel (DDP).  This does less work on the default GPU and does less copying around.
Each GPU has its own process (rather than thread), and is essentially responsible for its own training loop.
Right at the very start, the default GPU's process sends the model to all of the others.
Then all processes go into their training loop:
<ul>
<li>Firstly, each one
works out its own micro-batch (which means you need to have code to make sure
that the datasets are properly split across the GPUs)</li>
<li>Each model does its own forward pass, then its own backward pass, working out its
own independent gradients.</li>
<li>As it comes up with those gradients, it broadcasts them to a "reducer",
which handles the aggregation.  This is done in a distributed way -- there's not
just one reducer handling everything.</li>
<li>When all models have completed the backward pass, the reducer has a set of
combined gradients, which is visible from the per-GPU processes.</li>
<li>Each GPU process does its own optimizer step using those combined gradients.</li>
<li>That means that there's no model copy required -- each GPU has applied
the same gradient update, so they already have in-sync models, assuming
everything went well.</li>
</ul></li>
<li>ZeRO.  This is a much more complex system, and I went into how it works
<a href="/2024/05/fine-tuning-4" target="_blank" rel="noopener noreferrer">in this blog post</a>.</li>
</ol>

<p>Now, from what I understand, due to all of the copying around of models, plus
the issues inherent with the GIL in Python, DDP is actually better than DP despite being
more complicated -- and more flexible!  Per Hugging Face:</p>

<blockquote>
  <p>DDP is recommended because it reduces communication overhead between GPUs, efficiently utilizes each GPU, and scales to more than one machine.</p>
</blockquote>

<p>It might be a while before I want to try multi-machine training, but it would be
awesome to have code that's ready to do that without needing any extra work.</p>

<p>Now, how to implement it?</p>

<h3>Implementing DDP for our model.</h3>

<p>Hugging Face have a library called <a href="https://huggingface.co/docs/accelerate/index" target="_blank" rel="noopener noreferrer">Accelerate</a>,
which does everything for you:</p>

<blockquote>
  <p>Accelerate is a library that enables the same PyTorch code to be run across any distributed configuration by adding just four lines of code!</p>
</blockquote>

<p>That does sound very useful, but I worry that by using it I won't learn as much.
It also rather ties you in to the HF ecosystem.
That's not necessarily a bad thing -- I enjoyed using their stuff in my fine-tuning
project -- but I'm trying for a somewhat lower-level view in this series.</p>

<p>So, let's use the PyTorch-native stuff.  There's a <a href="https://docs.pytorch.org/tutorials/intermediate/ddp_tutorial.html" target="_blank" rel="noopener noreferrer">"getting started" tutorial</a>,
so we can follow that.</p>

<p>It has two options for running using DDP, one with a bit of extra setup code --
the first example, under "Basic Use Case" -- and one that uses <code>torchrun</code> to make
things easier.  The second sounds best.</p>

<p>The code changes actually look really simple; given a normal single-GPU training script,
you need to do some setup at the start:</p>

<div>
<pre><span></span><code><span>import</span><span> </span><span>torch.distributed</span><span> </span><span>as</span><span> </span><span>dist</span>
<span>from</span><span> </span><span>torch.nn.parallel</span><span> </span><span>import</span> <span>DistributedDataParallel</span> <span>as</span> <span>DDP</span>

<span># ...</span>

    <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>set_device_index</span><span>(</span><span>int</span><span>(</span><span>os</span><span>.</span><span>environ</span><span>[</span><span>"LOCAL_RANK"</span><span>]))</span>
    <span>acc</span> <span>=</span> <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>current_accelerator</span><span>()</span>
    <span>backend</span> <span>=</span> <span>torch</span><span>.</span><span>distributed</span><span>.</span><span>get_default_backend_for_device</span><span>(</span><span>acc</span><span>)</span>
    <span>dist</span><span>.</span><span>init_process_group</span><span>(</span><span>backend</span><span>)</span>
    <span>rank</span> <span>=</span> <span>dist</span><span>.</span><span>get_rank</span><span>()</span>
    <span>print</span><span>(</span><span>f</span><span>"Start running basic DDP example on rank </span><span>{</span><span>rank</span><span>}</span><span>."</span><span>)</span>
    <span># create model and move it to GPU with id rank</span>
    <span>device_id</span> <span>=</span> <span>rank</span> <span>%</span> <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>device_count</span><span>()</span>
</code></pre>
</div>

<p>...then wrap the model itself in a <code>DDP</code> object, which is what you actually do the
train on:</p>

<div>
<pre><span></span><code>    <span>model</span> <span>=</span> <span>ToyModel</span><span>()</span><span>.</span><span>to</span><span>(</span><span>device_id</span><span>)</span>
    <span>ddp_model</span> <span>=</span> <span>DDP</span><span>(</span><span>model</span><span>,</span> <span>device_ids</span><span>=</span><span>[</span><span>device_id</span><span>])</span>
</code></pre>
</div>

<p>...and a bit of teardown at the end:</p>

<div>
<pre><span></span><code>    <span>dist</span><span>.</span><span>destroy_process_group</span><span>()</span>
</code></pre>
</div>

<p>The way to look at this is that <code>torchrun</code> will spin off one process per GPU, each
running exactly the same code.  They have a "rank", which is an integer saying which
of the per-GPU processes they are -- 0 for GPU 0, 1 for GPU 1, and so on.  There's
a bit of a gotcha here, though -- you can see that we're looking at an environment
variable called <code>LOCAL_RANK</code> at the start, but we then get a (non-"local") <code>rank</code>
variable from <code>torch.distributed</code> a bit later on.  This is due to the multi-machine
possibilities with DDP -- if you have multiple machines, then the local rank will
be "which GPU on the machine does this process relate to", but there will also be a
"global" rank, which is unique across all machines.  This distinction won't matter
that much during this one-machine test, but it's worth keeping in mind if we want to
keep the code in a shape where it could potentially scale to multiple machines.</p>

<p>Anyway, after the processes are spun up, they will do their training, and the synchronisation
and passing around of gradients during the backward pass will all happen invisibly
in the background, so when we do our <code>optimizer.step()</code>, it will have the full set
of gradients.</p>

<p>Now that means that we'll presumably also need to use the rank -- that is, which of the <em>n</em> per-GPU
processes the current code is running in -- when selecting which dataset items to
train on.  More about that later.</p>

<p>Let's start writing some code!  I'll use a <a href="https://github.com/gpjt/ddp-base-model-from-scratch" target="_blank" rel="noopener noreferrer">new repo</a>,
into which I can put just the code needed for this train.  I'll also structure
it a little better than last time, with separate "runs", each of which has a model
config and training parameters, and will later on have its own checkpoints.  You can
think of these as being one per machine size that I'm trying out -- I'll create a run directory for
each one.</p>

<p><a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/0c3462c71874d83511eaabdf18fe8a91a7c31c2b/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's a first cut</a>,
simply loading up a model config from a run's directory, using it to create the
model, and then doing the wrapping above -- no training at all.  Running it with <code>torchrun</code> (and <code>uv</code>, as
I'm using that for all new projects):</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>ddp_train.py<span> </span>original
On<span> </span>rank<span> </span><span>0</span>.
</code></pre>
</div>

<p>Promising.  Now, unfortunately we only have one GPU locally, and the code assumes
that it's one process per GPU (I believe that's a hard limitation for PyTorch's
DDP), so running with <code>--nproc_per_node=2</code> blows up.  So we can't do an in-depth
test locally.</p>

<p>But at least we know that the basic infra is there and working.</p>

<p>Now let's move the other training code from the single-GPU script into that file, pretty much blindly.
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/2e781226034bbd2a7f0a9204f8f9c0bd55bac261/ddp_train.py" target="_blank" rel="noopener noreferrer">This is the result</a> --
it's doing almost nothing beyond what the last train did, apart from wrapping the model
in a <code>DDP</code> object -- the only other changes are to use this "runs" directory that
we've introduced.</p>

<p>As a quick hack, we should try running it.  It does a validation and checkpoint before it starts,
and we can make that happen quickly by hacking the validation loop to only
do a couple of iterations:</p>

<div>
<pre><span></span><code><span>for</span> <span>val_inputs</span><span>,</span> <span>val_targets</span> <span>in</span> <span>tqdm</span><span>(</span><span>val_ds</span><span>[:</span><span>2</span><span>]):</span>
</code></pre>
</div>

<p>(Foreshadowing: that hack will come back to haunt us later!)</p>

<p>Running that, then hitting control-C after the validation completes, and it looks OK:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>ddp_train.py<span> </span>original
On<span> </span>rank<span> </span><span>0</span>.
Starting<span> </span>training<span> </span>at<span> </span>dataset<span> </span>offset<span> </span><span>0</span>
<span>  </span><span>0</span>%<span>|</span><span>                                                                                                                                          </span><span>|</span><span> </span><span>0</span>/530630<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>Validation/checkpoint
<span>100</span>%<span>|</span>███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>2</span>/2<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>10</span>.95it/s<span>]</span>
Continuing<span> </span>training█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>2</span>/2<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>10</span>.96it/s<span>]</span>
<span>  </span><span>0</span>%<span>|</span><span>                                                                                                                              </span><span>|</span><span> </span><span>18</span>/530630<span> </span><span>[</span><span>00</span>:06&lt;<span>45</span>:20:54,<span>  </span><span>3</span>.25it/s<span>]</span>^CW1203<span> </span><span>18</span>:34:11.363000<span> </span><span>471545</span><span> </span>torch/distributed/elastic/agent/server/api.py:725<span>]</span><span> </span>Received<span> </span><span>2</span><span> </span>death<span> </span>signal,<span> </span>shutting<span> </span>down<span> </span>workers
W1203<span> </span><span>18</span>:34:11.364000<span> </span><span>471545</span><span> </span>torch/distributed/elastic/multiprocessing/api.py:908<span>]</span><span> </span>Sending<span> </span>process<span> </span><span>471607</span><span> </span>closing<span> </span>signal<span> </span>SIGINT
<span>  </span><span>0</span>%<span>|</span><span>                                                                                                                              </span><span>|</span><span> </span><span>18</span>/530630<span> </span><span>[</span><span>00</span>:07&lt;<span>57</span>:44:53,<span>  </span><span>2</span>.55it/s<span>]</span>

Aborted!
</code></pre>
</div>

<p>...and we have what look like solid checkpoints:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>ls<span> </span>-lrt<span> </span>runs/original/checkpoints/
total<span> </span><span>4</span>
lrwxrwxrwx<span> </span><span>1</span><span> </span>giles<span> </span>giles<span>   </span><span>27</span><span> </span>Dec<span>  </span><span>3</span><span> </span><span>18</span>:34<span> </span>latest<span> </span>-&gt;<span> </span>20251203Z183404-iteration-0
lrwxrwxrwx<span> </span><span>1</span><span> </span>giles<span> </span>giles<span>   </span><span>27</span><span> </span>Dec<span>  </span><span>3</span><span> </span><span>18</span>:34<span> </span>best<span> </span>-&gt;<span> </span>20251203Z183404-iteration-0
drwxr-xr-x<span> </span><span>2</span><span> </span>giles<span> </span>giles<span> </span><span>4096</span><span> </span>Dec<span>  </span><span>3</span><span> </span><span>18</span>:34<span> </span>20251203Z183404-iteration-0
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>ls<span> </span>-lrth<span> </span>runs/original/checkpoints/20251203Z183404-iteration-0/
total<span> </span><span>1</span>.9G
-rw-r--r--<span> </span><span>1</span><span> </span>giles<span> </span>giles<span> </span>670M<span> </span>Dec<span>  </span><span>3</span><span> </span><span>18</span>:34<span> </span>model.safetensors
-rw-r--r--<span> </span><span>1</span><span> </span>giles<span> </span>giles<span> </span><span>1</span>.4K<span> </span>Dec<span>  </span><span>3</span><span> </span><span>18</span>:34<span> </span>scaler.pt
-rw-r--r--<span> </span><span>1</span><span> </span>giles<span> </span>giles<span> </span><span>1</span>.3G<span> </span>Dec<span>  </span><span>3</span><span> </span><span>18</span>:34<span> </span>optimizer.pt
-rw-r--r--<span> </span><span>1</span><span> </span>giles<span> </span>giles<span>  </span><span>105</span><span> </span>Dec<span>  </span><span>3</span><span> </span><span>18</span>:34<span> </span>meta.json
</code></pre>
</div>

<p>However, loading one of those checkpoints fails:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>ddp_train.py<span> </span>original<span> </span>best
On<span> </span>rank<span> </span><span>0</span>.
<span>[</span>rank0<span>]</span>:<span> </span>Traceback<span> </span><span>(</span>most<span> </span>recent<span> </span>call<span> </span>last<span>)</span>:
<span>[</span>rank0<span>]</span>:<span>   </span>File<span> </span><span>"/home/giles/Dev/ddp-base-model-from-scratch/ddp_train.py"</span>,<span> </span>line<span> </span><span>229</span>,<span> </span><span>in</span><span> </span>&lt;module&gt;
<span>[</span>rank0<span>]</span>:<span>     </span>main<span>()</span>
<span>[</span>rank0<span>]</span>:<span>     </span>~~~~^^
<span>[</span>rank0<span>]</span>:<span>   </span>File<span> </span><span>"/home/giles/Dev/ddp-base-model-from-scratch/.venv/lib/python3.13/site-packages/click/core.py"</span>,<span> </span>line<span> </span><span>1485</span>,<span> </span><span>in</span><span> </span>__call__
<span>[</span>rank0<span>]</span>:<span>     </span><span>return</span><span> </span>self.main<span>(</span>*args,<span> </span>**kwargs<span>)</span>
<span>[</span>rank0<span>]</span>:<span>            </span>~~~~~~~~~^^^^^^^^^^^^^^^^^
<span>[</span>rank0<span>]</span>:<span>   </span>File<span> </span><span>"/home/giles/Dev/ddp-base-model-from-scratch/.venv/lib/python3.13/site-packages/click/core.py"</span>,<span> </span>line<span> </span><span>1406</span>,<span> </span><span>in</span><span> </span>main
<span>[</span>rank0<span>]</span>:<span>     </span><span>rv</span><span> </span><span>=</span><span> </span>self.invoke<span>(</span>ctx<span>)</span>
<span>[</span>rank0<span>]</span>:<span>   </span>File<span> </span><span>"/home/giles/Dev/ddp-base-model-from-scratch/.venv/lib/python3.13/site-packages/click/core.py"</span>,<span> </span>line<span> </span><span>1269</span>,<span> </span><span>in</span><span> </span>invoke
<span>[</span>rank0<span>]</span>:<span>     </span><span>return</span><span> </span>ctx.invoke<span>(</span>self.callback,<span> </span>**ctx.params<span>)</span>
<span>[</span>rank0<span>]</span>:<span>            </span>~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<span>[</span>rank0<span>]</span>:<span>   </span>File<span> </span><span>"/home/giles/Dev/ddp-base-model-from-scratch/.venv/lib/python3.13/site-packages/click/core.py"</span>,<span> </span>line<span> </span><span>824</span>,<span> </span><span>in</span><span> </span>invoke
<span>[</span>rank0<span>]</span>:<span>     </span><span>return</span><span> </span>callback<span>(</span>*args,<span> </span>**kwargs<span>)</span>
<span>[</span>rank0<span>]</span>:<span>   </span>File<span> </span><span>"/home/giles/Dev/ddp-base-model-from-scratch/ddp_train.py"</span>,<span> </span>line<span> </span><span>211</span>,<span> </span><span>in</span><span> </span>main
<span>[</span>rank0<span>]</span>:<span>     </span>train_ds_offset,<span> </span><span>best_loss</span><span> </span><span>=</span><span> </span>load_checkpoint<span>(</span>
<span>[</span>rank0<span>]</span>:<span>                                  </span>~~~~~~~~~~~~~~~^
<span>[</span>rank0<span>]</span>:<span>         </span>run_dir,<span> </span>checkpoint,<span> </span>model,<span> </span>optimizer,<span> </span>scaler
<span>[</span>rank0<span>]</span>:<span>         </span>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<span>[</span>rank0<span>]</span>:<span>     </span><span>)</span>
<span>[</span>rank0<span>]</span>:<span>     </span>^
<span>[</span>rank0<span>]</span>:<span>   </span>File<span> </span><span>"/home/giles/Dev/ddp-base-model-from-scratch/checkpointing.py"</span>,<span> </span>line<span> </span><span>16</span>,<span> </span><span>in</span><span> </span>load_checkpoint
<span>[</span>rank0<span>]</span>:<span>     </span>model.load_state_dict<span>(</span>load_file<span>(</span>checkpoint_dir<span> </span>/<span> </span><span>"model.safetensors"</span><span>))</span>
<span>[</span>rank0<span>]</span>:<span>     </span>~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<span>[</span>rank0<span>]</span>:<span>   </span>File<span> </span><span>"/home/giles/Dev/ddp-base-model-from-scratch/.venv/lib/python3.13/site-packages/torch/nn/modules/module.py"</span>,<span> </span>line<span> </span><span>2629</span>,<span> </span><span>in</span><span> </span>load_state_dict
<span>[</span>rank0<span>]</span>:<span>     </span>raise<span> </span>RuntimeError<span>(</span>
<span>[</span>rank0<span>]</span>:<span>     </span>...&lt;<span>3</span><span> </span>lines&gt;...
<span>[</span>rank0<span>]</span>:<span>     </span><span>)</span>
<span>[</span>rank0<span>]</span>:<span> </span>RuntimeError:<span> </span>Error<span>(</span>s<span>)</span><span> </span><span>in</span><span> </span>loading<span> </span>state_dict<span> </span><span>for</span><span> </span>GPTModel:
<span>[</span>rank0<span>]</span>:<span>    </span>Missing<span> </span>key<span>(</span>s<span>)</span><span> </span><span>in</span><span> </span>state_dict:<span> </span><span>"tok_emb.weight"</span>,<span> </span><span>"pos_emb.weight"</span>,<span> </span><span>"trf_blocks.0.att.mask"</span>,<span> </span><span>"trf_blocks.0.att.W_query.weight"</span>,
...
<span>[</span>rank0<span>]</span>:<span>    </span>Unexpected<span> </span>key<span>(</span>s<span>)</span><span> </span><span>in</span><span> </span>state_dict:<span> </span><span>"module.final_norm.scale"</span>,<span> </span><span>"module.final_norm.shift"</span>,<span> </span><span>"module.out_head.weight"</span>,<span> </span><span>"module.pos_emb.weight"</span>,<span> </span><span>"module.tok_emb.weight"</span>
...
</code></pre>
</div>

<p>It turns out that the problem is this code when we save it:</p>

<div>
<pre><span></span><code>            <span>save_checkpoint</span><span>(</span>
                <span>run_dir</span><span>,</span>
                <span>f</span><span>"iteration-</span><span>{</span><span>ix</span><span>}</span><span>"</span><span>,</span>
                <span>model</span><span>,</span> <span>optimizer</span><span>,</span> <span>scaler</span><span>,</span>
                <span>avg_train_loss</span><span>,</span> <span>val_loss</span><span>,</span>
                <span>ix</span><span>,</span>
                <span>is_best</span>
            <span>)</span>
</code></pre>
</div>

<p>The <code>model</code> that we're saving is the <code>DDP</code> wrapper around our model; my guess is that
it does actually include all of the weights for the model, hence the correct-looking
size for the checkpoint file, but they're renamed --
the <code>DDP</code> wrapper sees the underlying model as something called <code>module</code>, so (for example)
<code>tok_emb.weight</code> would be called <code>module.tok_emb.weight</code>.</p>

<p>Fixing that, with this diff:</p>

<div>
<pre><span></span><code><span>diff</span> <span>--</span><span>git</span> <span>a</span><span>/</span><span>ddp_train</span><span>.</span><span>py</span> <span>b</span><span>/</span><span>ddp_train</span><span>.</span><span>py</span>
<span>index</span> <span>7418851..963</span><span>fbf7</span> <span>100644</span>
<span>---</span> <span>a</span><span>/</span><span>ddp_train</span><span>.</span><span>py</span>
<span>+++</span> <span>b</span><span>/</span><span>ddp_train</span><span>.</span><span>py</span>
<span>@@</span> <span>-</span><span>137</span><span>,</span><span>12</span> <span>+</span><span>137</span><span>,</span><span>13</span> <span>@@</span> <span>def</span><span> </span><span>train</span><span>(</span>
         <span>if</span> <span>(</span><span>ix</span> <span>%</span> <span>VAL_AND_CHECKPOINT_INTERVAL</span> <span>==</span> <span>0</span><span>)</span> <span>or</span> <span>(</span><span>ix</span> <span>==</span> <span>len</span><span>(</span><span>train_ds</span><span>)</span> <span>-</span> <span>1</span><span>):</span>
             <span>print</span><span>(</span><span>"Validation/checkpoint"</span><span>)</span>
             <span>model</span><span>.</span><span>eval</span><span>()</span>
<span>+</span>            <span>base_model</span> <span>=</span> <span>model</span><span>.</span><span>module</span>
             <span>with</span> <span>torch</span><span>.</span><span>inference_mode</span><span>(),</span> <span>torch</span><span>.</span><span>amp</span><span>.</span><span>autocast</span><span>(</span><span>device_type</span><span>=</span><span>device</span><span>.</span><span>type</span><span>,</span> <span>dtype</span><span>=</span><span>torch</span><span>.</span><span>float16</span><span>):</span>
                 <span>val_losses</span> <span>=</span> <span>[]</span>
                 <span>for</span> <span>val_inputs</span><span>,</span> <span>val_targets</span> <span>in</span> <span>tqdm</span><span>(</span><span>val_ds</span><span>):</span>
                     <span>val_inputs</span> <span>=</span> <span>val_inputs</span><span>.</span><span>to</span><span>(</span><span>device</span><span>)</span><span>.</span><span>to</span><span>(</span><span>torch</span><span>.</span><span>long</span><span>)</span>
                     <span>val_targets</span> <span>=</span> <span>val_targets</span><span>.</span><span>to</span><span>(</span><span>device</span><span>)</span><span>.</span><span>to</span><span>(</span><span>torch</span><span>.</span><span>long</span><span>)</span>
<span>-</span>                    <span>val_logits</span> <span>=</span> <span>model</span><span>(</span><span>val_inputs</span><span>)</span>
<span>+</span>                    <span>val_logits</span> <span>=</span> <span>base_model</span><span>(</span><span>val_inputs</span><span>)</span>
                     <span>val_losses</span><span>.</span><span>append</span><span>(</span>
                         <span>calculate_loss</span><span>(</span><span>val_logits</span><span>,</span> <span>val_targets</span><span>)</span><span>.</span><span>item</span><span>()</span>
                     <span>)</span>
<span>@@</span> <span>-</span><span>160</span><span>,</span><span>7</span> <span>+</span><span>161</span><span>,</span><span>7</span> <span>@@</span> <span>def</span><span> </span><span>train</span><span>(</span>
             <span>save_checkpoint</span><span>(</span>
                 <span>run_dir</span><span>,</span>
                 <span>f</span><span>"iteration-</span><span>{</span><span>ix</span><span>}</span><span>"</span><span>,</span>
<span>-</span>                <span>model</span><span>,</span> <span>optimizer</span><span>,</span> <span>scaler</span><span>,</span>
<span>+</span>                <span>base_model</span><span>,</span> <span>optimizer</span><span>,</span> <span>scaler</span><span>,</span>
                 <span>avg_train_loss</span><span>,</span> <span>val_loss</span><span>,</span>
                 <span>ix</span><span>,</span>
                 <span>is_best</span>
</code></pre>
</div>

<p>...sorts it out -- we can load our checkpoints again.  Here's <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/7d1f189a0174e1a88d6f21ce2d4b0b88ab2965f7/ddp_train.py" target="_blank" rel="noopener noreferrer">the updated file</a>.</p>

<p>I think we're going to have to revisit checkpointing and validation again; we don't
want to do it in all of our processes, probably only on global rank 0, and we'll need to
somehow synchronise everything so that the other processes don't carry on training
while we're doing it.</p>

<p>But before we get on to that, there are a couple of other things to change.
At the top of the file we're defining some
constants that look wrong:</p>

<div>
<pre><span></span><code><span>BATCH_SIZE</span> <span>=</span> <span>6</span>
<span>SEQ_LENGTH</span> <span>=</span> <span>1024</span>
<span>VAL_AND_CHECKPOINT_INTERVAL</span> <span>=</span> <span>2000</span>
</code></pre>
</div>

<h3>Sequence length</h3>

<p>We'll handle the dumbest of these first; it was actually silly that in the old
code we had a constant for sequence length.  We're using the context
length of the model for that, so it's duplicated information.  Let's get it
from the <code>model_conf</code>:</p>

<div>
<pre><span></span><code><span>diff</span> <span>--</span><span>git</span> <span>a</span><span>/</span><span>ddp_train</span><span>.</span><span>py</span> <span>b</span><span>/</span><span>ddp_train</span><span>.</span><span>py</span>
<span>index</span> <span>963</span><span>fbf7</span><span>.</span><span>.77</span><span>a62ae</span> <span>100644</span>
<span>---</span> <span>a</span><span>/</span><span>ddp_train</span><span>.</span><span>py</span>
<span>+++</span> <span>b</span><span>/</span><span>ddp_train</span><span>.</span><span>py</span>
<span>@@</span> <span>-</span><span>20</span><span>,</span><span>15</span> <span>+</span><span>20</span><span>,</span><span>14</span> <span>@@</span> <span>from</span><span> </span><span>gpt</span><span> </span><span>import</span> <span>GPTModel</span>


 <span>BATCH_SIZE</span> <span>=</span> <span>6</span>
<span>-</span><span>SEQ_LENGTH</span> <span>=</span> <span>1024</span>
 <span>VAL_AND_CHECKPOINT_INTERVAL</span> <span>=</span> <span>2000</span>


 <span>class</span><span> </span><span>BigTrainDataset</span><span>(</span><span>Dataset</span><span>):</span>

<span>-</span>    <span>def</span><span> </span><span>__init__</span><span>(</span><span>self</span><span>,</span> <span>all_tokens</span><span>):</span>
<span>-</span>        <span>self</span><span>.</span><span>xs</span> <span>=</span> <span>all_tokens</span><span>[:</span><span>-</span><span>1</span><span>]</span><span>.</span><span>reshape</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>BATCH_SIZE</span><span>,</span> <span>SEQ_LENGTH</span><span>)</span>
<span>-</span>        <span>self</span><span>.</span><span>ys</span> <span>=</span> <span>all_tokens</span><span>[</span><span>1</span><span>:]</span><span>.</span><span>reshape</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>BATCH_SIZE</span><span>,</span> <span>SEQ_LENGTH</span><span>)</span>
<span>+</span>    <span>def</span><span> </span><span>__init__</span><span>(</span><span>self</span><span>,</span> <span>all_tokens</span><span>,</span> <span>seq_length</span><span>):</span>
<span>+</span>        <span>self</span><span>.</span><span>xs</span> <span>=</span> <span>all_tokens</span><span>[:</span><span>-</span><span>1</span><span>]</span><span>.</span><span>reshape</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>BATCH_SIZE</span><span>,</span> <span>seq_length</span><span>)</span>
<span>+</span>        <span>self</span><span>.</span><span>ys</span> <span>=</span> <span>all_tokens</span><span>[</span><span>1</span><span>:]</span><span>.</span><span>reshape</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>BATCH_SIZE</span><span>,</span> <span>seq_length</span><span>)</span>

     <span>def</span><span> </span><span>__getitem__</span><span>(</span><span>self</span><span>,</span> <span>ix</span><span>):</span>
         <span>return</span> <span>(</span><span>self</span><span>.</span><span>xs</span><span>[</span><span>ix</span><span>],</span> <span>self</span><span>.</span><span>ys</span><span>[</span><span>ix</span><span>])</span>
<span>@@</span> <span>-</span><span>37</span><span>,</span><span>9</span> <span>+</span><span>36</span><span>,</span><span>10</span> <span>@@</span> <span>class</span><span> </span><span>BigTrainDataset</span><span>(</span><span>Dataset</span><span>):</span>
         <span>return</span> <span>self</span><span>.</span><span>xs</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]</span>


<span>-</span><span>def</span><span> </span><span>load_dataset</span><span>(</span><span>run_dir</span><span>,</span> <span>split</span><span>):</span>
<span>+</span><span>def</span><span> </span><span>load_dataset</span><span>(</span><span>run_dir</span><span>,</span> <span>split</span><span>,</span> <span>seq_length</span><span>):</span>
     <span>return</span> <span>BigTrainDataset</span><span>(</span>
<span>-</span>        <span>load_file</span><span>(</span><span>run_dir</span> <span>/</span> <span>"datasets"</span> <span>/</span> <span>f</span><span>"</span><span>{</span><span>split</span><span>}</span><span>.safetensors"</span><span>)[</span><span>"tokens"</span><span>]</span>
<span>+</span>        <span>load_file</span><span>(</span><span>run_dir</span> <span>/</span> <span>"datasets"</span> <span>/</span> <span>f</span><span>"</span><span>{</span><span>split</span><span>}</span><span>.safetensors"</span><span>)[</span><span>"tokens"</span><span>],</span>
<span>+</span>        <span>seq_length</span><span>,</span>
     <span>)</span>


<span>@@</span> <span>-</span><span>205</span><span>,</span><span>8</span> <span>+</span><span>205</span><span>,</span><span>8</span> <span>@@</span> <span>def</span><span> </span><span>main</span><span>(</span><span>run</span><span>,</span> <span>checkpoint</span><span>):</span>

     <span>scaler</span> <span>=</span> <span>torch</span><span>.</span><span>amp</span><span>.</span><span>GradScaler</span><span>()</span>

<span>-</span>    <span>train_ds</span> <span>=</span> <span>load_dataset</span><span>(</span><span>run_dir</span><span>,</span> <span>"train"</span><span>)</span>
<span>-</span>    <span>val_ds</span> <span>=</span> <span>load_dataset</span><span>(</span><span>run_dir</span><span>,</span> <span>"validation"</span><span>)</span>
<span>+</span>    <span>train_ds</span> <span>=</span> <span>load_dataset</span><span>(</span><span>run_dir</span><span>,</span> <span>"train"</span><span>,</span> <span>model_conf</span><span>[</span><span>"context_length"</span><span>])</span>
<span>+</span>    <span>val_ds</span> <span>=</span> <span>load_dataset</span><span>(</span><span>run_dir</span><span>,</span> <span>"validation"</span><span>,</span> <span>model_conf</span><span>[</span><span>"context_length"</span><span>])</span>

     <span>if</span> <span>checkpoint</span><span>:</span>
         <span>train_ds_offset</span><span>,</span> <span>best_loss</span> <span>=</span> <span>load_checkpoint</span><span>(</span>
</code></pre>
</div>

<p>...and <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/017dd79a4a3c05c7a2dc31189c9ff71cf164fa64/ddp_train.py" target="_blank" rel="noopener noreferrer">here's the updated file</a>.
That was nice and simple.</p>

<h3>Batch size</h3>

<p>The code that we have specifies the batch size for each GPU -- that is, with <code>6</code>, we'll
have six sequences in each batch on each one.  Like I mentioned earlier, that's called a "micro-batch" in distributed
training like this <sup><a href="#fn-1" target="_blank" rel="noopener noreferrer">1</a></sup> -- a per-GPU batch, as opposed to the overall global size across all
GPUs -- so we could just rename it, and then we'd have 6×ngpus as
a global batch size.</p>

<p>However, it feels to me like this is a useful metaparameter to be able to tweak
from outside the code.  I can see machines with per-GPU VRAM varying from 40 GiB to
160 GiB on Lambda Labs, and pretty clearly that will mean there will be a varying
largest micro-batch size on each type.  So this is something we'll want to configure
on a per-run basis, so let's add a new <code>train.json</code> file to our run config,
load that up, and pass it through.</p>

<p>That's a simple enough fix; no need to note the diff, but <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/3e1879a8eadade783c1a6dd9f621b8cf2ae76be7/ddp_train.py" target="_blank" rel="noopener noreferrer">here's the code</a>.</p>

<h3>Validation/checkpoint interval</h3>

<p>This one we'll need to think about.  The size of our validation set is based on
what one process running on my local RTX 3090 can validate in five minutes, and the interval (for which I
fairly arbitrarily put 2000 in the code when copying it across) was calibrated
for roughly every half-hour.  Those numbers in turn were aimed at the 44 hours
of training time I expected locally.</p>

<p>For this train, we'll (hopefully!) be taking significantly less time.  We'll have
eight GPUs, so naively that's 5.5 hours of train time, and each will have more VRAM,
so we should be able to bump up the batch size and potentially get even faster than that.  Depending on which kind of cards
we're using, they may be faster, too -- I found that an A100 is slower (with the same batch size) than the
RTX 3090 in my fine-tuning experiments, but the H100 and B200 are likely faster.</p>

<p>I think this is another thing for the train config; we should have the validation
interval (in terms of iterations) and the number of batches to do for validation.</p>

<p><a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/fec0f54e4f0061f5ce93c85c4649b11f6ed7b77d/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's the updated code</a>.</p>

<h3>Datasets</h3>

<p>Now, let's move on to the dataset.  With the code as it is right now, all of our
per-GPU processes are using this code to iterate over the same dataset:</p>

<div>
<pre><span></span><code><span>for</span> <span>ix</span> <span>in</span> <span>tqdm</span><span>(</span><span>range</span><span>(</span><span>train_ds_offset</span><span>,</span> <span>len</span><span>(</span><span>train_ds</span><span>))):</span>
</code></pre>
</div>

<p>That means that they'll all be training on the same data; the synchronisation that is
happening "magically" in the background means that they'll all train on the first item,
work out gradients, and step their optimiser -- so they'll essentially (modulo randomness)
have the same updates.  Pretty pointless!   What we want is for each of the n per-GPU processes
to train on 1/n of the data.</p>

<p>We have two useful helpers in <a href="https://docs.pytorch.org/docs/stable/distributed.html" target="_blank" rel="noopener noreferrer"><code>torch.distributed</code></a>:</p>

<ul>
<li><p><code>get_rank</code>, which gets the global rank of this process.  In our one-machine case, it returns 0 for the process on <code>gpu0</code>, 1 for the one on <code>gpu1</code>, and so on.
We're already using it in that setup code we looked at earlier:</p>

<div>
<pre><span></span><code><span>rank</span> <span>=</span> <span>dist</span><span>.</span><span>get_rank</span><span>()</span>
<span>print</span><span>(</span><span>f</span><span>"Start running basic DDP example on rank </span><span>{</span><span>rank</span><span>}</span><span>."</span><span>)</span>
<span># create model and move it to GPU with id rank</span>
<span>device_id</span> <span>=</span> <span>rank</span> <span>%</span> <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>device_count</span><span>()</span>
</code></pre>
</div></li>
<li><p><code>get_world_size</code>, which tells us how many GPU processes there are (globally -- it would be across all machines if we had more than one)</p></li>
</ul>

<p>So, the simplest thing to do is to use the world size as a step, and the rank as an offset:</p>

<div>
<pre><span></span><code><span>rank</span> <span>=</span> <span>dist</span><span>.</span><span>get_rank</span><span>()</span>
<span>world_size</span> <span>=</span> <span>dist</span><span>.</span><span>get_world_size</span><span>()</span>
<span>for</span> <span>ix</span> <span>in</span> <span>tqdm</span><span>(</span><span>range</span><span>(</span><span>train_ds_offset</span> <span>+</span> <span>rank</span><span>,</span> <span>len</span><span>(</span><span>train_ds</span><span>),</span> <span>world_size</span><span>)):</span>
</code></pre>
</div>

<p><a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/86ea49d0e576e4dec3b5ca9b4fcd8ce8ad176a3f/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's the code with that</a>.</p>

<h3>Validation and checkpointing only on rank 0</h3>

<p>Now, remember that the same code is running for every one of our per-GPU processes.
That means that all of them will do the training with forward and backward passes, and
their own optimiser steps, all synchronised by PyTorch DDP magic.  But they will
also do their own validations -- which is kind of pointless -- and they'll also try to
save their own checkpoints, which would be messy because they could quite easily interfere
with each other; after all, all of the processes are running on the same machine and
would be writing to the same filesystem.</p>

<p>So, as a first cut, let's just wrap an <code>if rank == 0</code> around the eval and checkpointing
stuff -- we change this:</p>

<div>
<pre><span></span><code><span>if</span> <span>(</span><span>ix</span> <span>%</span> <span>validation_interval</span> <span>==</span> <span>0</span><span>)</span> <span>or</span> <span>(</span><span>ix</span> <span>==</span> <span>len</span><span>(</span><span>train_ds</span><span>)</span> <span>-</span> <span>1</span><span>):</span>
</code></pre>
</div>

<p>...to this:</p>

<div>
<pre><span></span><code><span>if</span> <span>rank</span> <span>==</span> <span>0</span> <span>and</span> <span>((</span><span>ix</span> <span>%</span> <span>validation_interval</span> <span>==</span> <span>0</span><span>)</span> <span>or</span> <span>(</span><span>ix</span> <span>==</span> <span>len</span><span>(</span><span>train_ds</span><span>)</span> <span>-</span> <span>1</span><span>)):</span>
</code></pre>
</div>

<p>That line is getting bit long, so let's break it apart a bit:</p>

<div>
<pre><span></span><code><span>is_eval_iter</span> <span>=</span> <span>(</span>
    <span>(</span><span>ix</span> <span>%</span> <span>validation_interval</span> <span>==</span> <span>0</span><span>)</span>
    <span>or</span> <span>(</span><span>ix</span> <span>==</span> <span>len</span><span>(</span><span>train_ds</span><span>)</span> <span>-</span> <span>1</span><span>)</span>
<span>)</span>
<span>if</span> <span>rank</span> <span>==</span> <span>0</span> <span>and</span> <span>is_eval_iter</span><span>:</span>
</code></pre>
</div>

<p>That looks OK, but there's an extra wrinkle: all of the processes are running
the same code, so while the rank zero one will do the eval, the others will continue
through the script, so they will go
right back around our loop and start training on the next batches -- which is bad.
We want our processes to be proceeding in lockstep, iteration-by-iteration.</p>

<p>Luckily, the solution is simple: the <code>barrier</code> function in <code>torch.distributed</code>
basically says "stop here until all of our processes have reached this point".</p>

<p>So we can use two of those -- one before the eval loop, to make sure that all of the
processes have finished their training part of the iteration before we do the eval on
rank zero,
and one after the eval, so that the non-rank-zero processes will wait.</p>

<p>One bit of complexity -- we want to do those barriers only if it's a eval iteration, but
we want to do them for all processes.  So we have to break up the <code>if</code> statement, and we
wind up with this:</p>

<div>
<pre><span></span><code>       <span>is_eval_iter</span> <span>=</span> <span>(</span>
            <span>(</span><span>ix</span> <span>%</span> <span>validation_interval</span> <span>==</span> <span>0</span><span>)</span>
            <span>or</span> <span>(</span><span>ix</span> <span>==</span> <span>len</span><span>(</span><span>train_ds</span><span>)</span> <span>-</span> <span>1</span><span>)</span>
        <span>)</span>
        <span>if</span> <span>is_eval_iter</span><span>:</span>
            <span>dist</span><span>.</span><span>barrier</span><span>()</span>

            <span>if</span> <span>rank</span> <span>==</span> <span>0</span><span>:</span>
                <span>print</span><span>(</span><span>"Validation/checkpoint"</span><span>)</span>
                <span>model</span><span>.</span><span>eval</span><span>()</span>

                <span>base_model</span> <span>=</span> <span>model</span><span>.</span><span>module</span>
                <span>with</span> <span>torch</span><span>.</span><span>inference_mode</span><span>(),</span> <span>torch</span><span>.</span><span>amp</span><span>.</span><span>autocast</span><span>(</span><span>device_type</span><span>=</span><span>device</span><span>.</span><span>type</span><span>,</span> <span>dtype</span><span>=</span><span>torch</span><span>.</span><span>float16</span><span>):</span>
                    <span>val_losses</span> <span>=</span> <span>[]</span>
                    <span>for</span> <span>val_inputs</span><span>,</span> <span>val_targets</span> <span>in</span> <span>tqdm</span><span>(</span><span>val_ds</span><span>[:</span><span>validation_batches</span><span>]):</span>
                        <span>val_inputs</span> <span>=</span> <span>val_inputs</span><span>.</span><span>to</span><span>(</span><span>device</span><span>)</span><span>.</span><span>to</span><span>(</span><span>torch</span><span>.</span><span>long</span><span>)</span>
                        <span>val_targets</span> <span>=</span> <span>val_targets</span><span>.</span><span>to</span><span>(</span><span>device</span><span>)</span><span>.</span><span>to</span><span>(</span><span>torch</span><span>.</span><span>long</span><span>)</span>
                        <span>val_logits</span> <span>=</span> <span>base_model</span><span>(</span><span>val_inputs</span><span>)</span>
                        <span>val_losses</span><span>.</span><span>append</span><span>(</span>
                            <span>calculate_loss</span><span>(</span><span>val_logits</span><span>,</span> <span>val_targets</span><span>)</span><span>.</span><span>item</span><span>()</span>
                        <span>)</span>
                    <span>val_loss</span> <span>=</span> <span>sum</span><span>(</span><span>val_losses</span><span>)</span> <span>/</span> <span>len</span><span>(</span><span>val_losses</span><span>)</span>

                <span>if</span> <span>best_loss</span> <span>is</span> <span>None</span> <span>or</span> <span>val_loss</span> <span>&lt;</span> <span>best_loss</span><span>:</span>
                    <span>is_best</span> <span>=</span> <span>True</span>
                    <span>best_loss</span> <span>=</span> <span>val_loss</span>
                <span>else</span><span>:</span>
                    <span>is_best</span> <span>=</span> <span>False</span>

                <span>avg_train_loss</span> <span>=</span> <span>sum</span><span>(</span><span>train_losses</span><span>)</span> <span>/</span> <span>len</span><span>(</span><span>train_losses</span><span>)</span>
                <span>train_losses</span> <span>=</span> <span>[]</span>

                <span>save_checkpoint</span><span>(</span>
                    <span>run_dir</span><span>,</span>
                    <span>f</span><span>"iteration-</span><span>{</span><span>ix</span><span>}</span><span>"</span><span>,</span>
                    <span>base_model</span><span>,</span> <span>optimizer</span><span>,</span> <span>scaler</span><span>,</span>
                    <span>avg_train_loss</span><span>,</span> <span>val_loss</span><span>,</span>
                    <span>ix</span><span>,</span>
                    <span>is_best</span>
                <span>)</span>
                <span>generate_training_chart</span><span>(</span><span>run_dir</span><span>)</span>

                <span>model</span><span>.</span><span>train</span><span>()</span>
                <span>print</span><span>(</span><span>"Continuing training"</span><span>)</span>

            <span>dist</span><span>.</span><span>barrier</span><span>()</span>
</code></pre>
</div>

<p>That seems to work OK (<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/a44b90088ca6373be6749cb512e4221ebb9c67b6/ddp_train.py" target="_blank" rel="noopener noreferrer">code here</a>),
but it does give a warning:</p>

<div>
<pre><span></span><code><span>UserWarning: barrier(): using the device under current context. You can specify ``device_id`` in ``init_process_group`` to mute this warning.</span>
</code></pre>
</div>

<p>So, we want to pass the device ID in when we call <code>init_process_group</code>.  Let's dig into
that a bit.</p>

<h3>Revisiting the init code</h3>

<p>Here's the copypasta that I took from the PyTorch tutorial earlier in this post:</p>

<div>
<pre><span></span><code>    <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>set_device_index</span><span>(</span><span>int</span><span>(</span><span>os</span><span>.</span><span>environ</span><span>[</span><span>"LOCAL_RANK"</span><span>]))</span>
    <span>acc</span> <span>=</span> <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>current_accelerator</span><span>()</span>
    <span>backend</span> <span>=</span> <span>torch</span><span>.</span><span>distributed</span><span>.</span><span>get_default_backend_for_device</span><span>(</span><span>acc</span><span>)</span>
    <span>dist</span><span>.</span><span>init_process_group</span><span>(</span><span>backend</span><span>)</span>
    <span>rank</span> <span>=</span> <span>dist</span><span>.</span><span>get_rank</span><span>()</span>
    <span>print</span><span>(</span><span>f</span><span>"On rank </span><span>{</span><span>rank</span><span>}</span><span>."</span><span>)</span>
    <span>device_id</span> <span>=</span> <span>rank</span> <span>%</span> <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>device_count</span><span>()</span>
</code></pre>
</div>

<p>Let's dig into what that is doing.</p>

<p>The <code>LOCAL_RANK</code> environment variable is being set by <code>torchrun</code> to 0, 1, 2, etc as
appropriate to tell us which process we are on this machine.  So the first line is telling PyTorch
to <a href="https://docs.pytorch.org/docs/stable/generated/torch.accelerator.device_index.html" target="_blank" rel="noopener noreferrer">use the device with that index for this process</a>.</p>

<p>The next line is <a href="https://docs.pytorch.org/docs/stable/generated/torch.accelerator.current_accelerator.html" target="_blank" rel="noopener noreferrer">getting the current accelerator</a> --
that is, an object that represents which acceleration hardware we're using in
this process.</p>

<p>I think that the best way to see the combination of these two lines is that the first
says "use <code>gpu0</code>" (or 1, or 2, or...), and then the second says "get the object
describing the GPU you're using right now".  So it's a slightly indirect way of
getting the object containing the details of the GPU in question.</p>

<p>Next, we call <a href="https://docs.pytorch.org/docs/stable/distributed.html#torch.distributed.get_default_backend_for_device" target="_blank" rel="noopener noreferrer"><code>torch.distributed.get_default_backend_for_device</code></a>.
A backend in this context is an abstraction of whatever system the device in question
is programmed using -- in the case of an Nvidia GPU, it would be some kind of thing
that encapsulates CUDA.</p>

<p>Once that's done, we call <a href="https://docs.pytorch.org/docs/2.9/distributed.html#torch.distributed.init_process_group" target="_blank" rel="noopener noreferrer"><code>torch.distributed.init_process_group</code></a>,
passing in the backend that we're using.  We're saying "initialise the internal
data structures for <code>torch.distributed</code> so that they're all set up properly to work
with the backend we specified".</p>

<p>After that, we can do stuff like getting the global rank with <code>dist.get_rank</code> and so on, because <code>torch.distributed</code>
has been properly initialized.  Presumably at this point we're talking to any other machines
in a multi-machine cluster, so we can find out what our world size is and that kind of thing.</p>

<p>That extra line at the end, to get the <code>device_id</code>:</p>

<div>
<pre><span></span><code>    <span>device_id</span> <span>=</span> <span>rank</span> <span>%</span> <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>device_count</span><span>()</span>
</code></pre>
</div>

<p>...actually looks erroneous to me.  All of our code is assuming one process per GPU.
So I think we can just use the <code>LOCAL_RANK</code> there as well.</p>

<p>Let's rewrite it like this (with some useful comments):</p>

<div>
<pre><span></span><code>    <span># Which of the one-per-GPU processes are we?</span>
    <span>rank</span> <span>=</span> <span>int</span><span>(</span><span>os</span><span>.</span><span>environ</span><span>[</span><span>"LOCAL_RANK"</span><span>])</span>

    <span># Set ourselves up to use the GPU with ID ``rank``</span>
    <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>set_device_index</span><span>(</span><span>rank</span><span>)</span>

    <span># Get the accelerator object associated with that GPU,</span>
    <span># and the associated backend object (eg. ``nccl`` for CUDA):</span>
    <span>acc</span> <span>=</span> <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>current_accelerator</span><span>()</span>
    <span>backend</span> <span>=</span> <span>torch</span><span>.</span><span>distributed</span><span>.</span><span>get_default_backend_for_device</span><span>(</span><span>acc</span><span>)</span>

    <span># Initialize torch.distributed; set the device ID explicitly</span>
    <span># to avoid warnings in ``dist.barrier``</span>
    <span>dist</span><span>.</span><span>init_process_group</span><span>(</span><span>backend</span><span>,</span> <span>device_id</span><span>=</span><span>rank</span><span>)</span>

    <span>print</span><span>(</span><span>f</span><span>"On rank </span><span>{</span><span>rank</span><span>}</span><span>."</span><span>)</span>
    <span>model</span> <span>=</span> <span>GPTModel</span><span>(</span><span>model_conf</span><span>)</span><span>.</span><span>to</span><span>(</span><span>rank</span><span>)</span>
</code></pre>
</div>

<p>That seems to work well!  <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/0f17f4fc455031020400ac3ccc7d41e3dc8d44dc/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's the code</a>.
However, I ran it past ChatGPT (largely to validate my understanding of what was
going on), and it highlighted something slightly misleading about it.</p>

<p>Right now, we're training on a single node, with one process per GPU.  But again, one
of the neat-o things about this DDP stuff is that it should be able to scale to multiple
nodes.</p>

<p>Now, remember that <code>LOCAL_RANK</code> is just the rank of the current process on the specific node that it's
running on -- hence the name.  If we had two machines, each with 8 GPUs, then
there would be a process with rank zero on each of them.</p>

<p>The "real" rank -- that is, across all machines -- is the one that you can get from
<code>dist.get_rank</code> once it has been initialised.  One of the things it does during that
initialisation is to talk to all of the other nodes and work that kind of thing out
-- which of the local rank zero processes across all of the machines is the global rank zero
process.</p>

<p>So we need to use the local rank when working out which GPU we should be running on
and so on, but we should not treat it as a global rank.</p>

<p>That's actually quite fine in this case, as we're calling <code>dist.get_rank</code> inside
the training loop when we actually need to use the global one (when indexing into
the dataset, or when deciding if we're the process that should be doing evals and
checkpoints).  The only place where we might be confusing matters is in that
print, which is not important anyway, as the training loop also prints out its rank.</p>

<p>So, let's tweak it a little more for clarity:</p>

<div>
<pre><span></span><code>    <span># Which of the one-per-GPU processes are we on this machine?</span>
    <span>local_rank</span> <span>=</span> <span>int</span><span>(</span><span>os</span><span>.</span><span>environ</span><span>[</span><span>"LOCAL_RANK"</span><span>])</span>

    <span># Set ourselves up to use the GPU with the ID that matches our local rank</span>
    <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>set_device_index</span><span>(</span><span>local_rank</span><span>)</span>

    <span># Get the accelerator object associated with that GPU,</span>
    <span># and the associated backend object (eg. ``nccl`` for CUDA):</span>
    <span>acc</span> <span>=</span> <span>torch</span><span>.</span><span>accelerator</span><span>.</span><span>current_accelerator</span><span>()</span>
    <span>backend</span> <span>=</span> <span>torch</span><span>.</span><span>distributed</span><span>.</span><span>get_default_backend_for_device</span><span>(</span><span>acc</span><span>)</span>

    <span># Initialize torch.distributed; set the device ID explicitly</span>
    <span># to avoid warnings in ``dist.barrier``</span>
    <span>dist</span><span>.</span><span>init_process_group</span><span>(</span><span>backend</span><span>,</span> <span>device_id</span><span>=</span><span>local_rank</span><span>)</span>

    <span>model</span> <span>=</span> <span>GPTModel</span><span>(</span><span>model_conf</span><span>)</span><span>.</span><span>to</span><span>(</span><span>local_rank</span><span>)</span>
</code></pre>
</div>

<p>That seems to work well!  <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/5ae5ea2aa38cd5f62b609e2bf33c8a45d5b642d4/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's the code</a>.</p>

<p>Time to run it past ChatGPT to see if I've made any dumb errors.  Turns out that
(unsurprisingly) I have...</p>

<h3>Checkpointing, revisited</h3>

<p>Let's go back to our code that decides whether or not it's an iteration where we need
to do a validation run and a checkpoint:</p>

<div>
<pre><span></span><code>        <span>is_eval_iter</span> <span>=</span> <span>(</span>
            <span>(</span><span>ix</span> <span>%</span> <span>validation_interval</span> <span>==</span> <span>0</span><span>)</span>
            <span>or</span> <span>(</span><span>ix</span> <span>==</span> <span>len</span><span>(</span><span>train_ds</span><span>)</span> <span>-</span> <span>1</span><span>)</span>
        <span>)</span>
</code></pre>
</div>

<p>The problem is that our index <code>ix</code> is different in the different processes!  Remember, we have
this in order to pick out the correct training items:</p>

<div>
<pre><span></span><code>    <span>for</span> <span>ix</span> <span>in</span> <span>tqdm</span><span>(</span><span>range</span><span>(</span><span>train_ds_offset</span> <span>+</span> <span>rank</span><span>,</span> <span>len</span><span>(</span><span>train_ds</span><span>),</span> <span>world_size</span><span>)):</span>
</code></pre>
</div>

<p>So let's think about it; in the first run through the loop, with 8 GPUs, we would have</p>

<ul>
<li><code>ix</code> = 0 for the process with rank 0</li>
<li><code>ix</code> = 1 for the process with rank 1</li>
<li>...</li>
<li><code>ix</code> = 7 for the process with rank 7</li>
</ul>

<p>In the next run through the loop, we'd have:</p>

<ul>
<li><code>ix</code> = 8 for the process with rank 0</li>
<li><code>ix</code> = 9 for the process with rank 1</li>
<li>...</li>
<li><code>ix</code> = 15 for the process with rank 7</li>
</ul>

<p>So <code>is_eval_iter</code> will give different results for each process.   That might not
sound like the end of the world -- <code>ix % validation_interval</code> will only be zero for
one of them, so long as <code>validation_interval</code> is larger than the number of GPUs --
but remember that our validation code looks like this:</p>

<div>
<pre><span></span><code>        <span>if</span> <span>is_eval_iter</span><span>:</span>
            <span>dist</span><span>.</span><span>barrier</span><span>()</span>

            <span>if</span> <span>rank</span> <span>==</span> <span>0</span><span>:</span>
                <span># do the validation and checkpointing</span>

            <span>dist</span><span>.</span><span>barrier</span><span>()</span>
</code></pre>
</div>

<p>Now, if different processes have different values for <code>is_eval_iter</code>, then
<code>dist.barrier()</code> will only be called in the one(s) for which it is <code>True</code>.  But
<code>dist.barrier()</code> means "wait until all processes have reached this barrier".  So the
ones that call it will lock up completely until other processes get there, and everything
will at best get out-of-sync, and at worst will lock up completely.</p>

<p>I think that the problem here is that I'm conflating two things: the index of the global step -- that is, one
iteration across all GPUs -- and the dataset element that we want to use.  In the original
one-GPU case that made, sense; iteration 0 was on dataset element 0, iteration 1 was on element 1,
and so on.  But now the offset into the dataset, and the global step, are quite different things.</p>

<p>This is quite deeply embedded in the code, but
we can fix it!</p>

<p>Let's start off by changing our checkpoint code, just to rename things.  It keeps track
of a variable called <code>train_ds_offset</code>, our offset into the training dataset, and uses
that both to index into the dataset, and to work out how far through the train we are.
The latter is a much better thing to store in a checkpoint, so instead of
saving <code>train_ds_offset</code>, we'll store (and restore) <code>global_step</code>.  Basically, just
a rename so that the variables and stored JSON match the new reality.
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/c8702169afb44082a4571b0179e1ad4a2c43fb3d/checkpointing.py" target="_blank" rel="noopener noreferrer">Here's the updated code</a>.</p>

<p>Now we need to make a number of minor changes to the training loop just to match that
rename of the value that we're checkpointing (eg. for the code to generate the training
chart) but the most important change is to our loop.  Instead of iterating over our dataset with
a step and and offset so that we can index into it, we firstly work out how many
global steps there will be:</p>

<div>
<pre><span></span><code><span>total_global_steps</span> <span>=</span> <span>len</span><span>(</span><span>train_ds</span><span>)</span> <span>//</span> <span>world_size</span>
</code></pre>
</div>

<p>...then we iterate from our initial global step -- zero if we're starting a fresh
train, or whatever global step we were on in a loaded checkpoint plus one if we're
doing a continued train from a checkpoint -- up to the <code>total_global_steps</code>:</p>

<div>
<pre><span></span><code><span>for</span> <span>global_step</span> <span>in</span> <span>tqdm</span><span>(</span><span>range</span><span>(</span><span>start_global_step</span><span>,</span> <span>total_global_steps</span><span>)):</span>
</code></pre>
</div>

<p>That means that we need to use the global step, the world size, and our current rank
to work out which dataset item we should be training on for this process at this global
step.  Let's say that we have eight processes; on the 0th global step, we should have
rank 0 training on dataset item 0, rank 1 on item 1, and so on.  On the next global step,
rank 0 should train on item 8, rank 1 on 9, and so on.  So:</p>

<div>
<pre><span></span><code><span>inputs</span><span>,</span> <span>targets</span> <span>=</span> <span>train_ds</span><span>[</span><span>global_step</span> <span>*</span> <span>world_size</span> <span>+</span> <span>rank</span><span>]</span>
</code></pre>
</div>

<p>That's actually much more elegant than the earlier code, and seems to work fine.
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/c8702169afb44082a4571b0179e1ad4a2c43fb3d/ddp_train.py" target="_blank" rel="noopener noreferrer">Here it is</a>.</p>

<p>Phew, glad to have caught that before I started spending money on machines -- it would
have been confusing if everything locked up.  Thanks, ChatGPT!</p>

<h3>Slicing the validation dataset</h3>

<p>Another thing that raised by ChatGPT is about the validation.  We don't want to validate
across all of the validation dataset -- we're using a number from the <code>train.json</code>.  I have this code:</p>

<div>
<pre><span></span><code>    <span>for</span> <span>val_inputs</span><span>,</span> <span>val_targets</span> <span>in</span> <span>tqdm</span><span>(</span><span>val_ds</span><span>[:</span><span>validation_batches</span><span>]):</span>
</code></pre>
</div>

<p>This looked like a nice, quick way to get the first <code>validation_batches</code> elements of
the validation dataset.  But ChatGPT told me it would raise.  It didn't, though -- why?</p>

<p>The problem is that I had <code>validation_batches</code> set to <code>2</code> in my training config for testing.
Stepping through what that slice does, when we run <code>val_ds[:validation_batches]</code>:</p>

<ul>
<li><p>Python calls the <code>__getitem__</code> on the dataset, passing in a <code>slice</code> object as <code>ix</code>,
so this code is called with it:</p>

<div>
<pre><span></span><code><span>def</span><span> </span><span>__getitem__</span><span>(</span><span>self</span><span>,</span> <span>ix</span><span>):</span>
    <span>return</span> <span>(</span><span>self</span><span>.</span><span>xs</span><span>[</span><span>ix</span><span>],</span> <span>self</span><span>.</span><span>ys</span><span>[</span><span>ix</span><span>])</span>
</code></pre>
</div></li>
<li><p>Now, because that code doesn't do anything clever with <code>slice</code>s, they're passed straight
down to the tensors that make up <code>self.xs</code> and <code>self.ys</code>.  So it's actually equivalent
to this:</p>

<div>
<pre><span></span><code><span>return</span> <span>self</span><span>.</span><span>xs</span><span>[:</span><span>validation_batches</span><span>],</span> <span>self</span><span>.</span><span>ys</span><span>[:</span><span>validation_batches</span><span>]</span>
</code></pre>
</div></li>
<li><p>Or, to rewrite the whole loop (omitting the <code>tqdm</code> for clarity):</p>

<div>
<pre><span></span><code><span>for</span> <span>val_inputs</span><span>,</span> <span>val_targets</span> <span>in</span> <span>(</span><span>self</span><span>.</span><span>xs</span><span>[:</span><span>validation_batches</span><span>],</span> <span>self</span><span>.</span><span>ys</span><span>[:</span><span>validation_batches</span><span>]):</span>
    <span>...</span>
</code></pre>
</div></li>
<li><p>So, the first time through the loop, we try to bind our loop variables like this:</p>

<div>
<pre><span></span><code><span>val_inputs</span><span>,</span> <span>val_targets</span> <span>=</span> <span>self</span><span>.</span><span>xs</span><span>[:</span><span>validation_batches</span><span>]</span>
</code></pre>
</div>

<p>That is clearly wrong!  It's equivalent to this:</p>

<div>
<pre><span></span><code><span>val_inputs</span> <span>=</span> <span>self</span><span>.</span><span>xs</span><span>[:</span><span>validation_batches</span><span>][</span><span>0</span><span>]</span>
<span>val_targets</span> <span>=</span> <span>self</span><span>.</span><span>xs</span><span>[:</span><span>validation_batches</span><span>][</span><span>1</span><span>]</span>
</code></pre>
</div>

<p>...with code to blow up if <code>self.xs[:validation_batches]</code> has more than two elements --
the normal Python "ValueError: too many values to unpack"</p></li>
<li>But if <code>validation_batches</code> is set to 2, which it happened to be in my case, then
it will silently fail -- our first eval loop will get the first X from the validation
set as <code>val_inputs</code>, and the second X as <code>val_targets</code>.</li>
</ul>

<p>Nasty!  AI code review certainly helped me dodge a bullet on that one.</p>

<p>Let's fix it, it's not a big change: we can just do this:</p>

<div>
<pre><span></span><code>    <span>for</span> <span>val_ix</span> <span>in</span> <span>tqdm</span><span>(</span><span>range</span><span>(</span><span>validation_batches</span><span>)):</span>
        <span>val_inputs</span><span>,</span> <span>val_targets</span> <span>=</span> <span>val_ds</span><span>[</span><span>val_ix</span><span>]</span>
</code></pre>
</div>

<p>...and that works!  So <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/87d15bfc4ff9187077b09293922df525fa42f425/ddp_train.py" target="_blank" rel="noopener noreferrer">here's the code now</a>.</p>

<h3>Back to the datasets</h3>

<p>So, I think we have one final issue, which is the training and validation datasets.  In our single-GPU
train, we worked out ahead of time how much of FineWeb (or FineWeb-Edu) to train on --
the Chinchilla-optimal number -- and
generated a dataset that contained a round number of 6-sequence, 1024-token batches
that was the smallest such round number that was larger than our target.  We also worked
out exactly how large (in terms of batches) our validation dataset needed to be so that
each validation run would take five minutes.</p>

<p>There was one big issue with that system; when I decided to do an "extended" train
on more of the FineWeb-Edu dataset, in order to see whether I could get the loss down further,
I had to do some nasty hackery in order to generate a new one.
So it would be nice to not have that problem this time around.</p>

<p>Additionally, we're likely to be tweaking the batch size quite a lot in this experiment
while we find what the appropriate level is to fit onto the cloud GPUs, and also varying
how much validation we do -- and additionally,
we have the world size to worry about.</p>

<p>I think that the best way to give us the flexibility we need will be to pre-convert
the complete FineWeb and FineWeb-Edu datasets into the format we need -- each sequence
in the dataset converted to GPT-2 tokens, and then those sequences concatenated together,
with the <code>&lt;|endoftext|&gt;</code> token 50257 separating them.</p>

<p>It would be good to properly nail down the validation dataset at the same time.  So
we can have a script that loads up the original dataset as downloaded from Hugging Face,
splits it into 99% train, 1% validation, does the conversion, and then saves them as
safetensors files.</p>

<p>If we use <code>uint16</code> for those (which is just large enough for our 50,257-token vocab), we can fit the ~10B tokens in each dataset's train split into 20 GiB of
disk.  Not too bad.</p>

<p>But there will still be the issue of getting them onto our cloud machines.  Let's generate
the data, and then work out how to handle that.</p>

<p>I tried initially with <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/aede6fbca2bf5ca518995ef39e58103e4c2dae15/prepare_datasets.py" target="_blank" rel="noopener noreferrer">the code I used last time, adapted to run through the entire dataset</a>.
It does the 99%/1% train/validation
split, and then for each of those generates a single massive tensor of tokens like this:</p>

<ul>
<li>Zoom through the records in the dataset in batches of 1,000.</li>
<li>For each batch:
<ul>
<li>Tokenising each batch, so we get a list of lists of tokens.</li>
<li>Convert that list of lists into a single list <code>&lt;|endoftext|&gt;</code> tokens separating each item.</li>
<li>Convert that list into a PyTorch <code>uint16</code> tensor.</li>
<li>Add the tensor to a <code>results</code> list.</li>
</ul></li>
<li>After that's all done, use <code>torch.cat</code> to convert the <code>results</code> list into a single
tensor, and then save that with <code>safetensors</code>.</li>
</ul>

<p>It <em>almost</em> worked!  To my surprise, it got all the way to the end, and only
blew up with an out-of-memory error when it was trying to save the result -- and it did that completely silently,
so I thought it had worked right up until I tried to check the file on disk to see
how large it was, and it wasn't there.</p>

<p>The obvious tweak: set the <code>results</code> list to <code>None</code> just after the <code>torch.cat</code>, to
free up the memory it's using.  Given that it was the save that triggered the OOM,
you'd think that that would be enough -- but it turned out not to be so.</p>

<p>Rather than mess around with this for much longer, I just decided to add on 128 GiB
of swap to my machine temporarily:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>sudo<span> </span>dd<span> </span><span>if</span><span>=</span>/dev/zero<span> </span><span>of</span><span>=</span>./swap<span> </span><span>bs</span><span>=</span>1G<span> </span><span>count</span><span>=</span><span>128</span>
<span>[</span>sudo<span>]</span><span> </span>password<span> </span><span>for</span><span> </span>giles:
<span>128</span>+0<span> </span>records<span> </span><span>in</span>
<span>128</span>+0<span> </span>records<span> </span>out
<span>137438953472</span><span> </span>bytes<span> </span><span>(</span><span>137</span><span> </span>GB,<span> </span><span>128</span><span> </span>GiB<span>)</span><span> </span>copied,<span> </span><span>63</span>.1124<span> </span>s,<span> </span><span>2</span>.2<span> </span>GB/s
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>sudo<span> </span>chmod<span> </span><span>0600</span><span> </span>./swap
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>sudo<span> </span>mkswap<span> </span>./swap
Setting<span> </span>up<span> </span>swapspace<span> </span>version<span> </span><span>1</span>,<span> </span><span>size</span><span> </span><span>=</span><span> </span><span>128</span><span> </span>GiB<span> </span><span>(</span><span>137438949376</span><span> </span>bytes<span>)</span>
no<span> </span>label,<span> </span><span>UUID</span><span>=</span>693d72a1-871d-4ab8-b0c8-b383b435ca8f
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>sudo<span> </span>swapon<span> </span>./swap
</code></pre>
</div>

<p>...and that was enough to make it run.  So I've now generated pre-tokenised,
pre-concatenated train and validation sets for both FineWeb and FineWeb-Edu:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>ls<span> </span>-lrth<span> </span>fineweb-prepared/
total<span> </span>20G
-rw-r--r--<span> </span><span>1</span><span> </span>giles<span> </span>giles<span> </span>196M<span> </span>Dec<span>  </span><span>4</span><span> </span><span>21</span>:02<span> </span>validation.safetensors
-rw-r--r--<span> </span><span>1</span><span> </span>giles<span> </span>giles<span>  </span>20G<span> </span>Dec<span>  </span><span>4</span><span> </span><span>21</span>:20<span> </span>train.safetensors
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>ls<span> </span>-lrth<span> </span>fineweb-edu-prepared/
total<span> </span>19G
-rw-r--r--<span> </span><span>1</span><span> </span>giles<span> </span>giles<span> </span>192M<span> </span>Dec<span>  </span><span>4</span><span> </span><span>22</span>:43<span> </span>validation.safetensors
-rw-r--r--<span> </span><span>1</span><span> </span>giles<span> </span>giles<span>  </span>19G<span> </span>Dec<span>  </span><span>4</span><span> </span><span>22</span>:59<span> </span>train.safetensors
</code></pre>
</div>

<p>Now, thinking about how to get it up to the Lambda Labs machines.  I have normal
1 Gb residential broadband, so conceivably I could upload 20 GiB in about
200 seconds.  But that's assuming that there's no network congestion, so I would
expect it to take longer.  The LL machines are quite expensive, and I don't want to
waste money keeping them up while I'm just uploading data.</p>

<p>There are possibilities here:</p>

<ol>
<li>I can upload the datasets to Hugging Face; their network connection will be better
than mine, so I can just pay the price in time of uploading everything from home once, and
then I can download them faster from  HF to LL.  That also has the benefit of meaning
that after this experiment I can safely delete the local files, but then download
them again if I need them.  And if anyone else wants to repro this experiment,
the data will be easily available to them.</li>
<li>Lambda Labs have persistent filesystems that you can use.  They cost $0.20/GB/month,
so that would be about $5/month for all of my datasets.  So I could upload the data
to a cheap instance with a persistent filesystem mounted, shut down that instance
but keep the filesystem, and then mount it on each machine I use to run tests. .</li>
</ol>

<p>I think the best option is to use option (1), but with the option of also doing (2).
The HF dataset will still take time to download to LL, even over the faster network
connection.  That might not be a problem -- but if it is, I download it once on a cheap
instance and use a persistent disk too.  Essentially I'd be using
the persistent disk as a "cache", and still get the benefits of the easily-shareable
datasets on Hugging Face.</p>

<p>So, that decided, let's find out how we can upload a whacking great 20 GiB safetensors
file as a dataset on Hugging Face.</p>

<h3>Putting the datasets on Hugging Face.</h3>

<p>It turns out that resources like datasets on HF are just Git repositories using
the LFS (Large File System) plugin to be able to handle, well, large files.
Conveniently, given that I'm using <code>uv</code> to manage my project, there's
a <a href="https://huggingface.co/docs/huggingface_hub/main/en/guides/cli#using-uv" target="_blank" rel="noopener noreferrer">plugin</a> that
allows me to use their CLI tools with minimal effort, so:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>auth<span> </span>login

<span>    </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>    </span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span><span>      </span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span>_<span>|</span><span>      </span>_<span>|</span>_<span>|</span>_<span>|</span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span><span>      </span>_<span>|</span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span>_<span>|</span>_<span>|</span>_<span>|</span>
<span>    </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>        </span>_<span>|</span><span>          </span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>            </span>_<span>|</span><span>        </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>        </span>_<span>|</span>
<span>    </span>_<span>|</span>_<span>|</span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>  </span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span><span>  </span>_<span>|</span>_<span>|</span><span>    </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>  </span>_<span>|</span><span>  </span>_<span>|</span><span>  </span>_<span>|</span>_<span>|</span><span>      </span>_<span>|</span>_<span>|</span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span><span>        </span>_<span>|</span>_<span>|</span>_<span>|</span>
<span>    </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>    </span>_<span>|</span><span>    </span>_<span>|</span><span>    </span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span><span>    </span>_<span>|</span><span>      </span>_<span>|</span><span>        </span>_<span>|</span><span>    </span>_<span>|</span><span>  </span>_<span>|</span><span>        </span>_<span>|</span>
<span>    </span>_<span>|</span><span>    </span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span><span>      </span>_<span>|</span>_<span>|</span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span><span>      </span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span>_<span>|</span><span>      </span>_<span>|</span><span>        </span>_<span>|</span><span>    </span>_<span>|</span><span>    </span>_<span>|</span>_<span>|</span>_<span>|</span><span>  </span>_<span>|</span>_<span>|</span>_<span>|</span>_<span>|</span>

<span>    </span>To<span> </span>log<span> </span><span>in</span>,<span> </span><span>``</span>huggingface_hub<span>``</span><span> </span>requires<span> </span>a<span> </span>token<span> </span>generated<span> </span>from<span> </span>https://huggingface.co/settings/tokens<span> </span>.
Enter<span> </span>your<span> </span>token<span> </span><span>(</span>input<span> </span>will<span> </span>not<span> </span>be<span> </span>visible<span>)</span>:
Add<span> </span>token<span> </span>as<span> </span>git<span> </span>credential?<span> </span><span>[</span>y/N<span>]</span>:<span> </span>n
Token<span> </span>is<span> </span>valid<span> </span><span>(</span>permission:<span> </span>write<span>)</span>.
The<span> </span>token<span> </span><span>``</span><span>[</span>REDACTED<span>]</span><span>``</span><span> </span>has<span> </span>been<span> </span>saved<span> </span>to<span> </span>/home/giles/.cache/huggingface/stored_tokens
Your<span> </span>token<span> </span>has<span> </span>been<span> </span>saved<span> </span>to<span> </span>/home/giles/.cache/huggingface/token
Login<span> </span>successful.
The<span> </span>current<span> </span>active<span> </span>token<span> </span>is:<span> </span><span>``</span><span>[</span>REDACTED<span>]</span><span>``</span>
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>repo<span> </span>create<span> </span>fineweb-gpt2-tokens<span> </span>--repo-type<span> </span>dataset
Successfully<span> </span>created<span> </span>gpjt/fineweb-gpt2-tokens<span> </span>on<span> </span>the<span> </span>Hub.
Your<span> </span>repo<span> </span>is<span> </span>now<span> </span>available<span> </span>at<span> </span>https://huggingface.co/datasets/gpjt/fineweb-gpt2-tokens
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>repo<span> </span>create<span> </span>fineweb-edu-gpt2-tokens<span> </span>--repo-type<span> </span>dataset
Successfully<span> </span>created<span> </span>gpjt/fineweb-edu-gpt2-tokens<span> </span>on<span> </span>the<span> </span>Hub.
Your<span> </span>repo<span> </span>is<span> </span>now<span> </span>available<span> </span>at<span> </span>https://huggingface.co/datasets/gpjt/fineweb-edu-gpt2-tokens
</code></pre>
</div>

<p>Both datasets show up on my profile page on Hugging Face, so that's looking good.
Now it's time to try to upload the data.  We'll need to install Git's LFS support
first:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>lfs<span> </span>install
Updated<span> </span>Git<span> </span>hooks.
Git<span> </span>LFS<span> </span>initialized.
</code></pre>
</div>

<p>Now let's try the FineWeb one first:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>clone<span> </span>https://huggingface.co/datasets/gpjt/fineweb-gpt2-tokens
Cloning<span> </span>into<span> </span><span>'fineweb-gpt2-tokens'</span>...
remote:<span> </span>Enumerating<span> </span>objects:<span> </span><span>3</span>,<span> </span><span>done</span>.
remote:<span> </span>Total<span> </span><span>3</span><span> </span><span>(</span>delta<span> </span><span>0</span><span>)</span>,<span> </span>reused<span> </span><span>0</span><span> </span><span>(</span>delta<span> </span><span>0</span><span>)</span>,<span> </span>pack-reused<span> </span><span>3</span><span> </span><span>(</span>from<span> </span><span>1</span><span>)</span>
Unpacking<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>3</span>/3<span>)</span>,<span> </span><span>1</span>.17<span> </span>KiB<span> </span><span>|</span><span> </span><span>1</span>.17<span> </span>MiB/s,<span> </span><span>done</span>.
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span><span>cd</span><span> </span>fineweb-gpt2-tokens
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>cp<span> </span>../fineweb-prepared/train.safetensors<span> </span>.
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>cp<span> </span>../fineweb-prepared/validation.safetensors<span> </span>.
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>cat<span> </span>&gt;<span> </span>meta.json<span> </span><span>&lt;&lt; 'EOF'</span>
<span>{</span>
<span>  "description": "FineWeb 10BT tokenized with GPT-2 BPE (tiktoken). uint16 safetensors, single long sequence with ``&lt;|endoftext|&gt;`` separators.",</span>
<span>  "token_dtype": "uint16",</span>
<span>  "files": {</span>
<span>    "train": "train.safetensors",</span>
<span>    "validation": "validation.safetensors"</span>
<span>  }</span>
<span>}</span>
<span>EOF</span>
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>add<span> </span>.
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>commit<span> </span>-am<span>"First cut, added GPT-2 tokens"</span>
<span>[</span>main<span> </span>3af6ef2<span>]</span><span> </span>First<span> </span>cut,<span> </span>added<span> </span>GPT-2<span> </span>tokens
<span> </span><span>3</span><span> </span>files<span> </span>changed,<span> </span><span>14</span><span> </span>insertions<span>(</span>+<span>)</span>
<span> </span>create<span> </span>mode<span> </span><span>100644</span><span> </span>meta.json
<span> </span>create<span> </span>mode<span> </span><span>100644</span><span> </span>train.safetensors
<span> </span>create<span> </span>mode<span> </span><span>100644</span><span> </span>validation.safetensors
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>push
Username<span> </span><span>for</span><span> </span><span>'https://huggingface.co'</span>:<span> </span>gpjt
Password<span> </span><span>for</span><span> </span><span>'https://gpjt@huggingface.co'</span>:
Username<span> </span><span>for</span><span> </span><span>'https://huggingface.co'</span>:<span> </span>gpjtB/s
Password<span> </span><span>for</span><span> </span><span>'https://gpjt@huggingface.co'</span>:
batch<span> </span>response:
You<span> </span>need<span> </span>to<span> </span>configure<span> </span>your<span> </span>repository<span> </span>to<span> </span><span>enable</span><span> </span>upload<span> </span>of<span> </span>files<span> </span>&gt;<span> </span>5GB.
Run<span> </span><span>"hf lfs-enable-largefiles ./path/to/your/repo"</span><span> </span>and<span> </span>try<span> </span>again.

error:<span> </span>failed<span> </span>to<span> </span>push<span> </span>some<span> </span>refs<span> </span>to<span> </span><span>'https://huggingface.co/datasets/gpjt/fineweb-gpt2-tokens'</span>
</code></pre>
</div>

<p>OK, so we need some kind of extra thing to tell it we can use large files on top of
the LFS stuff:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>lfs-enable-largefiles<span> </span>.
Local<span> </span>repo<span> </span><span>set</span><span> </span>up<span> </span><span>for</span><span> </span>largefiles
</code></pre>
</div>

<p>Right, now let's try again:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>push
Username<span> </span><span>for</span><span> </span><span>'https://huggingface.co'</span>:<span> </span>gpjt
Password<span> </span><span>for</span><span> </span><span>'https://gpjt@huggingface.co'</span>:
Username<span> </span><span>for</span><span> </span><span>'https://huggingface.co'</span>:<span> </span>gpjtB/s
Password<span> </span><span>for</span><span> </span><span>'https://gpjt@huggingface.co'</span>:
EOFoading<span> </span>LFS<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>2</span>/2<span>)</span>,<span> </span><span>21</span><span> </span>GB<span> </span><span>|</span><span> </span><span>0</span><span> </span>B/s
error:<span> </span>failed<span> </span>to<span> </span>push<span> </span>some<span> </span>refs<span> </span>to<span> </span><span>'https://huggingface.co/datasets/gpjt/fineweb-gpt2-tokens'</span>
</code></pre>
</div>

<p>Weird that it prompted for the credentials twice, but it did appear to try to do
something there -- but obviously it didn't work.</p>

<p>Let's see if Git over SSH is any better.</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span><span>cd</span><span> </span>..
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>rm<span> </span>-rf<span> </span>fineweb-gpt2-tokens/
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>clone<span> </span>git@hf.co:datasets/gpjt/fineweb-gpt2-tokens
Cloning<span> </span>into<span> </span><span>'fineweb-gpt2-tokens'</span>...
**<span> </span>WARNING:<span> </span>connection<span> </span>is<span> </span>not<span> </span>using<span> </span>a<span> </span>post-quantum<span> </span>key<span> </span>exchange<span> </span>algorithm.
**<span> </span>This<span> </span>session<span> </span>may<span> </span>be<span> </span>vulnerable<span> </span>to<span> </span><span>"store now, decrypt later"</span><span> </span>attacks.
**<span> </span>The<span> </span>server<span> </span>may<span> </span>need<span> </span>to<span> </span>be<span> </span>upgraded.<span> </span>See<span> </span>https://openssh.com/pq.html
remote:<span> </span>Enumerating<span> </span>objects:<span> </span><span>3</span>,<span> </span><span>done</span>.
remote:<span> </span>Total<span> </span><span>3</span><span> </span><span>(</span>delta<span> </span><span>0</span><span>)</span>,<span> </span>reused<span> </span><span>0</span><span> </span><span>(</span>delta<span> </span><span>0</span><span>)</span>,<span> </span>pack-reused<span> </span><span>3</span><span> </span><span>(</span>from<span> </span><span>1</span><span>)</span>
Receiving<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>3</span>/3<span>)</span>,<span> </span><span>done</span>.
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span><span>cd</span><span> </span>fineweb-gpt2-tokens
</code></pre>
</div>

<p>...then the same stuff to copy in the files and create the metadata file, then:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>lfs-enable-largefiles<span> </span>.
Local<span> </span>repo<span> </span><span>set</span><span> </span>up<span> </span><span>for</span><span> </span>largefiles
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>add<span> </span>.
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>commit<span> </span>-am<span>"First cut of code to prepare datasets"</span>
<span>[</span>main<span> </span>44df15c<span>]</span><span> </span>First<span> </span>cut<span> </span>of<span> </span>code<span> </span>to<span> </span>prepare<span> </span>datasets
<span> </span><span>3</span><span> </span>files<span> </span>changed,<span> </span><span>14</span><span> </span>insertions<span>(</span>+<span>)</span>
<span> </span>create<span> </span>mode<span> </span><span>100644</span><span> </span>meta.json
<span> </span>create<span> </span>mode<span> </span><span>100644</span><span> </span>train.safetensors
<span> </span>create<span> </span>mode<span> </span><span>100644</span><span> </span>validation.safetensors
giles@perry:~/Dev/ddp-base-model-from-scratch/fineweb-gpt2-tokens<span> </span><span>(</span>main<span>)</span>$<span> </span>git<span> </span>push
**<span> </span>WARNING:<span> </span>connection<span> </span>is<span> </span>not<span> </span>using<span> </span>a<span> </span>post-quantum<span> </span>key<span> </span>exchange<span> </span>algorithm.
**<span> </span>This<span> </span>session<span> </span>may<span> </span>be<span> </span>vulnerable<span> </span>to<span> </span><span>"store now, decrypt later"</span><span> </span>attacks.
**<span> </span>The<span> </span>server<span> </span>may<span> </span>need<span> </span>to<span> </span>be<span> </span>upgraded.<span> </span>See<span> </span>https://openssh.com/pq.html
EOFoading<span> </span>LFS<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>2</span>/2<span>)</span>,<span> </span><span>21</span><span> </span>GB<span> </span><span>|</span><span> </span><span>0</span><span> </span>B/s
error:<span> </span>failed<span> </span>to<span> </span>push<span> </span>some<span> </span>refs<span> </span>to<span> </span><span>'hf.co:datasets/gpjt/fineweb-gpt2-tokens'</span>
</code></pre>
</div>

<p>Looks like the same error.  Odd.</p>

<p>Let's try using HF's upload tools rather than Git -- feels like a bit of a cop-out,
but maybe it'll work better.</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>upload<span> </span>gpjt/fineweb-gpt2-tokens<span> </span>./fineweb-prepared/train.safetensors<span> </span>train.safetensors<span> </span>--repo-type<span> </span>dataset
Processing<span> </span>Files<span> </span><span>(</span><span>1</span><span> </span>/<span> </span><span>1</span><span>)</span><span>      </span>:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>20</span>.5GB<span> </span>/<span> </span><span>20</span>.5GB,<span> </span><span>2</span>.76MB/s
New<span> </span>Data<span> </span>Upload<span>               </span>:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>2</span>.95GB<span> </span>/<span> </span><span>2</span>.95GB,<span> </span><span>2</span>.76MB/s
<span>  </span>...repared/train.safetensors:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>20</span>.5GB<span> </span>/<span> </span><span>20</span>.5GB
https://huggingface.co/datasets/gpjt/fineweb-gpt2-tokens/commit/69085f941ba3e8f0750929a1f8cd451fba761bff
</code></pre>
</div>

<p>That did indeed take about 200 seconds to run, but the upload speed was only about
10 MiB/s -- from the output, I think it must have been compressing it.  Anyway, it looks like
it succeeded, so let's upload the others!</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>upload<span> </span>gpjt/fineweb-gpt2-tokens<span> </span>./fineweb-prepared/validation.safetensors<span> </span>validation.safetensors<span> </span>--repo-type<span> </span>dataset
Processing<span> </span>Files<span> </span><span>(</span><span>1</span><span> </span>/<span> </span><span>1</span><span>)</span><span>      </span>:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span>  </span>205MB<span> </span>/<span>  </span>205MB,<span> </span><span>78</span>.7MB/s
New<span> </span>Data<span> </span>Upload<span>               </span>:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span>  </span>235kB<span> </span>/<span>  </span>235kB,<span> </span><span>90</span>.6kB/s
<span>  </span>...ed/validation.safetensors:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span>  </span>205MB<span> </span>/<span>  </span>205MB
https://huggingface.co/datasets/gpjt/fineweb-gpt2-tokens/commit/885777d5211383cc7990004f99a8823fad53be66
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>upload<span> </span>gpjt/fineweb-edu-gpt2-tokens<span> </span>./fineweb-edu-prepared/train.safetensors<span> </span>train.safetensors<span> </span>--repo-type<span> </span>dataset
Processing<span> </span>Files<span> </span><span>(</span><span>1</span><span> </span>/<span> </span><span>1</span><span>)</span><span>      </span>:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>19</span>.7GB<span> </span>/<span> </span><span>19</span>.7GB,<span> </span><span>4</span>.53MB/s
New<span> </span>Data<span> </span>Upload<span>               </span>:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3</span>.09GB<span> </span>/<span> </span><span>3</span>.09GB,<span> </span><span>4</span>.53MB/s
<span>  </span>...repared/train.safetensors:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>19</span>.7GB<span> </span>/<span> </span><span>19</span>.7GB
https://huggingface.co/datasets/gpjt/fineweb-edu-gpt2-tokens/commit/55baacd6812ac085df0c91ea573c8ccd89015341
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uvx<span> </span>hf<span> </span>upload<span> </span>gpjt/fineweb-edu-gpt2-tokens<span> </span>./fineweb-edu-prepared/validation.safetensors<span> </span>validation.safetensors<span> </span>--repo-type<span> </span>dataset
Processing<span> </span>Files<span> </span><span>(</span><span>1</span><span> </span>/<span> </span><span>1</span><span>)</span><span>      </span>:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span>  </span>201MB<span> </span>/<span>  </span>201MB,<span> </span><span>62</span>.8MB/s
New<span> </span>Data<span> </span>Upload<span>               </span>:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span>  </span>104kB<span> </span>/<span>  </span>104kB,<span> </span><span>32</span>.5kB/s
<span>  </span>...ed/validation.safetensors:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span>  </span>201MB<span> </span>/<span>  </span>201MB
https://huggingface.co/datasets/gpjt/fineweb-edu-gpt2-tokens/commit/8bc548d681476ecc79444779746d6dc1a852cca2
</code></pre>
</div>

<p>...and that's done :-)</p>

<p>Next, a bit of manual editing of the dataset cards on the Hugging Face website,
and we have our two new public datasets:</p>

<ul>
<li><a href="https://huggingface.co/datasets/gpjt/fineweb-gpt2-tokens" target="_blank" rel="noopener noreferrer"><code>gpjt/fineweb-gpt2-tokens</code></a></li>
<li><a href="https://huggingface.co/datasets/gpjt/fineweb-edu-gpt2-tokens" target="_blank" rel="noopener noreferrer"><code>gpjt/fineweb-edu-gpt2-tokens</code></a></li>
</ul>

<p>That looks solid.  So, the next thing: change our codebase so that we have some
quick and easy way to download them (I'm feeling a little wary of using Git for
that after the upload issue), and then to use the downloaded files in our training
code.</p>

<h3>Downloading the datasets from Hugging Face</h3>

<p>We already have the code to download a dataset; the stuff that I wrote to
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/aede6fbca2bf5ca518995ef39e58103e4c2dae15/download-fineweb-10b.py" target="_blank" rel="noopener noreferrer">download FineWeb and FineWeb-Edu</a>
originally.  Here's the important bit:</p>

<div>
<pre><span></span><code><span>from</span><span> </span><span>huggingface_hub</span><span> </span><span>import</span> <span>snapshot_download</span>

<span>...</span>

    <span>folder</span> <span>=</span> <span>snapshot_download</span><span>(</span>
        <span>f</span><span>"HuggingFaceFW/</span><span>{</span><span>name</span><span>}</span><span>"</span><span>,</span>
        <span>repo_type</span><span>=</span><span>"dataset"</span><span>,</span>
        <span>local_dir</span><span>=</span><span>f</span><span>"./</span><span>{</span><span>name</span><span>}</span><span>/"</span><span>,</span>
        <span>allow_patterns</span><span>=</span><span>"sample/10BT/*"</span>
    <span>)</span>
</code></pre>
</div>

<p>...so we can adapt that to download all files in an arbitrary dataset:</p>

<div>
<pre><span></span><code><span>def</span><span> </span><span>download_dataset</span><span>(</span><span>datasets_dir</span><span>,</span> <span>dataset_name</span><span>):</span>
    <span>download_path</span> <span>=</span> <span>snapshot_download</span><span>(</span>
        <span>f</span><span>"</span><span>{</span><span>dataset_name</span><span>}</span><span>"</span><span>,</span>
        <span>repo_type</span><span>=</span><span>"dataset"</span><span>,</span>
        <span>local_dir</span><span>=</span><span>datasets_dir</span> <span>/</span> <span>dataset_name</span><span>,</span>
        <span>allow_patterns</span><span>=</span><span>"*"</span>
    <span>)</span>
    <span>return</span> <span>Path</span><span>(</span><span>download_path</span><span>)</span>
</code></pre>
</div>

<p>...and call that from our <code>main</code>, using a new command-line argument <code>datasets_dir_path</code>,
and a new <code>dataset</code> element in our train config JSON file:</p>

<div>
<pre><span></span><code>    <span>datasets_dir</span> <span>=</span> <span>Path</span><span>(</span><span>datasets_dir_path</span><span>)</span>
    <span>if</span> <span>not</span> <span>datasets_dir</span><span>.</span><span>is_dir</span><span>():</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>f</span><span>"</span><span>{</span><span>datasets_dir_path</span><span>}</span><span> is not a directory"</span><span>)</span>
    <span>dataset_dir</span> <span>=</span> <span>download_dataset</span><span>(</span><span>datasets_dir</span><span>,</span> <span>train_conf</span><span>[</span><span>"dataset"</span><span>])</span>
</code></pre>
</div>

<p>I was thinking that we'd need extra guard code to not download the dataset again
if it's already there, but it looks like <code>snapshot_download</code> handles that all nicely for us.</p>

<p>So we have a way to specify which dataset we should use for a training run, and
code to download it.  Now we just need to adjust the code that loads our datasets
so that instead of looking in the <code>run_dir</code>, it looks in the directory returned
by <code>download_dataset</code>:</p>

<div>
<pre><span></span><code>    <span>train_ds</span> <span>=</span> <span>load_dataset</span><span>(</span>
        <span>dataset_dir</span><span>,</span> <span>"train"</span><span>,</span>
        <span>model_conf</span><span>[</span><span>"context_length"</span><span>],</span> <span>train_conf</span><span>[</span><span>"microbatch_size"</span><span>]</span>
    <span>)</span>
    <span>val_ds</span> <span>=</span> <span>load_dataset</span><span>(</span>
        <span>dataset_dir</span><span>,</span> <span>"validation"</span><span>,</span>
        <span>model_conf</span><span>[</span><span>"context_length"</span><span>],</span> <span>train_conf</span><span>[</span><span>"microbatch_size"</span><span>]</span>
    <span>)</span>
</code></pre>
</div>

<p>...and update the <code>load_dataset</code> directory so that if just blindly uses the
directory provided rather than trying to look in a <code>datasets</code> subdirectory:</p>

<div>
<pre><span></span><code><span>def</span><span> </span><span>load_dataset</span><span>(</span><span>dataset_dir</span><span>,</span> <span>split</span><span>,</span> <span>seq_length</span><span>,</span> <span>microbatch_size</span><span>):</span>
    <span>return</span> <span>BigTrainDataset</span><span>(</span>
        <span>load_file</span><span>(</span><span>dataset_dir</span> <span>/</span> <span>f</span><span>"</span><span>{</span><span>split</span><span>}</span><span>.safetensors"</span><span>)[</span><span>"tokens"</span><span>],</span>
        <span>seq_length</span><span>,</span> <span>microbatch_size</span><span>,</span>
    <span>)</span>
</code></pre>
</div>

<p>That all works!  We successfully download the datasets and try to use them.
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/441e3564e2dabc9e06dbc7d1783d086312a11960/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's the code</a>.</p>

<p>But now we have a problem; when the <code>BigTrainDataset</code> tries to
reshape the huge tensor that we have as our inputs:</p>

<div>
<pre><span></span><code>        <span>self</span><span>.</span><span>xs</span> <span>=</span> <span>all_tokens</span><span>[:</span><span>-</span><span>1</span><span>]</span><span>.</span><span>reshape</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>microbatch_size</span><span>,</span> <span>seq_length</span><span>)</span>
</code></pre>
</div>

<p>...it craps out:</p>

<div>
<pre><span></span><code><span>RuntimeError: shape '[-1, 6, 1024]' is invalid for input of size 10248871836</span>
</code></pre>
</div>

<p>That makes perfect sense.  Our original <code>safetensors</code> files were carefully sized
for a batch size of six, and 1024-token sequences.  We need some way to work out
an appropriate slice of both the training and the validation data.</p>

<h3>Slicing the datasets</h3>

<p>Most of the trains are likely to be Chinchilla-optimal, or at least use a Chinchilla-optimal
number of tokens -- rounded up appropriately to match our micro-batch size, sequence
length, and world size.</p>

<p>But I'd like it to be more configurable.  What I'll do is add a <code>min_train_tokens</code>
key to the training config dictionary, along with a <code>start_train_token</code> so that we
can (for example) train on the first Chinchilla-optimal tokens, then do an
extended train continuing on from there.  The idea is that we can use
<code>min_train_tokens</code> as a base, and train on the smallest number of full batches that contains
at least that many tokens.</p>

<p>For validation, I think that the <code>validation_batches</code> key that we already have is
actually quite nice.  Validation is time-bound, and the number of batches is the
easiest lever to pull to handle that. However, a <code>start_val_token</code> would be
nice for symmetry.</p>

<p>So, here are some numbers for debugging:</p>

<div>
<pre><span></span><code><span>{</span>
<span>    </span><span>"microbatch_size"</span><span>:</span><span> </span><span>6</span><span>,</span>
<span>    </span><span>"validation_interval"</span><span>:</span><span> </span><span>10</span><span>,</span>
<span>    </span><span>"dataset"</span><span>:</span><span> </span><span>"gpjt/fineweb-gpt2-tokens"</span><span>,</span>
<span>    </span><span>"min_train_tokens"</span><span>:</span><span> </span><span>3260190720</span><span>,</span>
<span>    </span><span>"start_train_token"</span><span>:</span><span> </span><span>0</span><span>,</span>
<span>    </span><span>"validation_batches"</span><span>:</span><span> </span><span>3</span><span>,</span>
<span>    </span><span>"start_val_token"</span><span>:</span><span> </span><span>0</span>
<span>}</span>
</code></pre>
</div>

<p>Now let's use them.  Initially, we have this to load the train dataset:</p>

<div>
<pre><span></span><code>    <span>train_ds</span> <span>=</span> <span>load_dataset</span><span>(</span>
        <span>dataset_dir</span><span>,</span> <span>"train"</span><span>,</span>
        <span>model_conf</span><span>[</span><span>"context_length"</span><span>],</span> <span>train_conf</span><span>[</span><span>"microbatch_size"</span><span>]</span>
    <span>)</span>
</code></pre>
</div>

<p>Let's work through that one first then make appropriate changes to the validation
one.  The pieces of information we need to work out which tokens to use are:</p>

<ul>
<li>The <code>min_train_tokens</code></li>
<li>The <code>start_train_token</code></li>
<li>The world size -- that is, how many per-GPU processes are we running?</li>
<li>The micro-batch size</li>
<li>The sequence length</li>
</ul>

<p>Let's update our <code>load_dataset</code> function so that it takes those parameters in that
order:</p>

<div>
<pre><span></span><code>    <span>train_ds</span> <span>=</span> <span>load_dataset</span><span>(</span>
        <span>dataset_dir</span><span>,</span> <span>"train"</span><span>,</span>
        <span>train_conf</span><span>[</span><span>"min_train_tokens"</span><span>],</span> <span>train_conf</span><span>[</span><span>"start_train_token"</span><span>],</span>
        <span>dist</span><span>.</span><span>get_world_size</span><span>(),</span> <span>train_conf</span><span>[</span><span>"microbatch_size"</span><span>],</span>
        <span>model_conf</span><span>[</span><span>"context_length"</span><span>]</span>
    <span>)</span>
</code></pre>
</div>

<p>...and now we can write an updated <code>load_dataset</code> that uses those numbers to get
the right number of tokens:</p>

<div>
<pre><span></span><code><span>def</span><span> </span><span>load_dataset</span><span>(</span>
    <span>dataset_dir</span><span>,</span> <span>split</span><span>,</span>
    <span>min_tokens</span><span>,</span> <span>start_token</span><span>,</span>
    <span>world_size</span><span>,</span> <span>microbatch_size</span><span>,</span>
    <span>seq_length</span>
<span>):</span>
    <span>full_dataset</span> <span>=</span> <span>load_file</span><span>(</span><span>dataset_dir</span> <span>/</span> <span>f</span><span>"</span><span>{</span><span>split</span><span>}</span><span>.safetensors"</span><span>)[</span><span>"tokens"</span><span>]</span>

    <span>one_full_batch_tokens</span> <span>=</span> <span>world_size</span> <span>*</span> <span>microbatch_size</span> <span>*</span> <span>seq_length</span>
    <span>batches_for_just_over_min</span> <span>=</span> <span>(</span><span>min_tokens</span> <span>//</span> <span>one_full_batch_tokens</span><span>)</span> <span>+</span> <span>1</span>

    <span># Note that we need one extra token for our Ys.</span>
    <span>tokens_needed</span> <span>=</span> <span>(</span><span>batches_for_just_over_min</span> <span>*</span> <span>one_full_batch_tokens</span><span>)</span> <span>+</span> <span>1</span>

    <span>if</span> <span>len</span><span>(</span><span>full_dataset</span><span>)</span> <span>&lt;</span> <span>start_token</span> <span>+</span> <span>tokens_needed</span><span>:</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>f</span><span>"Not enough tokens (wanted </span><span>{</span><span>start_token</span><span> </span><span>+</span><span> </span><span>tokens_needed</span><span>}</span><span>, got </span><span>{</span><span>len</span><span>(</span><span>full_dataset</span><span>)</span><span>}</span><span>)"</span><span>)</span>

    <span>return</span> <span>BigTrainDataset</span><span>(</span>
        <span>full_dataset</span><span>[</span><span>start_token</span><span>:</span><span>start_token</span> <span>+</span> <span>tokens_needed</span><span>],</span>
        <span>seq_length</span><span>,</span> <span>microbatch_size</span><span>,</span>
    <span>)</span>
</code></pre>
</div>

<p>Validation is less obvious; I think that the best way to do this (given that
the validation dataset is small) is just to have a "magic" <code>-1</code> value for
<code>min_tokens</code>, which means "just get a round number of full batches starting at
<code>start_val_token</code>.  It's also worth remembering that we only do evals on the
rank 0 process, so we could in theory pass in a world size of 1 -- but I think that
passing in the real world size might be a good idea, because it gives us one fewer
thing to change if, in the future, we move towards distributed evals.</p>

<p>So:</p>

<div>
<pre><span></span><code>    <span>val_ds</span> <span>=</span> <span>load_dataset</span><span>(</span>
        <span>dataset_dir</span><span>,</span> <span>"validation"</span><span>,</span>
        <span>-</span><span>1</span><span>,</span> <span>train_conf</span><span>[</span><span>"start_val_token"</span><span>],</span>
        <span>dist</span><span>.</span><span>get_world_size</span><span>(),</span> <span>train_conf</span><span>[</span><span>"microbatch_size"</span><span>],</span>
        <span>model_conf</span><span>[</span><span>"context_length"</span><span>]</span>
    <span>)</span>
</code></pre>
</div>

<p>...and we change <code>load_dataset</code> to be able to handle the magic <code>-1</code>:</p>

<div>
<pre><span></span><code><span>def</span><span> </span><span>load_dataset</span><span>(</span>
    <span>dataset_dir</span><span>,</span> <span>split</span><span>,</span>
    <span>min_tokens</span><span>,</span> <span>start_token</span><span>,</span>
    <span>world_size</span><span>,</span> <span>microbatch_size</span><span>,</span>
    <span>seq_length</span>
<span>):</span>
    <span>full_dataset</span> <span>=</span> <span>load_file</span><span>(</span><span>dataset_dir</span> <span>/</span> <span>f</span><span>"</span><span>{</span><span>split</span><span>}</span><span>.safetensors"</span><span>)[</span><span>"tokens"</span><span>]</span>
    <span>if</span> <span>start_token</span> <span>&gt;</span> <span>len</span><span>(</span><span>full_dataset</span><span>):</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>f</span><span>"start_token </span><span>{</span><span>start_token</span><span>}</span><span> is past the end of the dataset"</span><span>)</span>

    <span>one_full_batch_tokens</span> <span>=</span> <span>world_size</span> <span>*</span> <span>microbatch_size</span> <span>*</span> <span>seq_length</span>

    <span>if</span> <span>min_tokens</span> <span>==</span> <span>-</span><span>1</span><span>:</span>
        <span>available_tokens</span> <span>=</span> <span>len</span><span>(</span><span>full_dataset</span><span>)</span> <span>-</span> <span>start_token</span>
        <span>available_batches</span> <span>=</span> <span>(</span><span>available_tokens</span> <span>//</span> <span>one_full_batch_tokens</span><span>)</span>
        <span>tokens_needed</span> <span>=</span> <span>available_batches</span> <span>*</span> <span>one_full_batch_tokens</span>
    <span>else</span><span>:</span>
        <span>batches_for_just_over_min</span> <span>=</span> <span>(</span><span>min_tokens</span> <span>//</span> <span>one_full_batch_tokens</span><span>)</span> <span>+</span> <span>1</span>
        <span>tokens_needed</span> <span>=</span> <span>batches_for_just_over_min</span> <span>*</span> <span>one_full_batch_tokens</span>

    <span># Note that we need one extra token for our Ys.</span>
    <span>tokens_needed</span> <span>+=</span> <span>1</span>

    <span>if</span> <span>len</span><span>(</span><span>full_dataset</span><span>)</span> <span>&lt;</span> <span>start_token</span> <span>+</span> <span>tokens_needed</span><span>:</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>f</span><span>"Not enough tokens (wanted </span><span>{</span><span>start_token</span><span> </span><span>+</span><span> </span><span>tokens_needed</span><span>}</span><span>, got </span><span>{</span><span>len</span><span>(</span><span>full_dataset</span><span>)</span><span>}</span><span>)"</span><span>)</span>

    <span>return</span> <span>BigTrainDataset</span><span>(</span>
        <span>full_dataset</span><span>[</span><span>start_token</span><span>:</span><span>start_token</span> <span>+</span> <span>tokens_needed</span><span>],</span>
        <span>seq_length</span><span>,</span> <span>microbatch_size</span><span>,</span>
    <span>)</span>
</code></pre>
</div>

<p>I also added in a quick sanity check to make sure that we don't get weird behaviour
if the <code>start_token</code> is past the end of the original dataset.</p>

<p>That all looks good!  Running it kicks off training, and validation is running
happily every ten global steps, but just with three samples, as configured in the
JSON file.  <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/36e475bcae5ef36757ddd3cff4da8692d2434213/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's the code</a>.</p>

<h3>QoL features</h3>

<p>One thing that hasn't shown up while running this code locally is that our training loop
has this:</p>

<div>
<pre><span></span><code>    <span>for</span> <span>global_step</span> <span>in</span> <span>tqdm</span><span>(</span><span>range</span><span>(</span><span>start_global_step</span><span>,</span> <span>total_global_steps</span><span>)):</span>
</code></pre>
</div>

<p>With one GPU, that's fine, but on a multi-GPU machine, that <code>tqdm</code> is going to happen in all of our per-GPU processes
-- so they'll all be spamming out progress bars, which will be ugly.  So, as a first cut:</p>

<div>
<pre><span></span><code>    <span>for</span> <span>global_step</span> <span>in</span> <span>tqdm</span><span>(</span><span>range</span><span>(</span><span>start_global_step</span><span>,</span> <span>total_global_steps</span><span>),</span> <span>disable</span><span>=</span><span>(</span><span>rank</span> <span>!=</span> <span>0</span><span>)):</span>
</code></pre>
</div>

<p>Now, in order to compare different machines (say, an 8x H100 vs an 8x A100) it would
be nice to get tokens-per-second numbers while training.  We can do that in the <code>tqdm</code>
progress bar too!   It has a <code>set_postfix</code> method that adds stuff to the end of the
bar, just after the elapsed time and iterations/second numbers.  For that, we'll need
to have the <code>tqdm</code> object available in a variable:</p>

<div>
<pre><span></span><code>    <span>progress_bar</span> <span>=</span> <span>tqdm</span><span>(</span>
        <span>range</span><span>(</span><span>start_global_step</span><span>,</span> <span>total_global_steps</span><span>),</span>
        <span>disable</span><span>=</span><span>(</span><span>rank</span> <span>!=</span> <span>0</span><span>)</span>
    <span>)</span>
    <span>for</span> <span>global_step</span> <span>in</span> <span>progress_bar</span><span>:</span>
</code></pre>
</div>

<p>...and now we can count the total tokens seen in the training run, plus keep track
of the start time -- just before the start of the training loop:</p>

<div>
<pre><span></span><code>    <span>start_time</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span>
    <span>tokens_seen_this_rank</span> <span>=</span> <span>0</span>
</code></pre>
</div>

<p>...then inside, after the training step:</p>

<div>
<pre><span></span><code>        <span>microbatch_size</span><span>,</span> <span>sequence_length</span> <span>=</span> <span>inputs</span><span>.</span><span>shape</span>
        <span>tokens_seen_this_rank</span> <span>+=</span> <span>microbatch_size</span> <span>*</span> <span>sequence_length</span>

        <span>if</span> <span>rank</span> <span>==</span> <span>0</span><span>:</span>
            <span>elapsed_time</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span> <span>-</span> <span>start_time</span>
            <span>tokens_per_sec</span> <span>=</span> <span>(</span><span>tokens_seen_this_rank</span> <span>*</span> <span>world_size</span><span>)</span> <span>/</span> <span>elapsed_time</span>
            <span>progress_bar</span><span>.</span><span>set_postfix</span><span>(</span>
                <span>loss</span><span>=</span><span>f</span><span>"</span><span>{</span><span>train_loss</span><span>.</span><span>item</span><span>()</span><span>:</span><span>.3f</span><span>}</span><span>"</span><span>,</span>
                <span>tps</span><span>=</span><span>f</span><span>"</span><span>{</span><span>tokens_per_sec</span><span>:</span><span>,.0f</span><span>}</span><span>"</span>
            <span>)</span>
</code></pre>
</div>

<p>That will give us a running average of tokens per second over the train as a whole since
the start.</p>

<p>Running that, we get a nice progress bar like this (you'll need to scroll to the right):</p>

<div>
<pre><span></span><code><span>  0%|                                                                                                      | 10/530631 [00:04&lt;47:31:23,  3.10it/s, loss=8.094, tps=14,362]</span>
</code></pre>
</div>

<p>Note that the tokens per second is worse than the just less than 20k that we got when running
the single-GPU test previously,
but that's due to the testing setup I have -- I'm doing an eval every 10 global steps.
Changing that to 1,000,000 so that we just get a single eval when we start, then
letting it run for a while to settle down from the initial eval, we get this:</p>

<div>
<pre><span></span><code><span>  0%|                                                                                                     | 631/530631 [03:17&lt;46:02:23,  3.20it/s, loss=6.890, tps=19,678]</span>
</code></pre>
</div>

<p>...which is close enough to what we had before.</p>

<p>Finally, let's print out some summary information at the end:</p>

<div>
<pre><span></span><code>    <span>end_time</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span>
    <span>elapsed_time</span> <span>=</span> <span>end_time</span> <span>-</span> <span>start_time</span>

    <span>if</span> <span>rank</span> <span>==</span> <span>0</span><span>:</span>
        <span>print</span><span>(</span><span>f</span><span>"</span><span>\n\n\n</span><span>Training complete in </span><span>{</span><span>elapsed_time</span><span>:</span><span>,.3f</span><span>}</span><span> seconds"</span><span>)</span>
        <span>total_tokens_seen</span> <span>=</span> <span>tokens_seen_this_rank</span> <span>*</span> <span>world_size</span>
        <span>print</span><span>(</span><span>f</span><span>"Tokens seen: </span><span>{</span><span>total_tokens_seen</span><span>:</span><span>,.0f</span><span>}</span><span>"</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>"Throughput: </span><span>{</span><span>total_tokens_seen</span><span> </span><span>/</span><span> </span><span>elapsed_time</span><span>:</span><span>,.0f</span><span>}</span><span> tokens/second"</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>"Final train loss: </span><span>{</span><span>avg_train_loss</span><span>:</span><span>.3f</span><span>}</span><span>"</span><span>)</span>
        <span>print</span><span>(</span><span>f</span><span>"Final val loss: </span><span>{</span><span>val_loss</span><span>:</span><span>.3f</span><span>}</span><span>"</span><span>)</span>
</code></pre>
</div>

<p>Ran that on a super-short train with about 50 iterations-worth of tokens, and:</p>

<div>
<pre><span></span><code><span>Training complete in 26.520 seconds</span>
<span>Tokens seen: 331,776</span>
<span>Throughput: 12,510 tokens/second</span>
<span>Final train loss: 7.817</span>
<span>Final val loss: 8.093</span>
</code></pre>
</div>

<p>Looking good.  <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/d6c0baaf7081828614beda68d47620084d99b805/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's the code</a>.</p>

<p>I think we now have something where it's worth spinning up a Lambda Labs
machine to run it.</p>

<h3>A first run on Lambda Labs</h3>

<p>Let's kick off a training run on the cheapest two-GPU machine that they have
available right now.  That's actually not all that cheap, it's a $6.38/hour
2x H100 80 GiB SXM5.  But I'm not planning to do a full train on it yet, this
is just a sanity test.</p>

<p>I won't attach a filesystem this time, either -- let's see how things go without
the caching of the datasets that I was considering.</p>

<p>First thing: do we have <code>uv</code>?</p>

<div>
<pre><span></span><code>ubuntu@192-222-53-181:~$<span> </span>uv
uv:<span> </span><span>command</span><span> </span>not<span> </span>found
</code></pre>
</div>

<p>Nope.  OK, let's install it:</p>

<div>
<pre><span></span><code>ubuntu@192-222-53-181:~$<span> </span>curl<span> </span>-LsSf<span> </span>https://astral.sh/uv/install.sh<span> </span><span>|</span><span> </span>sh
downloading<span> </span>uv<span> </span><span>0</span>.9.15<span> </span>x86_64-unknown-linux-gnu
no<span> </span>checksums<span> </span>to<span> </span>verify
installing<span> </span>to<span> </span>/home/ubuntu/.local/bin
<span>  </span>uv
<span>  </span>uvx
everything<span>'</span>s<span> </span>installed!
</code></pre>
</div>

<p>Right, now let's clone our repo and set up our environment:</p>

<div>
<pre><span></span><code>ubuntu@192-222-53-181:~$<span> </span>git<span> </span>clone<span> </span>https://github.com/gpjt/ddp-base-model-from-scratch.git
Cloning<span> </span>into<span> </span><span>'ddp-base-model-from-scratch'</span>...
remote:<span> </span>Enumerating<span> </span>objects:<span> </span><span>123</span>,<span> </span><span>done</span>.
remote:<span> </span>Counting<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>123</span>/123<span>)</span>,<span> </span><span>done</span>.
remote:<span> </span>Compressing<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>82</span>/82<span>)</span>,<span> </span><span>done</span>.
remote:<span> </span>Total<span> </span><span>123</span><span> </span><span>(</span>delta<span> </span><span>66</span><span>)</span>,<span> </span>reused<span> </span><span>88</span><span> </span><span>(</span>delta<span> </span><span>34</span><span>)</span>,<span> </span>pack-reused<span> </span><span>0</span><span> </span><span>(</span>from<span> </span><span>0</span><span>)</span>
Receiving<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>123</span>/123<span>)</span>,<span> </span><span>124</span>.76<span> </span>KiB<span> </span><span>|</span><span> </span><span>3</span>.46<span> </span>MiB/s,<span> </span><span>done</span>.
Resolving<span> </span>deltas:<span> </span><span>100</span>%<span> </span><span>(</span><span>66</span>/66<span>)</span>,<span> </span><span>done</span>.
ubuntu@192-222-53-181:~$<span> </span><span>cd</span><span> </span>ddp-base-model-from-scratch/
ubuntu@192-222-53-181:~/ddp-base-model-from-scratch$<span> </span>uv<span> </span>sync
Using<span> </span>CPython<span> </span><span>3</span>.13.10
Creating<span> </span>virtual<span> </span>environment<span> </span>at:<span> </span>.venv
Resolved<span> </span><span>90</span><span> </span>packages<span> </span><span>in</span><span> </span><span>0</span>.58ms
Prepared<span> </span><span>88</span><span> </span>packages<span> </span><span>in</span><span> </span><span>34</span>.05s
Installed<span> </span><span>88</span><span> </span>packages<span> </span><span>in</span><span> </span>133ms
...
</code></pre>
</div>

<p>And now I think we can just try running it!</p>

<div>
<pre><span></span><code>ubuntu@192-222-53-181:~/ddp-base-model-from-scratch$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>ddp_train.py<span> </span>original<span> </span>datasets
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:18&lt;<span>00</span>:00,<span>  </span><span>4</span>.51s/it<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>20</span>.7GB<span> </span><span>[</span><span>00</span>:18,<span> </span>724MB/s<span>]</span><span>                                                                                                                              </span>Starting<span> </span>rank<span> </span><span>0</span><span> </span>training<span> </span>at<span> </span>global<span> </span>step<span> </span><span>0</span>

<span>  </span><span>0</span>%<span>|</span><span>                                                                                                                 </span><span>|</span><span> </span><span>0</span>/530631<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s,<span> </span><span>loss</span><span>=</span><span>10</span>.972,<span> </span><span>tps</span><span>=</span><span>12</span>,439<span>]</span>

Validation/checkpoint
<span>100</span>%<span>|</span>███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>2</span>/2<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>33</span>.12it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>20</span>.7GB<span> </span><span>[</span><span>00</span>:19,<span> </span><span>1</span>.06GB/s<span>]</span>
findfont:<span> </span>Font<span> </span>family<span> </span><span>'xkcd'</span><span> </span>not<span> </span>found.<span>                                                                                                             </span><span>|</span><span> </span><span>0</span>/2<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
findfont:<span> </span>Font<span> </span>family<span> </span><span>'xkcd'</span><span> </span>not<span> </span>found.
findfont:<span> </span>Font<span> </span>family<span> </span><span>'xkcd'</span><span> </span>not<span> </span>found.
</code></pre>
</div>

<p>It took 18 seconds to download the dataset!  I don't think we need to worry about
the caching thing with persistent disks, at least at this point.</p>

<p>But there are a couple of issues here.  I didn't put the number of processes in the command line
-- I should be using</p>

<div>
<pre><span></span><code><span>uv run torchrun --nproc_per_node=2 ddp_train.py original datasets</span>
</code></pre>
</div>

<p>Also, we don't have the XKCD font family.  I'll ignore that for now.</p>

<div>
<pre><span></span><code>ubuntu@192-222-53-181:~/ddp-base-model-from-scratch$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>--nproc_per_node<span>=</span><span>2</span><span> </span>ddp_train.py<span> </span>original<span> </span>datasets
W1205<span> </span><span>20</span>:16:58.548000<span> </span><span>6491</span><span> </span>torch/distributed/run.py:803<span>]</span>
W1205<span> </span><span>20</span>:16:58.548000<span> </span><span>6491</span><span> </span>torch/distributed/run.py:803<span>]</span><span> </span>*****************************************
W1205<span> </span><span>20</span>:16:58.548000<span> </span><span>6491</span><span> </span>torch/distributed/run.py:803<span>]</span><span> </span>Setting<span> </span>OMP_NUM_THREADS<span> </span>environment<span> </span>variable<span> </span><span>for</span><span> </span>each<span> </span>process<span> </span>to<span> </span>be<span> </span><span>1</span><span> </span><span>in</span><span> </span>default,<span> </span>to<span> </span>avoid<span> </span>your<span> </span>system<span> </span>being<span> </span>overloaded,<span> </span>please<span> </span>further<span> </span>tune<span> </span>the<span> </span>variable<span> </span><span>for</span><span> </span>optimal<span> </span>performance<span> </span><span>in</span><span> </span>your<span> </span>application<span> </span>as<span> </span>needed.
W1205<span> </span><span>20</span>:16:58.548000<span> </span><span>6491</span><span> </span>torch/distributed/run.py:803<span>]</span><span> </span>*****************************************
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>███████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>8260</span>.57it/s<span>]</span>
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>██████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>19418</span>.07it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>              </span>Starting<span> </span>rank<span> </span><span>0</span><span> </span>training<span> </span>at<span> </span>global<span> </span>step<span> </span><span>0</span><span>                                                     </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
Starting<span> </span>rank<span> </span><span>1</span><span> </span>training<span> </span>at<span> </span>global<span> </span>step<span> </span><span>0</span>

<span>  </span><span>0</span>%<span>|</span><span>                                                                                                                 </span><span>|</span><span> </span><span>0</span>/265316<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s,<span> </span><span>loss</span><span>=</span><span>10</span>.982,<span> </span><span>tps</span><span>=</span><span>26</span>,590<span>]</span>

Validation/checkpoint
<span>100</span>%<span>|</span>███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>2</span>/2<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>33</span>.23it/s<span>]</span>
findfont:<span> </span>Font<span> </span>family<span> </span><span>'xkcd'</span><span> </span>not<span> </span>found.
...

Continuing<span> </span>training

<span>  </span><span>0</span>%<span>|</span><span>                                                                                                      </span><span>|</span><span> </span><span>10</span>/265316<span> </span><span>[</span><span>00</span>:03&lt;<span>13</span>:29:38,<span>  </span><span>5</span>.46it/s,<span> </span><span>loss</span><span>=</span><span>8</span>.391,<span> </span><span>tps</span><span>=</span><span>35</span>,279<span>]</span>
</code></pre>
</div>

<p>OK, that's looking good!  Let's make our validations happen less often, and see
how high we can get the micro-batches with the 80 GiB VRAM we have on each of our
two GPUs.</p>

<p>Doing a binary chop, I set the micro-batch size to 100 (OOM), then to 50 (OOM),
then to 25 (worked), then to 37 (OOM), then 31 (OOM), then 28 (worked), and finally
29 (OOM).</p>

<p>So we have a batch size of 28 for our 80 GiB machines.  Leaving it for a little
while to settle down, and we get to about 142,000 tokens/second.</p>

<p>Now, on the 3090, we were training at 20,000 tokens/second.  That means that this
machine is running at about 7 times the speed.  Given that our original train finished in
48 hours, we'd expect the train to finish in about 6, which indeed is the estimated time on
the tqdm progress bar.</p>

<p>At $6.38 per hour, that comes
to $38.28.  Not bad!  And this instance is actually
quite pricey on a per-GPU basis -- it's $3.19 per GPU/hour, whereas there is an 8x H100
that costs $2.99 per GPU/hour.</p>

<p>I'm almost tempted to let it run.  But the purpose of this run was to work out the
bugs.</p>

<p>We're going to want to track the training chart -- remember that after every validation
run, our training code generates a chart showing the training and validation loss
so far, <a href="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/big-training-run-chart-fineweb.png" target="_blank" rel="noopener noreferrer">like this one</a>.
I ran the normal quick-and-dirty
Python webserver command on the instance, inside the directory containing the
training chart:</p>

<div>
<pre><span></span><code>ubuntu@192-222-53-181:~/ddp-base-model-from-scratch/runs/original$<span> </span>python<span> </span>-m<span> </span>http.server<span> </span><span>8000</span>
</code></pre>
</div>

<p>My browser didn't connect to it, but looking at the Lambda Labs interface, there's a
new "Firewall" section, where you configure rules for allowing incoming connections
to your instances.  That's sensible, and the default rules are just "allow SSH from
any IP" and "allow ping from any IP".  Adding one letting anyone access port 8000
fixed the problem, and I saw a directory listing; clicking on the chart showed exactly
what I'd expect, but without the XKCD fonts.  Nice.</p>

<p>Let's work out how to fix that XKCD font thing.  Looking around, it seems like there
are approximately twenty thousand ways to do it.  Here's one that seems to work;
firstly, install the font on the system:</p>

<div>
<pre><span></span><code>mkdir<span> </span>-p<span> </span>~/.local/share/fonts
curl<span> </span>-sL<span> </span>https://github.com/ipython/xkcd-font/raw/master/xkcd-script/font/xkcd-script.ttf<span> </span>-o<span> </span>~/.local/share/fonts/xkcd-script.ttf
fc-cache<span> </span>-f<span> </span>-v
</code></pre>
</div>

<p>Now, that installs a font that has the family name 'xkcd Script` (with that erratic
capitalisation).  So we need to change the code to pick up pretty much anything that
looks like it's XKCD, so instead of this:</p>

<div>
<pre><span></span><code><span>plt</span><span>.</span><span>rcParams</span><span>[</span><span>'font.family'</span><span>]</span> <span>=</span> <span>"xkcd"</span>
</code></pre>
</div>

<p>...we can do this:</p>

<div>
<pre><span></span><code><span>from</span><span> </span><span>matplotlib</span><span> </span><span>import</span> <span>font_manager</span>

<span>...</span>

    <span>font_family</span> <span>=</span> <span>None</span>
    <span>for</span> <span>f</span> <span>in</span> <span>font_manager</span><span>.</span><span>fontManager</span><span>.</span><span>ttflist</span><span>:</span>
        <span>if</span> <span>"xkcd"</span> <span>in</span> <span>f</span><span>.</span><span>name</span><span>.</span><span>lower</span><span>():</span>
            <span>font_family</span> <span>=</span> <span>f</span><span>.</span><span>name</span>
            <span>break</span>

    <span>if</span> <span>font_family</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>plt</span><span>.</span><span>rcParams</span><span>[</span><span>'font.family'</span><span>]</span> <span>=</span> <span>font_family</span>
</code></pre>
</div>

<p>That seems to work OK.</p>

<p>So, now, I think we have the beginnings of a script to set up a Lambda Labs
machine so that we can use it.  Let's write a
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/30a3fd75f1eab96cd598a6c0a0f14465ddee6ae4/setup_lambda.sh" target="_blank" rel="noopener noreferrer"><code>setup_lambda.sh</code></a>
with this:</p>

<div>
<pre><span></span><code><span>#!/bin/bash</span>
<span>set</span><span> </span>-a
curl<span> </span>-LsSf<span> </span>https://astral.sh/uv/install.sh<span> </span><span>|</span><span> </span>sh
mkdir<span> </span>-p<span> </span>~/.local/share/fonts
curl<span> </span>-sL<span> </span>https://github.com/ipython/xkcd-font/raw/master/xkcd-script/font/xkcd-script.ttf<span> </span>-o<span> </span>~/.local/share/fonts/xkcd-script.ttf
fc-cache<span> </span>-f<span> </span>-v
</code></pre>
</div>

<p>...and give it another go on a fresh machine.  Shut this one down -- total cost
so far $7.28.</p>

<h3>A second run on Lambda Labs, as a sanity check</h3>

<p>Now there are no 2-GPU instances available.  There is a super-cheap 1x A10 (basically
the datacenter version of a 3090), though, so let's use that -- we're as certain as
we can be that the multi-GPU stuff works, and the proof of the pudding will
be whether we can train a model that works.</p>

<p>After spinning up our 1x A10 machine:</p>

<div>
<pre><span></span><code>ubuntu@150-136-154-247:~$<span> </span>git<span> </span>clone<span> </span>https://github.com/gpjt/ddp-base-model-from-scratch.git
Cloning<span> </span>into<span> </span><span>'ddp-base-model-from-scratch'</span>...
remote:<span> </span>Enumerating<span> </span>objects:<span> </span><span>134</span>,<span> </span><span>done</span>.
remote:<span> </span>Counting<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>134</span>/134<span>)</span>,<span> </span><span>done</span>.
remote:<span> </span>Compressing<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>89</span>/89<span>)</span>,<span> </span><span>done</span>.
remote:<span> </span>Total<span> </span><span>134</span><span> </span><span>(</span>delta<span> </span><span>70</span><span>)</span>,<span> </span>reused<span> </span><span>98</span><span> </span><span>(</span>delta<span> </span><span>37</span><span>)</span>,<span> </span>pack-reused<span> </span><span>0</span><span> </span><span>(</span>from<span> </span><span>0</span><span>)</span>
Receiving<span> </span>objects:<span> </span><span>100</span>%<span> </span><span>(</span><span>134</span>/134<span>)</span>,<span> </span><span>127</span>.03<span> </span>KiB<span> </span><span>|</span><span> </span><span>31</span>.76<span> </span>MiB/s,<span> </span><span>done</span>.
Resolving<span> </span>deltas:<span> </span><span>100</span>%<span> </span><span>(</span><span>70</span>/70<span>)</span>,<span> </span><span>done</span>.
ubuntu@150-136-154-247:~$<span> </span><span>cd</span><span> </span>ddp-base-model-from-scratch
ubuntu@150-136-154-247:~/ddp-base-model-from-scratch$<span> </span>./setup_lambda.sh
downloading<span> </span>uv<span> </span><span>0</span>.9.15<span> </span>x86_64-unknown-linux-gnu
no<span> </span>checksums<span> </span>to<span> </span>verify
installing<span> </span>to<span> </span>/home/ubuntu/.local/bin
<span>  </span>uv
<span>  </span>uvx
everything<span>'</span>s<span> </span>installed!
/usr/share/fonts:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>0</span><span> </span>fonts,<span> </span><span>2</span><span> </span><span>dirs</span>
/usr/share/fonts/opentype:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>0</span><span> </span>fonts,<span> </span><span>1</span><span> </span><span>dirs</span>
/usr/share/fonts/opentype/font-awesome:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>1</span><span> </span>fonts,<span> </span><span>0</span><span> </span><span>dirs</span>
/usr/share/fonts/truetype:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>0</span><span> </span>fonts,<span> </span><span>4</span><span> </span><span>dirs</span>
/usr/share/fonts/truetype/dejavu:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>6</span><span> </span>fonts,<span> </span><span>0</span><span> </span><span>dirs</span>
/usr/share/fonts/truetype/font-awesome:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>1</span><span> </span>fonts,<span> </span><span>0</span><span> </span><span>dirs</span>
/usr/share/fonts/truetype/lato:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>18</span><span> </span>fonts,<span> </span><span>0</span><span> </span><span>dirs</span>
/usr/share/fonts/truetype/lyx:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>12</span><span> </span>fonts,<span> </span><span>0</span><span> </span><span>dirs</span>
/usr/local/share/fonts:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>0</span><span> </span>fonts,<span> </span><span>0</span><span> </span><span>dirs</span>
/home/ubuntu/.local/share/fonts:<span> </span>caching,<span> </span>new<span> </span>cache<span> </span>contents:<span> </span><span>1</span><span> </span>fonts,<span> </span><span>0</span><span> </span><span>dirs</span>
/home/ubuntu/.fonts:<span> </span>skipping,<span> </span>no<span> </span>such<span> </span>directory
/usr/share/fonts/opentype:<span> </span>skipping,<span> </span>looped<span> </span>directory<span> </span>detected
/usr/share/fonts/truetype:<span> </span>skipping,<span> </span>looped<span> </span>directory<span> </span>detected
/usr/share/fonts/opentype/font-awesome:<span> </span>skipping,<span> </span>looped<span> </span>directory<span> </span>detected
/usr/share/fonts/truetype/dejavu:<span> </span>skipping,<span> </span>looped<span> </span>directory<span> </span>detected
/usr/share/fonts/truetype/font-awesome:<span> </span>skipping,<span> </span>looped<span> </span>directory<span> </span>detected
/usr/share/fonts/truetype/lato:<span> </span>skipping,<span> </span>looped<span> </span>directory<span> </span>detected
/usr/share/fonts/truetype/lyx:<span> </span>skipping,<span> </span>looped<span> </span>directory<span> </span>detected
/var/cache/fontconfig:<span> </span>not<span> </span>cleaning<span> </span>unwritable<span> </span>cache<span> </span>directory
/home/ubuntu/.cache/fontconfig:<span> </span>cleaning<span> </span>cache<span> </span>directory
/home/ubuntu/.fontconfig:<span> </span>not<span> </span>cleaning<span> </span>non-existent<span> </span>cache<span> </span>directory
fc-cache:<span> </span>succeeded
ubuntu@150-136-154-247:~/ddp-base-model-from-scratch$<span> </span>mkdir<span> </span>datasets
ubuntu@150-136-154-247:~/ddp-base-model-from-scratch$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>--nproc_per_node<span>=</span><span>1</span><span> </span>ddp_train.py<span> </span>original<span> </span>datasets
Using<span> </span>CPython<span> </span><span>3</span>.13.10
Creating<span> </span>virtual<span> </span>environment<span> </span>at:<span> </span>.venv
Installed<span> </span><span>88</span><span> </span>packages<span> </span><span>in</span><span> </span><span>1</span>.30s
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:14&lt;<span>00</span>:00,<span>  </span><span>3</span>.60s/it<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>20</span>.7GB<span> </span><span>[</span><span>00</span>:14,<span> </span><span>1</span>.20GB/s<span>]</span><span>                                                                                                                             </span>Starting<span> </span>rank<span> </span><span>0</span><span> </span>training<span> </span>at<span> </span>global<span> </span>step<span> </span><span>0</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>20</span>.7GB<span> </span><span>[</span><span>00</span>:15,<span> </span><span>1</span>.36GB/s<span>]</span>
<span>  </span><span>0</span>%<span>|</span><span>                                                                                                                                          </span><span>|</span><span> </span><span>0</span>/530631<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>  </span><span>0</span>%<span>|</span><span>                                                                                                                  </span><span>|</span><span> </span><span>0</span>/530631<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s,<span> </span><span>loss</span><span>=</span><span>10</span>.981,<span> </span><span>tps</span><span>=</span><span>6</span>,533<span>]</span>

Validation/checkpoint
<span>100</span>%<span>|</span>███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>2</span>/2<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span>  </span><span>7</span>.27it/s<span>]</span>
</code></pre>
</div>

<p>Looking good!  I think we have something that (in theory) should work.  That cost $0.05.</p>

<p>I think it's time to do our first train on a big instance.</p>

<h3>First train on a big instance: 8x A100, 40 GiB/GPU, SXM4</h3>

<p>There are four 8x instances available on Lambda Labs for me right now:</p>

<ul>
<li>An 8x B200, with 160 GiB per GPU, at $39.92/hour</li>
<li>An 8x H100, with 80 GiB per GPU, at $23.92/hour</li>
<li>An 8x A100, with 80 GiB per GPU, at $14.32/hour</li>
<li>An 8x A100, with 40 GiB per GPU, at $10.32/hour</li>
</ul>

<p>I think I'm going to want to train on all of those, to try to work out some kind
of metric (dollars per megatoken?) to compare them.  But let's start with something reasonably
low-end -- in fact, let's try the cheapest, and see what happens.</p>

<p>Spin one up, and first thing; after the setup, we need to work out the micro-batch size.  Last time we used
28, but this machine has GPUs with half as much VRAM.  I did a binary chop again... it turns out
to be 13.</p>

<p>Now let's think about validation frequency.  Let's try to get a feel for how long it will take.
We can set the eval batches to (say) 100, so that we can see how fast evals are,
but also set the interval to 10,000,000 so that it never does one after the first.</p>

<p>It took 11 seconds to run 100 validation batches, and after a few minutes, it
settles down at 254,000 tokens/second or so, and is estimating 3h15m to completion.
Nice!  The cards are an earlier generation to the H100s we used in the two-GPU test,
so they're slower, and they have half the VRAM.  So eight of them are, working together,
about twice as fast as two H100s.  Doesn't sound completely crazy.</p>

<p>So, in our local train, we spent 5 minutes evaluating every 30 minutes.  So our eval
time was 16% of our train time.  Probably a bit high, but let's run with it.</p>

<p>If we're going to take 3 hours training time, then 16% of that is about 28 minutes.
Previously we did about 88 evals (44 hours train time, with an eval after each
half hour).  That seems a bit too high.  So let's say that we want to do 50 evals.</p>

<p>28 minutes eval time in total, with 50 of them, means about 30 seconds per eval.  If
100 eval batches take 11 seconds, let's approximate it to 300 eval batches.</p>

<p>As to the interval between them -- if we want to do 50 over 3h15m, or 195 minutes,
then that's one every (let's approximate) 4 minutes.
We seem to have settled down to 2.57 iterations per second, so that's about every
617 iterations.</p>

<p>Let's bake those in and let it rip.</p>

<div>
<pre><span></span><code>ubuntu@129-213-131-52:~/ddp-base-model-from-scratch$<span> </span>cat<span> </span>runs/8xa100m40/train.json
<span>{</span>
<span>    </span><span>"microbatch_size"</span>:<span> </span><span>13</span>,
<span>    </span><span>"validation_interval"</span>:<span> </span><span>617</span>,
<span>    </span><span>"dataset"</span>:<span> </span><span>"gpjt/fineweb-gpt2-tokens"</span>,
<span>    </span><span>"min_train_tokens"</span>:<span> </span><span>3260190720</span>,
<span>    </span><span>"start_train_token"</span>:<span> </span><span>0</span>,
<span>    </span><span>"validation_batches"</span>:<span> </span><span>300</span>,
<span>    </span><span>"start_val_token"</span>:<span> </span><span>0</span>
<span>}</span>
</code></pre>
</div>

<p>After the run:</p>

<div>
<pre><span></span><code><span>Training complete in 13,904.270 seconds</span>
<span>Tokens seen: 3,260,268,544</span>
<span>Throughput: 234,480 tokens/second</span>
<span>Final train loss: 3.720</span>
<span>Final val loss: 3.675</span>
</code></pre>
</div>

<p>OK, let's download everything.</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch/first-cloud-train<span> </span><span>(</span>main<span>)</span>$<span> </span>scp<span> </span>ubuntu@129.213.131.52:/home/ubuntu/ddp-base-model-from-scratch/runs/8xa100m40/big-training-run-chart.png<span> </span>.
big-training-run-chart.png
</code></pre>
</div>

<p>Looking at the checkpoints, the latest (that is, the last one at the end of the training)
and best (the checkpoint that had the lowest validation loss) are the same one, meaning
that validation loss kept falling consistently:</p>

<div>
<pre><span></span><code><span>drwxrwxr-x 2 ubuntu ubuntu 4096 Dec  6 01:49 20251206Z014912-iteration-29616</span>
<span>drwxrwxr-x 2 ubuntu ubuntu 4096 Dec  6 01:53 20251206Z015351-iteration-30233</span>
<span>lrwxrwxrwx 1 ubuntu ubuntu   31 Dec  6 01:57 latest -&gt; 20251206Z015658-iteration-30613</span>
<span>lrwxrwxrwx 1 ubuntu ubuntu   31 Dec  6 01:57 best -&gt; 20251206Z015658-iteration-30613</span>
<span>drwxrwxr-x 2 ubuntu ubuntu 4096 Dec  6 01:57 20251206Z015658-iteration-30613</span>
</code></pre>
</div>

<p>So let's just download using the "best" symlink to get the weights for that checkpoint:</p>

<div>
<pre><span></span><code><span>giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xa100m40 (main)$ </span>scp<span> </span>-r<span> </span>ubuntu@129.213.131.52:/home/ubuntu/ddp-base-model-from-scratch/runs/8xa100m40/big-training-run-chart.png<span> </span>.
<span>giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xa100m40 (main)$ </span>mkdir<span> </span>checkpoints<span>;</span><span> </span><span>cd</span><span> </span>checkpoints
<span>giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xa100m40/checkpoints (main)$ </span>scp<span> </span>-r<span> </span>ubuntu@129.213.131.52:/home/ubuntu/ddp-base-model-from-scratch/runs/8xa100m40/checkpoints/best/<span> </span>.
<span>scaler.pt                                                                                                                               100% 1383     6.8KB/s   00:00</span>
<span>optimizer.pt                                                                                                                            100% 1244MB   7.7MB/s   02:41</span>
<span>model.safetensors                                                                                                                       100%  670MB   7.4MB/s   01:29</span>
<span>meta.json                                                                                                                               100%  104     0.5KB/s   00:00</span>
<span>giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xa100m40/checkpoints (main)$ </span>ls<span> </span>-lrt
<span>total 84</span>
<span>drwxr-xr-x 2 giles giles  4096 Dec  6 02:05 best</span>
<span>giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xa100m40/checkpoints (main)$ </span>ls<span> </span>best
<span>meta.json  model.safetensors  optimizer.pt  scaler.pt</span>
<span>giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xa100m40/checkpoints (main)$ </span>ls<span> </span>-h<span> </span>best
<span>meta.json  model.safetensors  optimizer.pt  scaler.pt</span>
<span>giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xa100m40/checkpoints (main)$ </span>ls<span> </span>-lh<span> </span>best
<span>total 1.9G</span>
<span>-rw-r--r-- 1 giles giles  104 Dec  6 02:05 meta.json</span>
<span>-rw-r--r-- 1 giles giles 670M Dec  6 02:05 model.safetensors</span>
<span>-rw-r--r-- 1 giles giles 1.3G Dec  6 02:04 optimizer.pt</span>
<span>-rw-r--r-- 1 giles giles 1.4K Dec  6 02:01 scaler.pt</span>
</code></pre>
</div>

<p>And now we can shut the cloud machine down.</p>

<p>Now that the clock is no longer ticking and we aren't spending money on an unused
machine, here's the training chart:</p>

<p><img src="/post-assets/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud/training-run-8xa100m40.png" alt="Training run on an 8x A100 with 40 GiB/GPU" title="Training run on an 8x A100 with 40 GiB/GPU" /></p>

<p>It looks like we had a couple of gradient spikes there.  I'm going to add some gradient
clipping code at some point, but I think I'll hold off for a little bit -- I want
to do a few cloud trains first to work out the best instance sizes to use, and only
then start exploring the possibilities for making the models better.</p>

<p>Apart from that, it looks pretty normal.</p>

<p>Looking at the billing page on Lambda Labs, that machine was up for about 4 hours and 35 minutes, costing US$10.32 per hour,
for a total cost of US$47.35.</p>

<p>Of that 4h35m, 13,904 seconds, or 3h52 was the actual training run -- somewhat more
than the 3h15m that was predicted at the start of the run.  The validation will have
accounted for most of that -- we did 50 evals, at 30 seconds each, so that's 25 minutes.
That means that 3h40m is accounted for, and the remainder can just be chalked up to
noise, I guess.</p>

<p>That leads to one question: do we actually need to be doing validation for these
trains?</p>

<h3>To validate or not to validate?</h3>

<p>I've been doing validation loops in these trains largely out of habit -- when you're
training an ML model, it's just "what you do".</p>

<p>The reason you'd normally hold out a validation set is simple: if you're training
over multiple epochs, then eventually your model is going to start overfitting to the training
data <sup><a href="#fn-2" target="_blank" rel="noopener noreferrer">2</a></sup>.  You validate as you go along so that you can spot any points where,
while the training loss continues to drop, the validation loss -- which is loss on
data that the model hasn't been trained on -- starts rising.  That's the classic
indicator of overfitting.</p>

<p>But for these models we're not doing multiple epochs -- we're just training through
a stream of constantly new tokens.  So, in fact, there's no real difference between
the training data and the validation data, apart from the fact that the validation
data is constant.  From the model's perspective, it's all new stuff (modulo any
repetitions in the dataset, which is possible but I think not likely to be
super-common in something as curated as FineWeb).</p>

<p>Now, in this post I'm aiming to identify the best options for training in the cloud --
cost in terms of dollars and time.  I don't want to change the model itself or the
training strategy because I want whatever I come up with to be roughly equivalent
to the models I trained on my own machine.  Exploring enhancements is for the
next post. (Of course, given that the batch size is one of the levers I want to
experiment with, and training on larger machines is already meaning that I'm doing
micro-batches larger than the batch size of 6 that I used locally, and then the overall batches are 8 times
larger, that's not quite true.)</p>

<p>Validation, however, doesn't actually affect the training runs in any direct way.
I could in theory remove it.</p>

<p>However, that is a relatively large change to the code, as I've kind of linked
it in with my checkpointing code.</p>

<p>I think that what I'll do for now is leave it in.  Validation will scale at the same
rate as training (so long as I leave the eval batches constant) so it leaving it
there will give me a clean comparison between machine types.  And I can keep notes
on how much time was spent on validation for each train so that I can subtract it from
the total time if that proves useful.</p>

<p>However, when I start tweaking the training code with changes beyond the batch
size, I should probably try removing validation first.</p>

<p>Anyway, while validation during the training run might not be important, evaluating
the model at the end and seeing how it compares to others is!  Let's do that next.</p>

<h3>Testing the first model</h3>

<p>There were two important post-train evals that I did on the models that I trained locally:</p>

<ol>
<li>The loss they got on the validation set from the first train.  Strictly speaking, I was kind of
cheating and using that as a test set.</li>
<li>The score given by the OpenAI GPT 5.1 model for an instruction-following dataset.
This was the one provided in the book -- an Alpaca-style Q&amp;A dataset, with a
well-defined train and test set.  Each model was fine-tuned on a training set of 85% of the data
until loss on a validation set of 5% of the data started rising, and then tested on the
remaining 10%.  Sebastian Raschka, being a pro, was splitting up the data properly :-)</li>
</ol>

<p>There was also a simple smoke test -- how does the model predict that the phrase</p>

<pre><code>Every effort moves you
</code></pre>

<p>...should continue?</p>

<p>I should do the same three tests here.</p>

<h4>Smoke test</h4>

<p><a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/a9167188d4a64762bfb3d45624f6677cabff9efd/test_smoke.py" target="_blank" rel="noopener noreferrer">A simple autoregressive generation script</a>
is easy enough to knock together, and:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_smoke.py<span> </span>runs/8xa100m40/model.json<span> </span>runs/8xa100m40/checkpoints/best/model.safetensors
Every<span> </span>effort<span> </span>moves<span> </span>you<span> </span>toward<span> </span>finding<span> </span>more<span> </span>fun<span> </span>stuff,”<span> </span>Geller<span> </span>explains.
“We<span> </span>love<span> </span>the<span> </span>music<span> </span>because
</code></pre>
</div>

<p>All we're looking for here is basic coherency, and I think this is good enough to
pass that filter.</p>

<h4>Loss tests</h4>

<p>Next, the loss-style testing.  What I think I want to be able to do here is
just take a <code>model.safetensors</code> file and run an eval against a standard dataset.</p>

<p>I did not generate my own test set, but I did generate a much-larger-than-necessary
eval set, 1% of both FineWeb and FineWeb-Edu -- that's 100 million tokens or so in
both cases.</p>

<p>In the validation that I was doing during the train just now, I did 300 batches
of 1,024 tokens with a micro-batch size of 13.  That only ran on the rank 0 process,
so that's</p>

300×13×1,024=3,993,600tokens

<p>Not even 4% of the validation data.</p>

<p>Now, for the local eval, I think it makes sense to make it run for about five minutes
-- that's just for my own convenience, I don't want to spend very long -- and
I know from the previous local train that I can do 3,200 batches of six 1,024-token
sequences in that time:</p>

3,200×6×1,024=19,660,800tokens

<p>So, somewhat arbitrarily, let's use the 19,660,800 tokens starting at position 50,000,000 in the FineWeb
validation dataset for our tests -- they'll never be used for training or validation during
the training loop.  It's kind of a hack, but it'll do for now.</p>

<p><a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/80fb517ef91785644264b5eddb14d88455fa29da/test_loss.py" target="_blank" rel="noopener noreferrer">Here's the code</a>.
It should be easy enough to understand; it did require one tweak to our existing <code>load_dataset</code> function,
though:</p>

<p>Originally, that function worked out out the actual number of tokens to use by
working out the size of each global batch, dividing our requested minimum number of
tokens by that size and taking the floor, adding on one, then multiplying that by
the global batch size.</p>

<p>That works fine in cases where the <code>min_tokens</code> is not a multiple of the global
batch size -- it gives us a round number of batches that contains at least <code>min_tokens</code>.
But if <code>min_tokens</code> is already a multiple of the global batch size, it gives us
an extra batch at the end.  So I added that as a special case in <code>load_dataset</code> to
avoid that.</p>

<p>Anyway, running that gives us a loss:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_loss.py<span> </span>datasets<span> </span>runs/8xa100m40/model.json<span> </span>runs/8xa100m40/checkpoints/best/model.safetensors
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>588</span>.84it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>                                                                                                            </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3200</span>/3200<span> </span><span>[</span><span>05</span>:05&lt;<span>00</span>:00,<span> </span><span>10</span>.49it/s<span>]</span>
Loss<span> </span>against<span> </span>our<span> </span><span>test</span><span> </span>dataset:<span> </span><span>3</span>.674
</code></pre>
</div>

<p>That's actually quite a lot lower than we were seeing with the locally-trained
models on the test dataset I was using then -- but, of course, it's a different
dataset so it's not strictly comparable.</p>

<p>Let's run the same test against them:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_loss.py<span> </span>datasets<span> </span>~/Dev/llm-from-scratch/big-train-model-conf.json<span> </span>~/Dev/llm-from-scratch/big-train-checkpoints-fw/best/model.safetensors
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>███████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>3069</span>.94it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>                                                                                                            </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3200</span>/3200<span> </span><span>[</span><span>04</span>:56&lt;<span>00</span>:00,<span> </span><span>10</span>.79it/s<span>]</span>
Loss<span> </span>against<span> </span>our<span> </span><span>test</span><span> </span>dataset:<span> </span><span>3</span>.944
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_loss.py<span> </span>datasets<span> </span>~/Dev/llm-from-scratch/big-train-model-conf.json<span> </span>~/Dev/llm-from-scratch/big-train-checkpoints-fw-edu/best/model.safetensors
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>979</span>.35it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>                                                                                                            </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3200</span>/3200<span> </span><span>[</span><span>04</span>:55&lt;<span>00</span>:00,<span> </span><span>10</span>.83it/s<span>]</span>
Loss<span> </span>against<span> </span>our<span> </span><span>test</span><span> </span>dataset:<span> </span><span>4</span>.167
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_loss.py<span> </span>datasets<span> </span>~/Dev/llm-from-scratch/big-train-model-conf.json<span> </span>~/Dev/llm-from-scratch/big-train-checkpoints-fw-edu-2x/best/model.safetensors
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>832</span>.12it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>                                                                                                            </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3200</span>/3200<span> </span><span>[</span><span>04</span>:54&lt;<span>00</span>:00,<span> </span><span>10</span>.87it/s<span>]</span>
Loss<span> </span>against<span> </span>our<span> </span><span>test</span><span> </span>dataset:<span> </span><span>4</span>.135
</code></pre>
</div>

<p>That's really interesting!   Those numbers are really close to the numbers I got in the
last post.   That does make some kind of sense, though -- while the numbers aren't
strictly comparable, as I said, both the dataset that I was using then and the one I'm
using now are essentially random stuff from FineWeb, so I guess they must be
more similar than I thought.</p>

<p>But, importantly, the loss on the newly-trained model is much lower -- 3.674 rather
than &gt; 3.9 for all three of the older locally-trained models.</p>

<p>Now, the only big difference between this training run and the ones that I did locally
is the batch size.  As I said in the last post, while I felt that the difference
between my batch size of six and the (reported) batch size of 512 for the original
GPT-2 was the least-likely cause of the differences in the results, Gemini told me
that it thought it was the most likely cause.</p>

<p>It looks like Gemini (and, I should note, <a href="https://news.ycombinator.com/item?id=46205589" target="_blank" rel="noopener noreferrer"><code>spi</code> on Hacker News</a>)
might have been right!  Batch size is super-important.</p>

<p>Let's do the same eval with the OpenAI weights.  I wrote a quick script (in my
old 'LLM from scratch' repo, which has the code used in the book) to
<a href="https://github.com/gpjt/llm-from-scratch/blob/c939774754f3b8ee42c1490f53ade2b77433e548/convert_openai_weights_to_safetensors.py" target="_blank" rel="noopener noreferrer">load up the GPT-2 weights and save them as a safetensors file</a>.</p>

<p>When I ran that, I got an interesting error:</p>

<div>
<pre><span></span><code><span>ValueError: You are trying to save a non contiguous tensor:</span>
<span>``trf_blocks.0.att.W_query.weight`` which is not allowed. It either means you are</span>
<span>trying to save tensors which are reference of each other in which case it's</span>
<span>recommended to save only the full tensors, and reslice at load time, or simply</span>
<span>call ``.contiguous()`` on your tensor to pack it before saving.</span>
</code></pre>
</div>

<p>That was easy enough to fix; in the book's code we assign the weights that have
been loaded from the OpenAI TensorFlow checkpoint files with a function called
<code>assign</code> that looks like this:</p>

<div>
<pre><span></span><code><span>def</span><span> </span><span>assign</span><span>(</span><span>left</span><span>,</span> <span>right</span><span>):</span>
    <span>if</span> <span>left</span><span>.</span><span>shape</span> <span>!=</span> <span>right</span><span>.</span><span>shape</span><span>:</span>
        <span>raise</span> <span>ValueError</span><span>(</span>
            <span>f</span><span>"Shape mismatch.  Left: </span><span>{</span><span>left</span><span>.</span><span>shape</span><span>}</span><span>, Right: </span><span>{</span><span>right</span><span>.</span><span>shape</span><span>}</span><span>"</span>
        <span>)</span>
    <span>return</span> <span>torch</span><span>.</span><span>nn</span><span>.</span><span>Parameter</span><span>(</span><span>torch</span><span>.</span><span>tensor</span><span>(</span><span>right</span><span>))</span>
</code></pre>
</div>

<p>Just adding a call to <code>contiguous</code> to the last line fixed the error:</p>

<div>
<pre><span></span><code>    <span>return</span> <span>torch</span><span>.</span><span>nn</span><span>.</span><span>Parameter</span><span>(</span><span>torch</span><span>.</span><span>tensor</span><span>(</span><span>right</span><span>)</span><span>.</span><span>contiguous</span><span>())</span>
</code></pre>
</div>

<p>...and as a result, I had safetensors files for the original OpenAI models:</p>

<div>
<pre><span></span><code><span>(</span>llm-from-scratch<span>)</span><span> </span>giles@perry:~/Dev/llm-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>ls<span> </span>-lrt
...
-rw-r--r--<span>  </span><span>1</span><span> </span>giles<span> </span>giles<span>        </span><span>731</span><span> </span>Dec<span>  </span><span>9</span><span> </span><span>18</span>:57<span> </span>convert_openai_weights_to_safetensors.py
-rw-r--r--<span>  </span><span>1</span><span> </span>giles<span> </span>giles<span>        </span><span>160</span><span> </span>Dec<span>  </span><span>9</span><span> </span><span>19</span>:00<span> </span>openai-weights-gpt-medium.json
-rw-r--r--<span>  </span><span>1</span><span> </span>giles<span> </span>giles<span>        </span><span>159</span><span> </span>Dec<span>  </span><span>9</span><span> </span><span>19</span>:01<span> </span>openai-weights-gpt-small.json
-rw-r--r--<span>  </span><span>1</span><span> </span>giles<span> </span>giles<span>       </span><span>4452</span><span> </span>Dec<span>  </span><span>9</span><span> </span><span>19</span>:10<span> </span>download_and_use_gpt2.py
drwxr-xr-x<span>  </span><span>2</span><span> </span>giles<span> </span>giles<span>       </span><span>4096</span><span> </span>Dec<span>  </span><span>9</span><span> </span><span>19</span>:10<span> </span>__pycache__
-rw-r--r--<span>  </span><span>1</span><span> </span>giles<span> </span>giles<span> </span><span>1725850968</span><span> </span>Dec<span>  </span><span>9</span><span> </span><span>19</span>:10<span> </span>gpt-2-medium.safetensors
-rw-r--r--<span>  </span><span>1</span><span> </span>giles<span> </span>giles<span>  </span><span>702501224</span><span> </span>Dec<span>  </span><span>9</span><span> </span><span>19</span>:14<span> </span>gpt-2-small.safetensors
</code></pre>
</div>

<p>So now we can run our test against them:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_loss.py<span> </span>datasets<span> </span>~/Dev/llm-from-scratch/openai-weights-gpt-medium.json<span> </span>~/Dev/llm-from-scratch/gpt-2-medium.safetensors
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>804</span>.24it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>                                                                                                            </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3200</span>/3200<span> </span><span>[</span><span>12</span>:41&lt;<span>00</span>:00,<span>  </span><span>4</span>.20it/s<span>]</span>
Loss<span> </span>against<span> </span>our<span> </span><span>test</span><span> </span>dataset:<span> </span><span>3</span>.231
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_loss.py<span> </span>datasets<span> </span>~/Dev/llm-from-scratch/openai-weights-gpt-small.json<span> </span>~/Dev/llm-from-scratch/gpt-2-small.safetensors
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>687</span>.84it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>                                                                                                            </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3200</span>/3200<span> </span><span>[</span><span>04</span>:53&lt;<span>00</span>:00,<span> </span><span>10</span>.89it/s<span>]</span>
Loss<span> </span>against<span> </span>our<span> </span><span>test</span><span> </span>dataset:<span> </span><span>3</span>.500
</code></pre>
</div>

<p>Excellent.  Let's start putting together a table of these results:</p>

<table>
<thead>
<tr>
  <th></th>
  <th>Test loss</th>
</tr>
</thead>
<tbody>
<tr>
  <td>OpenAI weights: medium</td>
  <td>3.231</td>
</tr>
<tr>
  <td>OpenAI weights: small</td>
  <td>3.500</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x A100 40 GiB</td>
  <td>3.674</td>
</tr>
<tr>
  <td>Local FineWeb train</td>
  <td>3.944</td>
</tr>
<tr>
  <td>Local FineWeb-Edu extended train</td>
  <td>4.135</td>
</tr>
<tr>
  <td>Local FineWeb-Edu train</td>
  <td>4.167</td>
</tr>
</tbody>
</table>

<p>That's pretty amazing.  Having a batch size of 13 micro-batches over eight GPUs, or
104 in total, seems to have massively improved the model -- it's much closer to the
original weights.  It will be interesting to see whether I get further improvements
when I move to the larger machines, which (due to having more VRAM) will have larger
possible micro-batches, so we'll get larger global batch sizes.</p>

<p>It certainly makes me think that I could have got much better results locally by using
gradient accumulation, which would mimic the effects of a larger batch size by running
multiple smaller batches through, without doing an optimiser step each time, then doing
one big update once enough has gone through.</p>

<p>But all of that is for another day.  Let's try the instruction fine-tuning test now.</p>

<h4>Instruction fine-tuning</h4>

<p>I decided to pretty much re-use my adapted version of the code from the book;
that meant that I was borrowing quite a lot of Raschka's code, which he has
<a href="https://github.com/rasbt/LLMs-from-scratch/blob/main/LICENSE.txt" target="_blank" rel="noopener noreferrer">released under the Apache 2 license</a>.
I normally use the MIT license for my code, but I'm not married to it, so I
relicensed the whole repo as Apache 2 with some specific headers to say which parts
came from "Build a Large Language Model (from Scratch)", and added
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/77ab971c5830a8f4827c1e485267915690871b0f/test_ift.py" target="_blank" rel="noopener noreferrer">this code</a>.</p>

<p>It downloads the Alpaca dataset from the site for the book, splits it into train/validation/test splits,
trains on the training set, evaluating each epoch and bailing out (and restoring the
previous epoch's weights) when validation loss starts rising, and then runs through the
test set generating responses, and then sends them all off to the OpenAI API for
GPT-5.1 to judge them.</p>

<p>Running it against our new model gets a score of 17.09.  Let's try the various other models
and build out our table:</p>

<table>
<thead>
<tr>
  <th></th>
  <th>Test loss</th>
  <th>Instruction fine-tune score</th>
</tr>
</thead>
<tbody>
<tr>
  <td>OpenAI weights: medium</td>
  <td>3.231</td>
  <td>38.53</td>
</tr>
<tr>
  <td>OpenAI weights: small</td>
  <td>3.500</td>
  <td>22.98</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x A100 40 GiB</td>
  <td>3.674</td>
  <td>17.09</td>
</tr>
<tr>
  <td>Local FineWeb train</td>
  <td>3.944</td>
  <td>16.01</td>
</tr>
<tr>
  <td>Local FineWeb-Edu extended train</td>
  <td>4.135</td>
  <td>14.55</td>
</tr>
<tr>
  <td>Local FineWeb-Edu train</td>
  <td>4.167</td>
  <td>16.86</td>
</tr>
</tbody>
</table>

<p>Interesting!  In the last run, <a href="/2025/12/llm-from-scratch-28-training-a-base-model-from-scratch#but-why-is-our-model-worse-than-openais" target="_blank" rel="noopener noreferrer">I found</a>
the instruction fine-tune numbers came out as FineWeb-Edu extended &gt; FineWeb &gt; FineWeb-Edu,
but here we have FineWeb-Edu &gt; FineWeb &gt; FineWeb-Edu extended -- exactly the opposite!</p>

<p>I do have to wonder, though, how precise a measure this is.  While the training should
be fairly consistent (though I don't have a random seed in there to enforce it),
the fact that we're using an LLM as a judge means that there is an element of
randomness coming in here.  Indeed, I re-ran the FineWeb-Edu extended train test again,
just to see what I got, and it came up with an even-worse 12.12.</p>

<p>So I don't think we can read a huge amount into these numbers -- well, unless we can get
the numbers significantly up.  While it looks like a 2.5-point difference might
just be randomness, I doubt that a 10-point difference could be.</p>

<p>I think we've done the tests that we need for this model now, and we have a testing
procedure in place.  So let's train some further models on different instance
sizes, and gather numbers.</p>

<h3>Training on an 8x B200 with 160 GiB per GPU, using SXM6</h3>

<p>This is the biggest machine available on Lambda Labs right now, and is only
sporadically available; one happens to be there now, so let's
to give it a go.  First, we need to create the <a href="https://github.com/gpjt/ddp-base-model-from-scratch/tree/main/runs/8xb200m160" target="_blank" rel="noopener noreferrer">runs/8xb200m160</a>
directory, initially with a <code>train.json</code> that is a clone of the one I did for
the last train, <code>8xa100m40</code>, then spin up the machine.</p>

<h4>The train</h4>

<p>As before, we need to log in, clone the repo, then in it run the
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/30a3fd75f1eab96cd598a6c0a0f14465ddee6ae4/setup_lambda.sh" target="_blank" rel="noopener noreferrer"><code>setup_lambda.sh</code></a>
script, run <code>uv sync</code>, and try to run the script:</p>

<div>
<pre><span></span><code><span>uv run torchrun --nproc_per_node=8 ddp_train.py 8xb200m160 datasets</span>
</code></pre>
</div>

<p>It crapped out because there was no datasets directory, which is an annoyance.
We should create it if it doesn't exist.</p>

<p>Create the directory, and run it again.  It took a while to download the
dataset, because every per-GPU process downloads it separately.  That only took a minute or two,
but it was a waste of time; I think we should only download it from the rank 0 process
with some barriers to make the other processes pause.</p>

<p>Next, we need to do a binary chop on the micro-batch size, starting with a low of 13 (which I
know will be fine because it worked on the 40 GiB GPUs that we used last time),
and a high of 100 (fairly random, just something I'm pretty sure will fail).</p>

<p>While doing that, a few things are standing out, both to do with validation.
When the script starts, it does one training iteration, then goes straight into
validation.  Then it starts the training run proper.  However:</p>

<ul>
<li>If we're going to do validation then it does make some sense to do one at the start --
but doing one training iteration first seems kind of arbitrary (though it's clear how
that drops out of the existing code).</li>
<li>The validation runs on this machine are taking longer than they were on the less-powerful
A100 GPUs!  That confused me for a bit, until I realised that I didn't notice that it was slower
with the batch-size 13 test, only with the larger ones later in in the binary
chop.  If we're using larger batches, then there's more work to do for the validation.</li>
<li>Doing this binary chop by hand is annoying and error-prone, and worse, we have to wait
for one of those (long) validation runs before we get into proper training.  The initial
training iteration can succeed, while later ones hit memory limits -- it seems like we need to wait
for three or four training iterations before we can be sure that we have a workable
batch size.  Not quite sure why that is, perhaps it's something in the optimiser or
the scaler?</li>
</ul>

<p>We're going to need to work out some kind of fix for that, because it's taken me
17 minutes from spinning up the machine to getting a size for our micro-batches --
which happens to be 64.  On a machine that costs US$39.92/hour, that's an expensive test!
We'll look into that later.</p>

<p>Anyway, a batch size of 64 is pretty neat, as with 8 GPUs, that means we have a global
batch size of 512 -- exactly the same as in the original GPT-2 paper!</p>

<p>So, let's kick off the train.  It takes about 7 minutes to get to the first checkpoint,
at which point it's averaging 801,221 tokens/second.  That pattern repeats, and with about one minute to
do the validation, we're spending about 12.5% of the time on this machine validating.
Hmm.  A further indication that we might want to remove the validation stuff if it's
not adding on any value.</p>

<p>Eventually, it finishes:</p>

<div>
<pre><span></span><code><span>Training complete in 4,190.357 seconds</span>
<span>Tokens seen: 3,260,547,072</span>
<span>Throughput: 778,107 tokens/second</span>
<span>Final train loss: 3.865</span>
<span>Final val loss: 3.770</span>
</code></pre>
</div>

<p>So, that's 1h9m50s.  The final validation loss is not
as good as the previous run on the 8x A100 40 GiB machine, where we got down to 3.675.  Given that we're using the
same validation dataset as the previous, that's meaningful: this is not as good a
model, it seems.</p>

<p>Again, latest and best checkpoints are the same one:</p>

<div>
<pre><span></span><code>ubuntu@129-213-85-212:~/ddp-base-model-from-scratch$<span> </span>ls<span> </span>-lrt<span> </span>runs/8xb200m160/checkpoints/
total<span> </span><span>64</span>
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:05<span> </span>20251210Z170527-iteration-0
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:07<span> </span>20251210Z170712-iteration-0
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:08<span> </span>20251210Z170848-iteration-0
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:10<span> </span>20251210Z171043-iteration-0
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:12<span> </span>20251210Z171231-iteration-0
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:19<span> </span>20251210Z171914-iteration-617
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:26<span> </span>20251210Z172557-iteration-1234
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:32<span> </span>20251210Z173241-iteration-1851
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:39<span> </span>20251210Z173924-iteration-2468
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:46<span> </span>20251210Z174608-iteration-3085
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:52<span> </span>20251210Z175251-iteration-3702
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>17</span>:59<span> </span>20251210Z175935-iteration-4319
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>18</span>:06<span> </span>20251210Z180619-iteration-4936
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>18</span>:13<span> </span>20251210Z181302-iteration-5553
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>18</span>:19<span> </span>20251210Z181945-iteration-6170
lrwxrwxrwx<span> </span><span>1</span><span> </span>ubuntu<span> </span>ubuntu<span>   </span><span>30</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>18</span>:21<span> </span>latest<span> </span>-&gt;<span> </span>20251210Z182116-iteration-6218
lrwxrwxrwx<span> </span><span>1</span><span> </span>ubuntu<span> </span>ubuntu<span>   </span><span>30</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>18</span>:21<span> </span>best<span> </span>-&gt;<span> </span>20251210Z182116-iteration-6218
drwxrwxr-x<span> </span><span>2</span><span> </span>ubuntu<span> </span>ubuntu<span> </span><span>4096</span><span> </span>Dec<span> </span><span>10</span><span> </span><span>18</span>:21<span> </span>20251210Z182116-iteration-6218
</code></pre>
</div>

<p>So we can download everything:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xb200m160<span> </span><span>(</span>main<span>)</span>$<span> </span>scp<span> </span>ubuntu@129.213.85.212:/home/ubuntu/ddp-base-model-from-scratch/runs/8xb200m160/big-training-run-chart.png<span> </span>.
big-training-run-chart.png<span>                                                                                                              </span><span>100</span>%<span>   </span>75KB<span> </span><span>149</span>.0KB/s<span>   </span><span>00</span>:00
giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xb200m160<span> </span><span>(</span>main<span>)</span>$<span> </span>scp<span> </span>-r<span> </span>ubuntu@129.213.85.212:/home/ubuntu/ddp-base-model-from-scratch/runs/8xb200m160/checkpoints/best<span> </span>./
big-training-run-chart.html<span>  </span>big-training-run-chart.png<span>   </span>model.json<span>                   </span>train.json
giles@perry:~/Dev/ddp-base-model-from-scratch/runs/8xb200m160<span> </span><span>(</span>main<span>)</span>$<span> </span>scp<span> </span>-r<span> </span>ubuntu@129.213.85.212:/home/ubuntu/ddp-base-model-from-scratch/runs/8xb200m160/checkpoints/best<span> </span>./
meta.json<span>                                                                                                                               </span><span>100</span>%<span>  </span><span>100</span><span>     </span><span>0</span>.5KB/s<span>   </span><span>00</span>:00
optimizer.pt<span>                                                                                                                            </span><span>100</span>%<span> </span>1244MB<span>  </span><span>12</span>.2MB/s<span>   </span><span>01</span>:42
scaler.pt<span>                                                                                                                               </span><span>100</span>%<span> </span><span>1383</span><span>     </span><span>4</span>.9KB/s<span>   </span><span>00</span>:00
model.safetensors<span>                                                                                                                       </span><span>100</span>%<span>  </span>670MB<span>  </span><span>12</span>.7MB/s<span>   </span><span>00</span>:52
</code></pre>
</div>

<p>...and here's the training chart:</p>

<p><img src="/post-assets/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud/training-run-8xb200m160.png" alt="Training run on an 8x B200 with 160 GiB/GPU" title="Training run on an 8x B200 with 160 GiB/GPU" /></p>

<p>OK, so that's smoother than the last one -- no loss spikes.  Maybe the larger
batch size smoothed them?</p>

<p>Let's think a bit about the cost of this train.</p>

<h4>Cost</h4>

<p>From Lambda Labs, we had that machine running for a little over 1h30m.  At US$39.92/hour,
the total cost was US$60.25.</p>

<p>Yikes.  So, knocking off the 1h10 or so for the train, we have 20m to allow for --
which matches up quite well to the 17 minutes of fiddling with batch sizes, and
then 3 minutes to download all of the files.</p>

<p>If this blog post isn't going to cost significantly more than it needs to, we need
to get that down.  Of the US$60.25, just
over US$13 was spent on identifying the
batch size.  Only US$46.57 was spent on the train itself.</p>

<p>We also did 11 validation runs as part of that; at a minute each, those cost US$7.32.
So, excluding validation, we're below US$40 for the train.</p>

<h4>Evals</h4>

<p>Now, let's run our tests.  First, the smoke test: we get this:</p>

<pre><code>Every effort moves you to give something back. You will only make sure to check what you find on all other website for
</code></pre>

<p>"...on all other website for..." is a bit rubbish.  Still, on to the loss:</p>

<div>
<pre><span></span><code><span>Loss against our test dataset: 3.771</span>
</code></pre>
</div>

<p>That's in line with the training loss -- worse than the loss I got with the one trained on
the smaller machine, with its corresponding smaller batch size, but still better than
any of our local trains.  Still interesting, though -- larger batches are not guaranteed
to get bigger results.   More investigation needed there!</p>

<p>On to the instruction fine-tuning test.  That gives us a score of 13.89 -- the
worst that we've seen yet!</p>

<p>I think I'll put together a full table including these results later; I want to try training on some
other, differently sized machines first, and we can aggregate the results at the end.</p>

<p>But before we do that, let's make some changes to the scripts to fix some of those
QoL issues we encountered in that last train.</p>

<h3>QoL fixes to the script</h3>

<p>The first irritation was that it errored out saying that <code>datasets</code> was not
a directory when it didn't exist.  The script takes a datasets directory as one of
its command-line options, and it's reasonable that it checks that it really is a
directory (rather than, say, a file or a symlink):</p>

<div>
<pre><span></span><code>    <span>datasets_dir</span> <span>=</span> <span>Path</span><span>(</span><span>datasets_dir_path</span><span>)</span>
    <span>if</span> <span>not</span> <span>datasets_dir</span><span>.</span><span>is_dir</span><span>():</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>f</span><span>"</span><span>{</span><span>datasets_dir_path</span><span>}</span><span> is not a directory"</span><span>)</span>
</code></pre>
</div>

<p>...but if it doesn't exist, it might as well create it first.  Now, I could just put this
before the <code>is_dir</code> check:</p>

<div>
<pre><span></span><code>    <span>if</span> <span>not</span> <span>datasets_dir</span><span>.</span><span>exists</span><span>():</span>
        <span>datasets_dir</span><span>.</span><span>mkdir</span><span>()</span>
</code></pre>
</div>

<p>...but remember, this code is run by multiple processes -- so they could easily
trip over a race condition here.</p>

<p>What I want is to have just one of them do this; I've deemed the rank 0 process
the "special" one for validation, printing the progress bar, and so on, so we may as
well treat it that way here.</p>

<p>But -- there's a difference!  Rank zero is the one that should be printing stuff
out, it's true.  And right now, we only have one node participating in this train.
But I do want to avoid simple errors that would make it hard to run multi-node in
the future.</p>

<p>Now, if we have multiple nodes, then each one will have its own filesytem (unless we're
using NFS or something like that), so we'll
need a separate "datasets" directory for all of them.  What we want is to do these
checks on one process on each node.</p>

<p>Usefully, we have the <code>local_rank</code> variable that is defined earlier in <code>main</code>,
which is per-node.  Again, let's imagine we have two nodes with two GPUs each.
Node 0 might be runnning the processes with global rank 0 and 1, and node 1 might
have global ranks 2 and 3.  On node 0, the processes would have local ranks 0 and 1
respectively, but on node 1, they'd also be local ranks 0 and 1.</p>

<p>So, the full code becomes this:</p>

<div>
<pre><span></span><code>    <span>datasets_dir</span> <span>=</span> <span>Path</span><span>(</span><span>datasets_dir_path</span><span>)</span>
    <span>if</span> <span>local_rank</span> <span>==</span> <span>0</span><span>:</span>
        <span>if</span> <span>not</span> <span>datasets_dir</span><span>.</span><span>exists</span><span>():</span>
            <span>datasets_dir</span><span>.</span><span>mkdir</span><span>()</span>
    <span>dist</span><span>.</span><span>barrier</span><span>()</span>
    <span>if</span> <span>not</span> <span>datasets_dir</span><span>.</span><span>is_dir</span><span>():</span>
        <span>raise</span> <span>Exception</span><span>(</span><span>f</span><span>"</span><span>{</span><span>datasets_dir_path</span><span>}</span><span> is not a directory"</span><span>)</span>
</code></pre>
</div>

<p>Note the barrier; we don't want the other processes to check whether <code>datasets_dir</code> is a
directory until the local rank 0 process has had a chance to create it.</p>

<p>(Of course, if we were running this on a setup where all of the nodes shared a filesystem,
it wouldn't work -- in that case we'd want to use the global rank that we can get from
<code>dist.get_rank()</code> instead.  But we can burn that bridge if we ever come to it ;-)</p>

<p>Phew, that was a bit more work than I expected!  But it sets us up nicely for the
next QoL fix on my to-do list.</p>

<p>I don't like the fact that every process downloaded the whole dataset.  The
<code>huggingface_hub.snapshot_download</code> actually handled it pretty gracefully -- none
of the processes tripped over any of the others.  Indeed, it looks like there was
some kind of global queueing going on, so they downloaded it one after the other.</p>

<p>But it did take time -- maybe a minute or two in total, and with the clock ticking
on that ~US$40/hour machine, that felt a bit stress-inducing.</p>

<p>So: I think it would be best to only do that from the rank 0 process as well.</p>

<p>The code that downloads the dataset is just after the bit we've been looking at:</p>

<div>
<pre><span></span><code>    <span>dataset_dir</span> <span>=</span> <span>download_dataset</span><span>(</span><span>datasets_dir</span><span>,</span> <span>train_conf</span><span>[</span><span>"dataset"</span><span>])</span>
</code></pre>
</div>

<p>...and <code>download_dataset</code> looks like this:</p>

<div>
<pre><span></span><code><span>def</span><span> </span><span>download_dataset</span><span>(</span><span>datasets_dir</span><span>,</span> <span>dataset_name</span><span>):</span>
    <span>download_path</span> <span>=</span> <span>snapshot_download</span><span>(</span>
        <span>f</span><span>"</span><span>{</span><span>dataset_name</span><span>}</span><span>"</span><span>,</span>
        <span>repo_type</span><span>=</span><span>"dataset"</span><span>,</span>
        <span>local_dir</span><span>=</span><span>datasets_dir</span> <span>/</span> <span>dataset_name</span><span>,</span>
        <span>allow_patterns</span><span>=</span><span>"*"</span>
    <span>)</span>
    <span>return</span> <span>Path</span><span>(</span><span>download_path</span><span>)</span>
</code></pre>
</div>

<p>Now, the docs for <a href="https://huggingface.co/docs/huggingface_hub/v1.2.2/en/package_reference/file_download#huggingface_hub.snapshot_download" target="_blank" rel="noopener noreferrer"><code>huggingface_hub.snapshot_download</code></a>
say that the <code>local_dir</code> parameter is:</p>

<blockquote>
  <p>If provided, the downloaded files will be placed under this directory.</p>
</blockquote>

<p>...and the return value is this:</p>

<blockquote>
  <p>Returns</p>
  
  <p><code>str</code> or list of <code>DryRunFileInfo</code></p>
  
  <ul>
  <li>If <code>dry_run=False</code>: Local snapshot path.</li>
  <li>If <code>dry_run=True</code>: A list of DryRunFileInfo objects containing download information.</li>
  </ul>
</blockquote>

<p>We happen to be passing in a <code>Path</code> object for <code>local_dir</code>, and we're not in <code>dry_run</code> mode -- it
defaults to <code>False</code>.  So all we're doing by returning that <code>download_path</code> wrapped in
a <code>Path</code> object is a slightly indirect way of returning the path <code>datasets_dir / dataset_name</code>
that we're passing in as <code>local_dir</code>.</p>

<p>For tidiness, I really want to gate the call to <code>download_dataset</code> in <code>main</code> with
the same rank stuff as we did for the directory creation.  So, let's change the
setup so that <code>download_dataset</code> takes the path to the directory where we want this
specific dataset to be, not the generic "all datasets" directory.  And given that
we're now passing this specific path into the function, we don't need to return it:</p>

<div>
<pre><span></span><code><span>def</span><span> </span><span>download_dataset</span><span>(</span><span>dataset_dir</span><span>,</span> <span>dataset_name</span><span>):</span>
    <span>snapshot_download</span><span>(</span>
        <span>f</span><span>"</span><span>{</span><span>dataset_name</span><span>}</span><span>"</span><span>,</span>
        <span>repo_type</span><span>=</span><span>"dataset"</span><span>,</span>
        <span>local_dir</span><span>=</span><span>dataset_dir</span><span>,</span>
        <span>allow_patterns</span><span>=</span><span>"*"</span>
    <span>)</span>
</code></pre>
</div>

<p>Now it's just a wrapper around a single call to <code>snapshot_download</code>, which I'm not
entirely sure about (it's a code smell that I'm probably creating an unnecessary
level of abstraction) but I think I'm happiest leaving it that way for now, as it does
hide away a bit of messiness in the HF hub API. <sup><a href="#fn-3" target="_blank" rel="noopener noreferrer">3</a></sup></p>

<p>That means that we can now combine the directory-checking logic that we fixed above
with download-on-local-rank-zero-only code like this:</p>

<div>
<pre><span></span><code>    <span>datasets_dir</span> <span>=</span> <span>Path</span><span>(</span><span>datasets_dir_path</span><span>)</span>
    <span>dataset_name</span> <span>=</span> <span>train_conf</span><span>[</span><span>"dataset"</span><span>]</span>
    <span>dataset_dir</span> <span>=</span> <span>datasets_dir</span> <span>/</span> <span>dataset_name</span>
    <span>if</span> <span>local_rank</span> <span>==</span> <span>0</span><span>:</span>
        <span>if</span> <span>not</span> <span>datasets_dir</span><span>.</span><span>exists</span><span>():</span>
            <span>datasets_dir</span><span>.</span><span>mkdir</span><span>()</span>
        <span>if</span> <span>not</span> <span>datasets_dir</span><span>.</span><span>is_dir</span><span>():</span>
            <span>raise</span> <span>Exception</span><span>(</span><span>f</span><span>"</span><span>{</span><span>datasets_dir_path</span><span>}</span><span> is not a directory"</span><span>)</span>
        <span>download_dataset</span><span>(</span><span>dataset_dir</span><span>,</span> <span>dataset_name</span><span>)</span>
    <span>dist</span><span>.</span><span>barrier</span><span>()</span>
</code></pre>
</div>

<p><a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/6851ce9b403204477758faa2e14f99061fc25504/ddp_train.py" target="_blank" rel="noopener noreferrer">Here's the updated code</a> with those fixes.</p>

<p>Now, let's move on to validation.  I'm increasingly of the opinion that the validation
steps are just adding on to the cost without much in the way of benefit.</p>

<p>Additionally,
the validation is taking a different amount of time for each batch size, and
happen a different number of times in each train -- remember,
it's <code>validation_batches</code> batches every <code>validation_interval</code> global steps, and
the batch size varies based on the micro-batch size, which is different for different
amounts of GPU VRAM, and the total number of global steps in a train <em>also</em> varies
based on the size of each batch.</p>

<p>So that means that if we want to compare apples to apples in any final comparison
of the time and money cost of training models on different kinds of Lambda Labs machines,
we'll want to exclude the validation cost -- once we've settled on a machine type,
we're going to want to fine-tune the validation size for that in much more detail than I
have to date, assuming we don't drop it entirely.</p>

<p>However: I'm loath to make such a fundamental change halfway through this comparison.
It's tightly coupled to the checkpointing code, and the charting code, and so on.
So I think that for this post, I'm just going to keep it there, and keep track of how
much time (roughly) we're spending on each validation step for each train, so that
we can remove it and get a "pure" train-time only comparison between the different
kinds of machines.</p>

<p>It's not pretty, but I think it's better than changing horses mid-stream.</p>

<p>On the other hand, the validation is a real pain when doing the binary chop to find out
the maximum micro-batch size for our VRAM before
we start the training run.  That's because we have to wait for one validation to run before
we get into the full training loop, which makes it slower.   On top of that, having
to do a manual binary chop is a PITA.</p>

<p>What I think would be a true QoL improvement for the future trains is something that
does the binary chop for us, using a dummy training loop.  We run it once on each
new machine type, get a micro-batch size to plug into our training parameters, and
then let it rip,</p>

<p>This will re-use so much of the code from the training script <code>ddp_train</code> that I
think it actually is just an alternative way of running it.</p>

<p>After a bit of hacking, I came up with <a href="https://github.com/gpjt/ddp-base-model-from-scratch/blob/d2a7b694ff217a4ca0ade8267776a87816c58825/ddp_train.py" target="_blank" rel="noopener noreferrer">this updated code</a>
-- the <a href="https://github.com/gpjt/ddp-base-model-from-scratch/commit/d2a7b694ff217a4ca0ade8267776a87816c58825" target="_blank" rel="noopener noreferrer">diff</a> is a bit
hairy, but essentially:</p>

<ul>
<li>I updated the <code>train</code> function so that it takes flags to
tell it whether or not to do validation (default true) and an optional maximum
number of steps, which is <code>None</code> by default.  With those default values, it does
exactly the same as before, of course.</li>
<li>I created a <code>load_datasets_and_train</code> function, which does all of the dataset-loading
stuff that the original <code>main</code> function did, and then calls <code>train</code> with a
<code>DDP</code>-wrapped model.  So that maintains the current flow.</li>
<li>Next, I added a <code>--find-max-microbatch-size</code> flag to the script; if that's not
set, it just calls <code>load_datasets_and_train</code>.</li>
<li>However, if it is set, it instead calls a new <code>binary_chop_batch_sizes</code> function,
which determines the largest batch size we can fit onto the current hardware
for the current run, and (on the rank 0 process only, to avoid log spam),
prints it out.</li>
<li><code>binary_chop_batch_sizes</code> does what it says on the tin; it confirms that we can
train with batch size of 1, and that we can't with batch size 70 (chosen because
the limit was 64 on that massive B200 machine), then chops between them to find
the largest batch size that doesn't OOM.</li>
<li>It uses <code>check_batch_size_works</code> for that -- that just constructs a dataset with
the appropriate batch size, then runs a three-step train with no validation
to see if it raises an OOM.  PyTorch rather messily just raises a generic
<code>RuntimeError</code> for those, but we can look inside the exception's message to
see if it is an OOM.</li>
</ul>

<p>That takes just over six seconds to find the correct batch size on my local machine;
with multiple GPUs, I expect it will be slower (there's a spinup overhead to start
all of the per-GPU processes), but I'm sure it won't be as bad
as the manual binary chops with validation that I was doing, and will be less
error-prone.</p>

<p>Right!  We've done some QoL stuff, let's try another machine size on Lambda Labs :-)</p>

<h3>Training on an 8x H100 with 80 GiB per GPU, using SXM5</h3>

<p>These are the machines that Andrej Karpathy is recommending for training nanochat,
so let's see how we do with them.  They cost US$23.92/hour; let's see how it works
out.</p>

<h4>The train</h4>

<p>Here are the steps:</p>

<ol>
<li>Create the <code>8xh100m80</code> run file, commit and push.</li>
<li>Spin up the machine.  On it:</li>
<li>Clone the repo</li>
<li><code>setup_lambda.sh</code></li>
<li><code>uv sync</code></li>
</ol>

<p>Now let's download our dataset and find our micro-batch size:</p>

<div>
<pre><span></span><code>ubuntu@192-222-52-220:~/ddp-base-model-from-scratch$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>--nproc_per_node<span>=</span><span>8</span><span> </span>ddp_train.py<span> </span>8xh100m80<span> </span>datasets<span> </span>-f
...
Max<span> </span>microbatch<span> </span>size<span> </span>was<span> </span><span>27</span>
</code></pre>
</div>

<p>That took less than a minute to run -- nice!  Now we can put that micro-batch
size in <code>train.json</code>.  It does seem a little small -- after all, we could fit
a batch of 64 into 160 GiB -- but I'll do some analysis later.</p>

<p>Actually, before we kick off the train, let's see how long all of the preparatory
steps took to run before we can do that -- not just the micro-batch-size script, but
also the installation of the dependencies, the clone, and any overhead from boot
time etc:</p>

<div>
<pre><span></span><code>ubuntu@192-222-52-220:~/ddp-base-model-from-scratch$<span> </span>uptime
<span> </span><span>22</span>:37:19<span> </span>up<span> </span><span>5</span><span> </span>min,<span>  </span><span>2</span><span> </span>users,<span>  </span>load<span> </span>average:<span> </span><span>1</span>.38,<span> </span><span>1</span>.51,<span> </span><span>0</span>.69
</code></pre>
</div>

<p>Five minutes total.  Not bad.</p>

<p>Let's start the train:</p>

<div>
<pre><span></span><code>ubuntu@192-222-52-220:~/ddp-base-model-from-scratch$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>--nproc_per_node<span>=</span><span>8</span><span> </span>ddp_train.py<span> </span>8xh100m80<span> </span>datasets
</code></pre>
</div>

<p>The initial validation run took 38 seconds, and then we started off.  At 4m37s in,
we get the first real validation run; at that point, it's running at 493k tokens/second.</p>

<p>Eventually, it finishes, having taken about 1h50 including all of the validations.</p>

<pre><code>Training complete in 6,650.197 seconds
Tokens seen: 3,260,252,160
Throughput: 490,249 tokens/second
Final train loss: 4.091
Final val loss: 3.729
</code></pre>

<p>Here's the training chart:</p>

<p><img src="/post-assets/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud/training-run-8xh100m80.png" alt="Training run on an 8x H100 with 80 GiB/GPU" title="Training run on an 8x H100 with 80 GiB/GPU" /></p>

<p>Two things stand out here:</p>

<ol>
<li>We had two nasty loss spikes.</li>
<li>As a result of the second of those, the best iteration as per validation
loss is not the last one.</li>
</ol>

<p>Further evidence that gradient clipping is likely to be an excellent addition to
our training loop!  It's also worth noting that the train loss spikes at the same
time as the validation loss, so getting rid of the latter would still allow us
to get a "best" checkpoint to compare with the latest at the end of the train.</p>

<h4>Cost</h4>

<p>The machine was up and running for 2h9m, costing US$23.92/hour, for a total cost of
US$51.47.</p>

<p>The train took 6,650.197 seconds, so about 1h50m.  Allowing for five minutes setup
time, that's 1h55m accounted for.  There's an extra 14m there -- that was because
downloading those two checkpoints to my machine took quite a long time due to local
network issues.  Might want to look into ways to avoid that later.</p>

<p>And for later cost-accounting purposes, we should note that it took 38 seconds or
so for each validation run, and we can see on the chart that there were 24 of them.</p>

<h4>Evals</h4>

<p>So, firstly, let's give our two models -- the best one and the latest one -- a smoke test:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_smoke.py<span> </span>runs/8xh100m80/model.json<span> </span>runs/8xh100m80/checkpoints/best/model.safetensors
Every<span> </span>effort<span> </span>moves<span> </span>you<span> </span>forward,<span> </span>and<span> </span>you<span> </span>will<span> </span>not<span> </span>regret<span> </span>it.
But<span> </span><span>if</span><span> </span>something<span> </span>comes<span> </span><span>in</span>,<span> </span>you<span> </span>may<span> </span>ask<span> </span>the
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_smoke.py<span> </span>runs/8xh100m80/model.json<span> </span>runs/8xh100m80/checkpoints/latest/model.safetensors
Every<span> </span>effort<span> </span>moves<span> </span>you<span> </span><span>in</span><span> </span>the<span> </span>future<span>;</span><span> </span><span>in</span><span> </span>many<span> </span>cases<span> </span>you<span> </span>can<span>'</span>t<span> </span>afford<span> </span>the<span> </span>most<span> </span>costly<span> </span>replacement.&lt;<span>|</span>endoftext<span>|</span>&gt;The<span> </span>following<span> </span>list
</code></pre>
</div>

<p>Both of those look OK!  Now let's try the loss test.  I started running it, but
when it started downloading the dataset, I realised that it needed
<a href="https://github.com/gpjt/ddp-base-model-from-scratch/commit/bd4f14cd1e323434561b35edebe4bce71c5e4b37" target="_blank" rel="noopener noreferrer">updating to allow for the changes I made to <code>download_dataset</code></a> -- ooops!
That done, let's give it a run for both of our models:</p>

<div>
<pre><span></span><code>giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_loss.py<span> </span>datasets<span> </span>runs/8xh100m80/model.json<span> </span>runs/8xh100m80/checkpoints/best/model.safetensors
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>810</span>.61it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>                                                                                                            </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3200</span>/3200<span> </span><span>[</span><span>04</span>:54&lt;<span>00</span>:00,<span> </span><span>10</span>.88it/s<span>]</span>
Loss<span> </span>against<span> </span>our<span> </span><span>test</span><span> </span>dataset:<span> </span><span>3</span>.725
giles@perry:~/Dev/ddp-base-model-from-scratch<span> </span><span>(</span>main<span>)</span>$<span> </span>uv<span> </span>run<span> </span>test_loss.py<span> </span>datasets<span> </span>runs/8xh100m80/model.json<span> </span>runs/8xh100m80/checkpoints/latest/model.safetensors
Fetching<span> </span><span>4</span><span> </span>files:<span> </span><span>100</span>%<span>|</span>███████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>4</span>/4<span> </span><span>[</span><span>00</span>:00&lt;<span>00</span>:00,<span> </span><span>1719</span>.15it/s<span>]</span>
Download<span> </span>complete:<span> </span>:<span> </span><span>0</span>.00B<span> </span><span>[</span><span>00</span>:00,<span> </span>?B/s<span>]</span><span>                                                                                                            </span><span>|</span><span> </span><span>0</span>/4<span> </span><span>[</span><span>00</span>:00&lt;?,<span> </span>?it/s<span>]</span>
<span>100</span>%<span>|</span>█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████<span>|</span><span> </span><span>3200</span>/3200<span> </span><span>[</span><span>04</span>:53&lt;<span>00</span>:00,<span> </span><span>10</span>.89it/s<span>]</span>
Loss<span> </span>against<span> </span>our<span> </span><span>test</span><span> </span>dataset:<span> </span><span>3</span>.734
</code></pre>
</div>

<p>As you'd expect, the best checkpoint has somewhat better loss, at 3.725, than the
last one, with 3.734.  Once again, better than our local trains, but not quite as good
as the result with the first cloud train on that 8x A100 40 GiB machine, which was 3.674.
Again, I'll put together a table comparing all of these results at the end.</p>

<p>Does that make any real difference with the instruction fine-tune test?
The test prints a lot out, but the headline numbers:</p>

<ul>
<li>Best checkpoint: 4 epochs of fine-tuning, and a score of 11.98 -- another record low!  Amusingly, it confidently
said "The author of 'Pride and Prejudice' is Sarah Palin".</li>
<li>Latest checkpoint: 5 epochs of fine-tuning, and a rather good score of 17.91.</li>
</ul>

<p>So that was interesting!  However, I am getting ever less convinced that the IFT
test is a useful one; the randomness of the LLM-as-a-judge responses means that I
don't think it can be consistent.</p>

<p>Perhaps a better way to do this would be to batch up all of the models, and then
give GPT5.1 answers from "model A", "model B", and so on all in one query, and then
to ask it to give them scores all at the same time.  That would hopefully make things at least a bit more
consistent.  Something to ponder later, I think.</p>

<p>In the meantime, one extra thing I wanted to dig into before going on to the last
train for this post:</p>

<h3>Batch size scaling</h3>

<p>I mentioned that I thought that the batch size for that last run, 27, was a bit
small considering that we'd managed to fit a size of 64 into the 160 GiB/GPU machine.
But after thinking about it for a bit, it occurs to me that during my
experiments doing fine-tuning, I came to the conclusion that
<a href="/2024/08/fine-tuning-8" target="_blank" rel="noopener noreferrer">memory use scaled linearly with batch size</a>, with a
fixed amount per element in the batch (the activations for the model for that batch element),
plus an overhead (the model itself, the optimiser, and perhaps other stuff).</p>

<p>We have batch sizes for:</p>

<ul>
<li>24 GiB locally, which was 6</li>
<li>40 GiB in the first train in this series, which was 13</li>
<li>80 GiB in the last one, giving us 27</li>
<li>160 GiB in the one on the huge machine, giving us 64</li>
</ul>

<p>Now, that is slightly messy data because each memory "measurement" is the size of
the card's VRAM, not the amount of VRAM we actually used -- there might have been anything from zero to
just less than one extra batch element's worth of "spare" space -- but we can see
what we get with a simple linear regression:</p>

<div>
<pre><span></span><code><span>&gt;&gt;&gt;</span> <span>import</span><span> </span><span>numpy</span><span> </span><span>as</span><span> </span><span>np</span>
<span>&gt;&gt;&gt;</span> <span>xs</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>6</span><span>,</span> <span>13</span><span>,</span> <span>27</span><span>,</span> <span>64</span><span>])</span>
<span>&gt;&gt;&gt;</span> <span>ys</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>24</span><span>,</span> <span>40</span><span>,</span> <span>80</span><span>,</span> <span>160</span><span>])</span>
<span>&gt;&gt;&gt;</span> <span>a</span><span>,</span> <span>b</span> <span>=</span> <span>np</span><span>.</span><span>polyfit</span><span>(</span><span>xs</span><span>,</span> <span>ys</span><span>,</span> <span>1</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>print</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
<span>2.3461346633416458</span> <span>11.481296758104722</span>
</code></pre>
</div>

<p>And if we plot that, we get this:</p>

<p><img src="/post-assets/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud/micro-batch-size-scaling-chart.png" alt="Batch size vs GPU VRAM linear regression" title="Batch size vs GPU VRAM linear regression" /></p>

<p>Nice!  That fits really well.  So we have an overhead of about 11.5 GiB, then
about 2.35 GiB per batch element on top of that.</p>

<p>That is, of course, somewhat sad news for anyone trying to repro this on a GPU with
12 GiB -- looks like it would be <em>just</em> too small to even fit in a single-element
batch after the overhead :-(</p>

<p>Anyway, that's been a bit of a side quest.   Let's try our last machine size for
what has (once again) turned into a bit of a monster of a blog post...</p>

<h3>Training on an 8x A100 with 80 GiB per GPU, using SXM4</h3>

<p>This is the same kind of instance as the first train in this post, except that
it has double the VRAM per GPU.  Let's see what we can do with it.</p>

<h4>The train</h4>

<p>Once again, we create the <code>8xa100m80</code> run file, commit and push, then spin up the machine.
On it, we clone the repo, run <code>setup_lambda.sh</code> then <code>uv sync</code>.</p>

<p>Next, we can find our micro-batch size:</p>

<div>
<pre><span></span><code>ubuntu@192-222-52-220:~/ddp-base-model-from-scratch$<span> </span>uv<span> </span>run<span> </span>torchrun<span> </span>--nproc_per_node<span>=</span><span>8</span><span> </span>ddp_train.py<span> </span>8xa100m80<span> </span>datasets<span> </span>-f
...
Max<span> </span>microbatch<span> </span>size<span> </span>was<span> </span><span>28</span>
</code></pre>
</div>

<p>Interesting, we managed to squeeze an extra one in compared to the H100's batch size of 27, despite having
exactly the same amount of VRAM!   Not sure what might have caused that.</p>

<p>It took 4 minutes to get to this point, so let's get that batch size into the config and kick off the run.  The initial validation takes 1m06s,
which is consistent throughout the train.  The first real val run at 8m15s in, and the
estimated train time is 2h35m, with a tokens-per-second of 286,188.</p>

<p>At the end:</p>

<pre><code>Training complete in 11,532.620 seconds
Tokens seen: 3,260,350,464
Throughput: 282,707 tokens/second
Final train loss: 3.771
Final val loss: 3.723
</code></pre>

<p>Again, the latest and the best global steps are the same (despite some loss spikes):</p>

<p><img src="/post-assets/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud/training-run-8xa100m80.png" alt="Training run on an 8x A100 with 80 GiB/GPU" title="Training run on an 8x A100 with 80 GiB/GPU" /></p>

<p>...so we just need to download that and shut down the machine.</p>

<p>How much did that cost us?</p>

<h4>Cost</h4>

<p>The machine was running for 3h25m, costing US$14.32 / hour, for a total of
US$48.76.</p>

<p>Our train took 11,532 seconds, which is 3h12m, and our setup took about 4 minutes --
maybe five including the time required to update the train config with the micro-batch size,
so we have 7 minutes on top of that, which is about the amount of time it took to
download the model.</p>

<p>Let's run some evals!</p>

<h4>Evals</h4>

<p>Our smoke test gives us this:</p>

<pre><code>Every effort moves you up the hill for a full day.
“We don’t know anyone who looks
</code></pre>

<p>Coherent enough, I think!  Now the loss on our test dataset; it comes out as 3.730,
so pretty similar to our other cloud trains, apart from the oddly-low one on the 40 GiB GPUs.</p>

<p>Now let's see what GPT-5.1 thinks of the instruction fine-tuned version.  It only needs
two epochs of fine-tuning, and believes that "The author of 'Pride and Prejudice' is 'Pride and Prejudice'",
which is not promising, and gets a score in the same kind of range as the other models,
11.71.</p>

<p>So: we've trained four models on four different machine sizes.  Let's see how
they stack up against each other, against our locally-trained models, and the original
OpenAI GPT-2 weights.</p>

<h3>The results</h3>

<p>So, I've trained four of my 163M-parameter GPT-2 models, using almost exactly the same dataset
-- the Chinchilla-optimal number of tokens, rounded up to make an even number of batches.
I did this on four different multi-GPU machines on Lambda Labs:</p>

<ul>
<li>An 8x A100 40 GiB</li>
<li>An 8x A100 80 GiB</li>
<li>An 8x H100 80 GiB</li>
<li>An 8x B200 160 GiB</li>
</ul>

<h4>Evals</h4>

<p>I've done some evals on each of the models, so let's put those results together
in one table -- results for the
trains in this blog post, alongside those for the original OpenAI GPT-2 weights, both
small and medium, and for the models I got when training locally.</p>

<p>For all models, I've provided:</p>

<ul>
<li>The loss on my test set.</li>
<li>The results it got on an instruction fine-tune test based on Sebastian Raschka's.</li>
<li>The global batch size (that is, for single GPU runs, just the batch size, but for
the multi-GPU ones, where each batch is made up of per-GPU micro-batches, the
per-GPU batch size times the number of GPUs). <sup><a href="#fn-4" target="_blank" rel="noopener noreferrer">4</a></sup></li>
</ul>

<p>I've sorted the models
in order of increasing loss on the test set -- so, the best model by that measure is first.</p>

<table>
<thead>
<tr>
  <th></th>
  <th>Test loss</th>
  <th>IFT score</th>
  <th>Batch size</th>
</tr>
</thead>
<tbody>
<tr>
  <td>OpenAI weights: medium</td>
  <td>3.231</td>
  <td>38.52</td>
  <td>512</td>
</tr>
<tr>
  <td>OpenAI weights: small</td>
  <td>3.500</td>
  <td>22.98</td>
  <td>512</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x A100 40 GiB</td>
  <td>3.674</td>
  <td>17.09</td>
  <td>104</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x H100 80 GiB</td>
  <td>3.725</td>
  <td>11.98</td>
  <td>216</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x A100 80 GiB</td>
  <td>3.734</td>
  <td>11.71</td>
  <td>224</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x B200 160 GiB</td>
  <td>3.771</td>
  <td>13.89</td>
  <td>512</td>
</tr>
<tr>
  <td>Local FineWeb train</td>
  <td>3.944</td>
  <td>16.01</td>
  <td>6</td>
</tr>
<tr>
  <td>Local FineWeb-Edu extended train</td>
  <td>4.135</td>
  <td>14.44</td>
  <td>6</td>
</tr>
<tr>
  <td>Local FineWeb-Edu train</td>
  <td>4.167</td>
  <td>16.86</td>
  <td>6</td>
</tr>
</tbody>
</table>

<p>The instruction fine-tune results are kind of all over the place, and I'll look into
that later <sup><a href="#fn-5" target="_blank" rel="noopener noreferrer">5</a></sup>.  For now, let's focus on the test loss.  We have a pretty clear pattern,
where the local trains are grouped together at around 4.0, and the cloud trains at
around 3.7.  For the local trains, as I noticed last time around, FineWeb is
counter-intuitively <em>better</em> than FineWeb-Edu.</p>

<p>There are two interesting things about the cloud trains:</p>

<ol>
<li>They're all consistently better than the local ones.</li>
<li>The one on the <em>smaller</em> machine is better than the ones on the larger ones;
indeed, it looks like the larger the machine, the worse.</li>
</ol>

<p>I think that what we're seeing here is that larger batches are better, but only
up to a point.  It's as if there's some kind of curve like this:</p>

<p><img src="/post-assets/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud/batch-size-fit.png" alt="Log batch size vs loss quadratic polynomial regression" title="Log batch size vs loss quadratic polynomial regression" /></p>

<p>I got that by taking the log of the batch size, then asking NumPy to do a polynomial
regression -- that is, work out a, b and c so that the formula</p>

y=ax2+bx+c

<p>...fits it as well as possible:</p>

<div>
<pre><span></span><code><span>&gt;&gt;&gt;</span> <span>import</span><span> </span><span>numpy</span><span> </span><span>as</span><span> </span><span>np</span>
<span>&gt;&gt;&gt;</span> <span>xs</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>104</span><span>,</span> <span>216</span><span>,</span> <span>224</span><span>,</span> <span>512</span><span>,</span> <span>6</span><span>])</span>
<span>&gt;&gt;&gt;</span> <span>ys</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>3.674</span><span>,</span> <span>3.725</span><span>,</span> <span>3.73</span><span>,</span> <span>3.771</span><span>,</span> <span>3.944</span><span>])</span>
<span>&gt;&gt;&gt;</span> <span>log_xs</span> <span>=</span> <span>np</span><span>.</span><span>log</span><span>(</span><span>xs</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span> <span>=</span> <span>np</span><span>.</span><span>polyfit</span><span>(</span><span>log_xs</span><span>,</span> <span>ys</span><span>,</span> <span>2</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span>
<span>(</span><span>np</span><span>.</span><span>float64</span><span>(</span><span>0.03231264430524897</span><span>),</span>
 <span>np</span><span>.</span><span>float64</span><span>(</span><span>-</span><span>0.2957154034594081</span><span>),</span>
 <span>np</span><span>.</span><span>float64</span><span>(</span><span>4.368745850428664</span><span>))</span>
</code></pre>
</div>

<p>It's kind of interesting that it's such a good
fit with such an ad-hoc formula!  We have a nice smooth curve hitting almost all
of the points, and our optimal batch size looks like it's just a little below that
104 we managed with the smaller cloud machine, at about 97.
But it's certainly not something that I'd like to
read too much into.  Best to treat it as purely illustrative: "it <em>might</em>
be something like this".</p>

<p>I think digging into that might be an interesting experiment at some later point.
A bit of checking around the Internet (and a chat with ChatGPT) suggests that it's
something people have looked into in some detail, unsurprisingly.  An
interesting point ChatGPT raised is that with our pretty much fixed "budget" of tokens --
we're always training on something close to the Chinchilla-optimal number -- then a larger
batch size means that we're doing fewer optimiser steps.</p>

<p>Intuitively, that sounds like a problem.
The larger batches mean that each move across the loss landscape
is "better", or at least more stable.  But we're doing fewer of those moves over the course
of the train.  There's obviously a tension between those two.  You can imagine
a degenerate case where the batch is so large you can fit the entire run into
one iteration, so you do just one update of the parameters; that obviously wouldn’t work very well.</p>

<p>Anyway, for the purposes of this post, let's flag it as interesting and move on.
Let's take a look at costs.</p>

<h4>Costs of training in the cloud</h4>

<p>Here's another table for those -- for each cloud model, I've listed:</p>

<ul>
<li>How long the training run took.</li>
<li>How much the machine cost per hour.</li>
<li>How much the training run cost.</li>
<li>How much of that was doing validation (which I'm now thinking is pointless on single-epoch trains like this).</li>
<li>How much it would have cost, and how long it would have taken if it had been run without validation.</li>
</ul>

<table>
<thead>
<tr>
  <th></th>
  <th>Train time (s)</th>
  <th>Cost/hour (USD)</th>
  <th>Train cost (USD)</th>
  <th>Val runs</th>
  <th>Per-val time (s)</th>
  <th>Total val time (s)</th>
  <th>Val cost (USD)</th>
  <th>Cost ex val (USD)</th>
  <th>Time ex val (s)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Cloud FineWeb, 8x A100 40 GiB</td>
  <td>13,904</td>
  <td>10.32</td>
  <td>39.86</td>
  <td>50</td>
  <td>30</td>
  <td>1,500</td>
  <td>4.30</td>
  <td>35.56</td>
  <td>12,404</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x H100 80 GiB</td>
  <td>6,650</td>
  <td>23.92</td>
  <td>44.19</td>
  <td>24</td>
  <td>38</td>
  <td>912</td>
  <td>6.06</td>
  <td>38.13</td>
  <td>5,738</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x A100 80 GiB</td>
  <td>11,532</td>
  <td>14.32</td>
  <td>45.87</td>
  <td>24</td>
  <td>66</td>
  <td>1,584</td>
  <td>6.30</td>
  <td>39.57</td>
  <td>9,948</td>
</tr>
<tr>
  <td>Cloud FineWeb, 8x B200 160 GiB</td>
  <td>4,190</td>
  <td>39.92</td>
  <td>46.46</td>
  <td>11</td>
  <td>60</td>
  <td>660</td>
  <td>7.32</td>
  <td>39.14</td>
  <td>3,530</td>
</tr>
</tbody>
</table>

<p>What do these numbers tell us, given what we were trying to do here?</p>

<h3>Conclusion</h3>

<p>Like I said at the start, this was a pretty expensive learning experience: I wound
up spending US$215.16 on Lambda Labs instances over the course of putting this all together.
But it was worth it!</p>

<p>At the start of this post (if you can remember so far back), I said I wanted to
achieve two things:</p>

<ol>
<li>I wanted to learn how to change a simple single-GPU training loop to make it
multi-GPU.</li>
</ol>

<p>Success!</p>

<ol>
<li>Could I get the training time for a full base model down from 48 hours
to something more manageable -- and, hopefully, not too expensive?</li>
</ol>

<p>Yes, absolutely.  The trains I did, if we exclude the validation time, each cost
between US$35.56
and US$39.14.  In time, also excluding validation, the slowest ran for about 3h25m,
and the fastest just less than an hour.</p>

<p>Now, in a future post I want to try making the changes that I listed
<a href="/2025/12/llm-from-scratch-28-training-a-base-model-from-scratch#but-why-is-our-model-worse-than-openais" target="_blank" rel="noopener noreferrer">at the end of my last post</a>
to see if I can get the loss lower:</p>

<ul>
<li>Removing dropout</li>
<li>Tweaking the learning rate (and maybe adding the warmup and cosine learning-rate decay stuff I've read about).</li>
<li>Reverting the architectural differences between our model and the original GPT-2:
reintroducing weight tying between the token embeddings and the final linear layer, and also bias in the attention weights.</li>
<li>Trying full-fat 32-bit precision.</li>
<li>Fixing the exploding gradients issue with gradient clipping.</li>
</ul>

<p>If I'm to do those, what I'll need to do is start with a baseline train on one particular
size of machine, and then try introducing each change separately to see what happens to loss.
I'll want to use a fixed seed for random number generation, so that I start with the
same initial weights each time.</p>

<p>Given what these experiments have already shown about loss -- that the smallest,
cheapest machine has better loss than the other more expensive ones due to what I assume
is the batch size -- then that
actually feels like exactly the right machine to choose for this.  It does take a
while to train anything, but three and a half hours is pretty acceptable, I think
-- I can do a train or two per day.  An 8x
A100 with 40 GiB VRAM per GPU is the way forward.</p>

<p>So: next steps.  I want to:</p>

<ul>
<li>Dig in to the instruction fine-tuning tests a little more -- as I've
said above, I'm not 100% happy with how comparable it really is between models,
at least given how I've been running it so far.</li>
<li>Upload the models we have to Hugging Face.  I have a new motherboard ready for my
PC, and replacing the old one has a risk that I might mess up and break the NVMe drive
I have them stored on.  I was holding off on this because it would mean sharing
Raschka's GPT code, but having noticed that he's already licensed it all under
the Apache license, I can release them under the same one.</li>
<li>Strip out the validation stuff.  We can use training loss to track our progress,
and losing evals during the train will help keep the cost down.</li>
<li>Finally, do the trains to see how each of the levers above affects loss.</li>
</ul>

<p>This is going to be fun.  Stay tuned!</p>

<p><a href="/2026/01/llm-from-scratch-30-digging-into-llm-as-a-judge" target="_blank" rel="noopener noreferrer">Here's a link to the next post in this series</a>.</p>

<div>
<hr />
<ol>
<li>
<p>I erroneously called this a "mini-batch" in earlier versions of this post and
in the code -- fixed in <a href="https://github.com/gpjt/ddp-base-model-from-scratch/commit/7f50aa4d86ff81699bbf4bb7fbb1931e0461cc8a" target="_blank" rel="noopener noreferrer">this commit</a>.
The code in this post reflects the correct terminology, but if you follow the
links to the earlier versions you will, of course, see the mistaken name. <a href="#fnref-1" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>

<li>
<p>Disregarding the "grokking" phenomenon where continued training after overfitting,
in some cases, can apparently make it start generalising again. <a href="#fnref-2" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>

<li>
<p>Of course, people <em>always</em> say that when they add on unnecessary levels of
abstraction... <a href="#fnref-3" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>

<li>
<p>The <a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf" target="_blank" rel="noopener noreferrer">GPT-2 paper</a> is
annoyingly short on concrete numbers, but they do at least explicitly state
that they used a batch size of 512. <a href="#fnref-4" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>

<li>
<p>To be strictly honest here, I've already dug into it, but adding a writeup of
that to this already absurdly long blog post felt like something adjacent to sadism.
Update shortly. <a href="#fnref-5" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
</ol>
</div>
</div> <footer class="article-footer" data-astro-cid-wrgicudb> <div class="action-row" data-astro-cid-wrgicudb> <a href="https://www.gilesthomas.com/2026/01/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud" target="_blank" rel="noopener noreferrer" class="read-original-btn" data-astro-cid-wrgicudb>
阅读原文 ↗
</a> </div> <div class="back-to-list" data-astro-cid-wrgicudb> <a href="/reading-list" class="back-link" data-astro-cid-wrgicudb>← 返回订阅列表</a> </div> </footer> </article> </div>  </main> <footer class="site-footer" aria-label="Site footer" data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <p class="footer-text" data-astro-cid-sz7xmlte>
&copy; 2026 AstroBlog
</p> <p class="footer-text" data-astro-cid-sz7xmlte>
Built with  <a href="https://astro.build/" target="_blank" rel="noopener noreferrer" class="footer-link" data-astro-cid-sz7xmlte>
Astro
</a> </p> </div> </footer>  </body></html> 