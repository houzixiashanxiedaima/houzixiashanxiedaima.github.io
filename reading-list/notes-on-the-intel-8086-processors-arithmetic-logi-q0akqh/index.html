<!DOCTYPE html><html lang="zh-CN" data-astro-cid-sckkx6r4> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.17.1"><meta name="description" content="1978 年，英特尔推出了 8086 处理器，这是一款革命性的芯片，引领了现代 x86 架构的发展。然而，与现代 64 位处理器不同，8086 是一款 16 位芯片。其算术/逻辑单元"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self'; font-src 'self' data:;"><link rel="canonical" href="https://blog.yuyins.com/reading-list/notes-on-the-intel-8086-processors-arithmetic-logi-q0akqh/"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://blog.yuyins.com/reading-list/notes-on-the-intel-8086-processors-arithmetic-logi-q0akqh/"><meta property="og:title" content="英特尔 8086 处理器算术逻辑单元说明"><meta property="og:description" content="1978 年，英特尔推出了 8086 处理器，这是一款革命性的芯片，引领了现代 x86 架构的发展。然而，与现代 64 位处理器不同，8086 是一款 16 位芯片。其算术/逻辑单元"><meta property="og:image" content="https://blog.yuyins.com/favicon.svg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://blog.yuyins.com/reading-list/notes-on-the-intel-8086-processors-arithmetic-logi-q0akqh/"><meta property="twitter:title" content="英特尔 8086 处理器算术逻辑单元说明"><meta property="twitter:description" content="1978 年，英特尔推出了 8086 处理器，这是一款革命性的芯片，引领了现代 x86 架构的发展。然而，与现代 64 位处理器不同，8086 是一款 16 位芯片。其算术/逻辑单元"><meta property="twitter:image" content="https://blog.yuyins.com/favicon.svg"><title>英特尔 8086 处理器算术逻辑单元说明</title><!-- Theme and color scheme script (runs before page loads to prevent flash) --><script>
			// 初始化配色方案 - 默认使用 stone-amber
			const colorScheme = localStorage.getItem('colorScheme') || 'stone-amber';
			document.documentElement.setAttribute('data-color', colorScheme);

			// 强制使用浅色主题
			document.documentElement.setAttribute('data-theme', 'light');
		</script><link rel="stylesheet" href="/_astro/_slug_.Da6PdEKR.css">
<style>.blog-post-container[data-astro-cid-wrgicudb]{width:100%;margin:0 auto;padding:2rem 0}.blog-post[data-astro-cid-wrgicudb]{width:100%;min-width:0;max-width:42rem;margin:0 auto}.article-header[data-astro-cid-wrgicudb]{margin-bottom:2rem;padding-bottom:1rem;border-bottom:1px solid var(--border)}.article-header[data-astro-cid-wrgicudb] h1[data-astro-cid-wrgicudb]{font-size:2rem;line-height:1.3;margin-bottom:1rem;font-weight:700;color:var(--foreground);word-break:break-word}.article-meta[data-astro-cid-wrgicudb]{display:flex;align-items:center;gap:.5rem;font-size:.875rem;color:var(--muted-foreground)}.source-tag[data-astro-cid-wrgicudb]{background-color:var(--muted);color:var(--foreground);padding:.125rem .5rem;border-radius:9999px;font-weight:500;font-size:.75rem;text-decoration:none;transition:opacity .2s}.source-tag[data-astro-cid-wrgicudb]:hover{opacity:.8}.separator[data-astro-cid-wrgicudb]{color:var(--border)}.article-content[data-astro-cid-wrgicudb]{line-height:1.8;margin-bottom:3rem;font-size:1.0625rem;color:var(--foreground)}.article-content[data-astro-cid-wrgicudb] h2{margin-top:2rem;margin-bottom:1rem;font-size:1.5rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] h3{margin-top:1.5rem;margin-bottom:.75rem;font-size:1.25rem;font-weight:600}.article-content[data-astro-cid-wrgicudb] p{margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] a{color:var(--accent);text-decoration:underline;text-underline-offset:2px}.article-content[data-astro-cid-wrgicudb] img{max-width:100%;height:auto;border-radius:.5rem;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] blockquote{border-left:4px solid var(--border);padding-left:1rem;margin:1.5rem 0;color:var(--muted-foreground);font-style:italic}.article-content[data-astro-cid-wrgicudb] pre{background:var(--muted);padding:1rem;border-radius:.5rem;overflow-x:auto;font-family:monospace;margin:1.5rem 0}.article-content[data-astro-cid-wrgicudb] ul,.article-content[data-astro-cid-wrgicudb] ol{padding-left:1.5rem;margin-bottom:1.25rem}.article-content[data-astro-cid-wrgicudb] li{margin-bottom:.5rem}.article-footer[data-astro-cid-wrgicudb]{padding-top:2rem;border-top:1px solid var(--border);display:flex;flex-direction:column;gap:1.5rem;align-items:center}.action-row[data-astro-cid-wrgicudb]{display:flex;justify-content:center}.read-original-btn[data-astro-cid-wrgicudb]{display:inline-flex;align-items:center;gap:.5rem;padding:.75rem 1.5rem;background-color:var(--foreground);color:var(--background);border-radius:.5rem;font-weight:500;text-decoration:none;transition:opacity .2s}.read-original-btn[data-astro-cid-wrgicudb]:hover{opacity:.9}.back-to-list[data-astro-cid-wrgicudb]{text-align:center}.back-link[data-astro-cid-wrgicudb]{color:var(--muted-foreground);text-decoration:none;font-size:.875rem;transition:color .2s}.back-link[data-astro-cid-wrgicudb]:hover{color:var(--foreground)}
</style></head> <body data-astro-cid-sckkx6r4> <a id="skip-to-content" href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-accent focus:text-background" data-astro-cid-sckkx6r4>Skip to content</a> <header class="header" data-astro-cid-3ef6ksr2> <nav class="header-nav" aria-label="Main navigation" data-astro-cid-3ef6ksr2> <a href="/" class="header-logo" data-astro-cid-3ef6ksr2>
AstroBlog
</a> <div class="header-links" data-astro-cid-3ef6ksr2> <ul class="nav-list" data-astro-cid-3ef6ksr2> <li data-astro-cid-3ef6ksr2> <a href="/" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 文章 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/category" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 分类 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/reading-list" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 订阅 </a> </li><li data-astro-cid-3ef6ksr2> <a href="/about" class="nav-link" data-astro-prefetch="true" data-astro-cid-3ef6ksr2> 关于 </a> </li> </ul> <div class="header-actions" data-astro-cid-3ef6ksr2> <div id="search" data-astro-cid-otpdt6jm> <button id="search-button" class="search-toggle" aria-label="打开搜索" title="搜索 (⌘K)" data-astro-cid-otpdt6jm> <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></circle> <path d="M20 20L16.5 16.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" data-astro-cid-otpdt6jm></path> </svg> </button> <dialog id="search-dialog" class="search-modal" data-astro-cid-otpdt6jm> <div class="modal-content" data-astro-cid-otpdt6jm> <div class="modal-header" data-astro-cid-otpdt6jm> <h2 class="modal-title" data-astro-cid-otpdt6jm>搜索文章</h2> <button id="close-search" class="close-button" aria-label="关闭搜索" data-astro-cid-otpdt6jm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-astro-cid-otpdt6jm> <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-otpdt6jm></path> </svg> </button> </div> <div id="pagefind-ui" data-astro-cid-otpdt6jm></div> </div> </dialog> </div> <script type="module">let d=!1;const c="pagefind-loaded";async function l(t=0){if(sessionStorage.getItem(c)==="true")return g(),!0;const r=document.getElementById("pagefind-ui");if(!r)return!1;r.innerHTML='<div style="padding: 2rem; text-align: center; color: var(--muted-foreground);">加载中...</div>';try{return await new Promise((o,s)=>{const a=document.createElement("script");a.src="/pagefind/pagefind-ui.js",a.onload=o,a.onerror=s,document.head.appendChild(a)}),g(),sessionStorage.setItem(c,"true"),!0}catch(i){return console.error("Failed to load search:",i),t<2?(console.log(`Retrying search load... (${t+1}/2)`),await new Promise(o=>setTimeout(o,1e3)),l(t+1)):(r&&(r.innerHTML=`
          <div style="padding: 2rem; text-align: center;">
            <p style="color: var(--muted-foreground); margin-bottom: 1rem;">搜索功能加载失败</p>
            <button id="retry-search" style="padding: 0.5rem 1rem; background: var(--accent); color: var(--accent-foreground); border: none; border-radius: 0.375rem; cursor: pointer;">
              重试
            </button>
          </div>
        `,document.getElementById("retry-search")?.addEventListener("click",()=>{sessionStorage.removeItem(c),l(0)})),!1)}}function g(){typeof PagefindUI<"u"&&(new PagefindUI({element:"#pagefind-ui",showSubResults:!0,showImages:!1,excerptLength:15,translations:{placeholder:"搜索文章...",clear_search:"清除",load_more:"加载更多",search_label:"搜索此站点",filters_label:"筛选",zero_results:"未找到结果 [SEARCH_TERM]",many_results:"找到 [COUNT] 个结果 [SEARCH_TERM]",one_result:"找到 [COUNT] 个结果 [SEARCH_TERM]",alt_search:"未找到 [SEARCH_TERM] 的结果。显示 [DIFFERENT_TERM] 的结果",search_suggestion:"未找到 [SEARCH_TERM] 的结果。尝试以下搜索：",searching:"搜索中 [SEARCH_TERM]..."}}),setTimeout(()=>{const t=document.querySelector(".pagefind-ui__search-input");t instanceof HTMLElement&&t.focus()},100))}function u(){if(d)return;d=!0;const t=document.getElementById("search-button"),n=document.getElementById("search-dialog"),r=document.getElementById("close-search");if(!t||!n||!r)return;let i=sessionStorage.getItem(c)==="true";const o=async()=>{n.showModal(),document.body.style.overflow="hidden",i?setTimeout(()=>{const e=document.querySelector(".pagefind-ui__search-input");e instanceof HTMLElement&&e.focus()},100):await l()&&(i=!0)},s=()=>{n.close(),document.body.style.overflow=""},a=e=>{e.target===n&&s()},m=e=>{e.key==="Escape"&&n.open&&s()},f=e=>{(e.metaKey||e.ctrlKey)&&e.key==="k"&&(e.preventDefault(),n.open?s():o())};t.addEventListener("click",o),r.addEventListener("click",s),n.addEventListener("click",a),document.addEventListener("keydown",m),document.addEventListener("keydown",f),document.addEventListener("astro:before-swap",()=>{t.removeEventListener("click",o),r.removeEventListener("click",s),n.removeEventListener("click",a),document.removeEventListener("keydown",m),document.removeEventListener("keydown",f),d=!1},{once:!0})}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",u):u();document.addEventListener("astro:page-load",u);</script> <link href="/pagefind/pagefind-ui.css" rel="stylesheet">  </div> </div> </nav> </header>  <main id="main-content" data-pagefind-body class="main-content main-content--wide" data-astro-cid-sckkx6r4>  <div class="blog-post-container" data-astro-cid-wrgicudb> <article class="blog-post" data-astro-cid-wrgicudb> <header class="article-header" data-astro-cid-wrgicudb> <h1 data-astro-cid-wrgicudb>英特尔 8086 处理器算术逻辑单元说明</h1> <div class="article-meta" data-astro-cid-wrgicudb> <a href="https://righto.com" target="_blank" rel="noopener noreferrer" class="source-tag" data-astro-cid-wrgicudb>righto.com</a> <span class="separator" data-astro-cid-wrgicudb>·</span> <time data-astro-cid-wrgicudb>2026年1月23日</time> </div> </header> <!-- 使用清洗后的安全 HTML 内容 --> <div class="article-content app-prose" data-astro-cid-wrgicudb><p>In 1978, Intel introduced the 8086 processor, a revolutionary chip that led to the modern x86 architecture.
Unlike modern 64-bit processors, however, the 8086 is a 16-bit chip.
Its arithmetic/logic unit (ALU) operates on 16-bit values, performing arithmetic operations such as addition and subtraction,
as well as logic operations including bitwise AND, OR, and XOR.
The 8086's ALU is a complicated part of the chip, performing 28 operations in total.<span><a href="#fn:operations" target="_blank" rel="noopener noreferrer">1</a></span></p>
<p>In this post, I discuss the circuitry that controls the ALU, generating the appropriate control signals for a
particular operation.
The process is more complicated than you might expect. First, a machine code instruction results in the execution of multiple
microcode instructions.
Using the ALU is a two-step process: one microcode instruction (micro-instruction) configures the ALU for the desired operation,
while a second
micro-instruction gets the results from the ALU.
Moreover, based on both the microcode micro-instruction and the machine code instruction, the control circuitry sends control signals to the ALU,
reconfiguring it for the desired operation.
Thus, this circuitry provides the "glue" between the micro-instructions and the ALU.</p>
<p>The die photo below shows the 8086 processor under a microscope.
I've labeled the key functional blocks.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus and memory activity as well as instruction prefetching, while the Execution Unit (EU) executes the instructions.
In the lower right corner, the microcode ROM holds the micro-instructions.
The ALU is in the lower left corner, with bits 7-0 above and bits 15-8 below, sandwiching the status flag circuitry.
The ALU control circuitry, highlighted in red at the bottom of the chip, is the focus of this article.</p>
<p><a href="https://static.righto.com/images/8086-alu-notes/die-labeled2.jpg" target="_blank" rel="noopener noreferrer"><img alt="The die of the 8086 with the metal layer removed to show the silicon and polysilicon underneath. Click this image (or any other) for a larger version." height="622" src="https://static.righto.com/images/8086-alu-notes/die-labeled2-w600.jpg" title="The die of the 8086. Click this image (or any other) for a larger version." width="600" /></a></p><div>The die of the 8086. Click this image (or any other) for a larger version.</div><p></p>
<h2>Microcode</h2>
<p>The 8086 processor implements most machine instructions in microcode, with a micro-instruction for each step of the machine instruction.
(I discuss the 8086's microcode in detail <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html" target="_blank" rel="noopener noreferrer">here</a>.)
The 8086 uses an interesting architecture for microcode:
each micro-instruction performs two unrelated operations. The first operation moves data between a source and a destination.
The second operation can range from a jump or subroutine call to a memory read/write or an ALU operation.
An ALU operation has a five-bit field to specify a particular operation and a two-bit field to specify
which temporary register provides the input. As you'll see below, these two fields play an important role in the ALU circuitry.</p>
<p>In many cases, the 8086's micro-instruction doesn't specify the ALU operation, leaving the details to be substituted from the machine instruction opcode.
For instance, the ADD, SUB, ADC, SBB, AND, OR, XOR, and CMP
machine instructions share the same microcode, while the hardware selects the ALU operation from the instruction opcode.
Likewise, the increment and decrement instructions use the same microcode, as do the decimal adjust instructions DAA and DAS, and the
ASCII adjust instructions AAA and AAS.
Inside the micro-instruction, all these operations are performed with a "pseudo" ALU operation called XI (for some reason).
If the microcode specifies an XI ALU operation, the hardware replaces it with the ALU operation specified in the instruction.
Another important feature of the microcode is 
that you need to perform one ALU micro-instruction to configure the ALU's operation, but the result isn't
available until a later micro-instruction, which moves the result to a destination.
This has the consequence that the hardware must remember the ALU operation.</p>
<p>To make this concrete, here is the microcode that implements a typical arithmetic instruction such as <code>ADD AL, BL</code> or <code>XOR [BX+DI], CX</code>.
This microcode consists of three micro-instructions. 
The left half of each micro-instruction specifies a data movement, first moving the two arguments to ALU temporary registers
and then storing the ALU result (called Σ).
The right half of each micro-instruction performs the second task.
First, the ALU is configured to perform an <code>XI</code> operation using temporary register A. Recall that <code>XI</code> indicates the ALU operation
is filled in from the machine instruction; this is how the same microcode handles eight different types of machine instructions.
In the second micro-instruction, the next machine instruction is started unless a memory writeback is required (<code>WB</code>).
The last micro-instruction is <code>RNI</code> (Run Next Instruction) to start a new machine instruction. It also indicates that the
processor status flags (<code>F</code>) should be updated to indicate if the ALU result is zero, positive, overflow, and so forth.<span><a href="#fn:addressing" target="_blank" rel="noopener noreferrer">2</a></span></p>

<pre>
M → tmpa   XI   tmpa  <span>Load first argument, configure ALU.</span>
R → tmpb   WB,NXT     <span>Load second argument, start Next instruction if no memory writeback</span>
Σ → M      RNI  F     <span>Store ALU result, Run Next Instruction, update status Flags</span>
</pre>

<h2>The ALU circuit</h2>
<p>The ALU is the heart of a processor, performing arithmetic and logic operations.
Microprocessors of the 1970s typically supported addition and subtraction; logical AND, OR, and XOR; and various bit shift operations.
(Although the 8086 had multiply and divide instructions, these were implemented in microcode, not in the ALU.)
Since an ALU is both large and critical to performance, chip architects try to optimize its design.
As a result, different microprocessors have widely different ALU designs.
For instance, the 6502 microprocessor has separate circuits for addition and each logic operation; a multiplexer selects the appropriate
output.
The Intel 8085, on the other hand, uses an optimized clump of gates that performs the desired operation based on control signals (<a href="https://www.righto.com/2013/01/inside-alu-of-8085-microprocessor.html" target="_blank" rel="noopener noreferrer">details</a>), while the Z80's 4-bit ALU uses a different clump of gates (<a href="https://www.righto.com/2013/09/the-z-80-has-4-bit-alu-heres-how-it.html" target="_blank" rel="noopener noreferrer">details</a>).</p>
<p>The 8086 takes a different approach, using two lookup tables (along with other gates) to generate the carry and output signals for each bit in the ALU.
By setting the lookup tables appropriately, the ALU can be configured to perform the desired operation.
(This is similar to how an FPGA implements arbitrary functions through lookup tables.)
The schematic below shows the circuit for one bit of the ALU.
I won't explain this circuit in detail since I explained it in <a href="https://www.righto.com/2020/08/reverse-engineering-8086s.html" target="_blank" rel="noopener noreferrer">an earlier article</a>.<span><a href="#fn:shift-right" target="_blank" rel="noopener noreferrer">3</a></span>
The relevant part of this circuit is the six control signals at the left.
The two multiplexers (trapezoidal symbols) implement the lookup tables by using the two input argument bits to select outputs from
the control signals to control carry generation and carry propagation.
Thus, by feeding appropriate control signals into the ALU, the 8086 can reconfigure the ALU to perform the desired operation.
For instance, with one set of control signals, this circuit will add. Other sets of control signals will cause the circuit to subtract
or compute a logical operation, such as AND or XOR.
The 8086 has 16 copies of this circuit, so it operates on 16-bit values.</p>
<p><a href="https://static.righto.com/images/8086-alu-notes/alu-schematic.png" target="_blank" rel="noopener noreferrer"><img alt="The circuit that implements one bit in the 8086's ALU." height="382" src="https://static.righto.com/images/8086-alu-notes/alu-schematic-w600.png" title="The circuit that implements one bit in the 8086's ALU." width="600" /></a></p><div>The circuit that implements one bit in the 8086's ALU.</div><p></p>
<p>The 8086 is a complicated processor, and its instructions have many special cases, so controlling the ALU is
more complex than described above.
For instance, the compare operation is the same as a subtraction, except the numerical result of a compare is discarded; just the
status flags are updated.
The add versus add-with-carry instructions require different values for the carry into bit 0, while subtraction requires the
carry flag to be inverted since it is treated as a borrow.
The 8086's ALU supports increment and decrement operations, but also increment and decrement by 2, which requires an increment signal into bit
1 instead of bit 0.
The bit-shift operations all require special treatment. For instance, a rotate can use the carry bit or exclude the carry bit, while
and arithmetic shift right requires the top bit to be duplicated.
As a result, along with the six lookup table (LUT) control signals, the ALU also requires numerous control signals to adjust its
behavior for specific instructions.
In the next section, I'll explain how these control signals are generated.</p>
<h2>ALU control circuitry on the die</h2>
<p>The diagram below shows the components of the ALU control logic as they appear on the die.
The information from the micro-instruction enters at the right and is stored in the latches.
The PLAs (Programmable Logic Arrays) decode the instruction and generate the control signals.
These signals flow to the left, where they control the ALU.</p>
<p><a href="https://static.righto.com/images/8086-alu-notes/logic-labeled.jpg" target="_blank" rel="noopener noreferrer"><img alt="The ALU control logic as it appears on the die. I removed the metal layer to show the underlying polysilicon and silicon. The reddish lines are remnants of the metal." height="338" src="https://static.righto.com/images/8086-alu-notes/logic-labeled-w500.jpg" title="The ALU control logic as it appears on the die. I removed the metal layer to show the underlying polysilicon and silicon. The reddish lines are remnants of the metal." width="500" /></a></p><div>The ALU control logic as it appears on the die. I removed the metal layer to show the underlying polysilicon and silicon. The reddish lines are remnants of the metal.</div><p></p>
<p>As explained earlier, if the microcode specifies the <code>XI</code> operation, the operation field is replaced with a value based on the machine instruction opcode.
This substitution is performed by the <code>XI</code> multiplexer before the value is stored in the operation latch.
Because of the complexity of the 8086 instruction set, the <code>XI</code> operation is not as straightforward as you might expect.
This multiplexer gets three instruction bits from a special register called the "X" register, another instruction bit from the instruction
register, and the final bit from a decoding circuit called the Group Decode ROM.<span><a href="#fn:xi" target="_blank" rel="noopener noreferrer">4</a></span></p>
<p>Recall that one micro-instruction specifies the ALU operation, and a later micro-instruction accesses the result. Thus, the
ALU control circuitry must remember the specified operation so it can be used later. 
In particular, the control circuitry must keep track of the ALU operation to perform and the temporary register specified.
The control circuitry uses three flip-flops to keep track of the specified temporary register, one flip-flop for each register.
The micro-instruction contains a two-bit field that specifies the temporary register. The control circuitry decodes this field and
activates the associated flip-flop.
The outputs from these flip-flops go to the ALU and enable the associated temporary register.
At the start of each machine instruction,<span><a href="#fn:sc" target="_blank" rel="noopener noreferrer">5</a></span> the flip-flops are reset, so temporary register A is selected by default.</p>
<p>The control circuitry uses five flip-flops to store the five-bit operation field from the micro-instruction.
At the start of each machine instruction, the flip-flops are reset so operation 0 (ADD) is specified by default.
One important consequence is that an add operation can potentially be performed without a micro-instruction to configure the ALU,
shortening the microcode by one micro-instruction and thus shortening the instruction time by one cycle.</p>
<p>The five-bit output from the operation flip-flops goes to the operation PLA (Programmable Logic Array)<span><a href="#fn:pla" target="_blank" rel="noopener noreferrer">7</a></span>, which decodes the operation
into 27 control signals.<span><a href="#fn:control" target="_blank" rel="noopener noreferrer">6</a></span>
Many of these signals go to the ALU, where they control the behavior of the ALU for special cases.
About 15 of these signals go to the Lookup Table (LUT) PLA, which generates the six lookup table signals for the ALU.
At the left side of the LUT PLA, special high-current driver circuits amplify the control signals before they are sent to the ALU.
Details on these drivers are in the footnotes.<span><a href="#fn:driver" target="_blank" rel="noopener noreferrer">8</a></span></p>
<h2>Conclusions</h2>
<p>Whenever I look at the circuitry of the 8086 processor, I see the differences between a RISC chip and a CISC chip.
In a RISC (Reduced Instruction Set Computer) processor such as ARM, instruction decoding is straightforward, as is the processor circuitry.
But in the 8086, a CISC (Complex Instruction Set Computer) processor, there are corner cases and complications everywhere.
For instance, an 8086 machine instruction sometimes specifies the ALU operation in the first byte and sometimes in the second byte,
and sometimes elsewhere, so the X register latch, the XI multiplexer, and the Group Decode ROM are needed.
The 8086's ALU includes obscure operations including four types of BCD adjustments and seven types of shifts, making the ALU more
complicated.
Of course, the continuing success of x86 shows that this complexity also has benefits.</p>
<p>This article has been a deep dive into the details of the 8086's ALU, but I hope you have found it interesting.
If it's too much detail for you, you might prefer my overview of the <a href="https://www.righto.com/2020/08/reverse-engineering-8086s.html" target="_blank" rel="noopener noreferrer">8086 ALU</a>.</p>
<p>For updates, follow me on
 Bluesky (<a href="https://bsky.app/profile/righto.com" target="_blank" rel="noopener noreferrer">@righto.com</a>),
Mastodon (<a href="https://oldbytes.space/@kenshirriff" target="_blank" rel="noopener noreferrer">@kenshirriff@oldbytes.space</a>),
or <a href="http://www.righto.com/feeds/posts/default" target="_blank" rel="noopener noreferrer">RSS</a>.</p>
<p>Credits:
Thanks to Marcin Peczarski for discussion.
My microcode analysis is based on Andrew Jenner's <a href="https://www.reenigne.org/blog/8086-microcode-disassembled/" target="_blank" rel="noopener noreferrer">8086 microcode disassembly</a>.</p>
<h2>Notes and references</h2>
<div>
<ol>
<li>
<p></p>
<p>The operations implemented by the ALU are:</p>
<p></p><table>
<tr><td>00</td><td>ADD</td><td>Add</td></tr>
<tr><td>01</td><td>OR</td><td>Logical OR</td></tr>
<tr><td>02</td><td>ADC</td><td>Add with carry in</td></tr>
<tr><td>03</td><td>SBB</td><td>Subtract with borrow in</td></tr>
<tr><td>04</td><td>AND</td><td>Logical AND</td></tr>
<tr><td>05</td><td>SUBT</td><td>Subtract</td></tr>
<tr><td>06</td><td>XOR</td><td>Logical XOR</td></tr>
<tr><td>07</td><td>CMP</td><td>Comparison</td></tr>
<tr><td>08</td><td>ROL</td><td>Rotate left</td></tr>
<tr><td>09</td><td>ROR</td><td>Rotate right</td></tr>
<tr><td>0a</td><td>LRCY</td><td>Left rotate through carry</td></tr>
<tr><td>0b</td><td>RRCY</td><td>Right rotate through carry</td></tr>
<tr><td>0c</td><td>SHL</td><td>Shift left</td></tr>
<tr><td>0d</td><td>SHR</td><td>Shift right</td></tr>
<tr><td>0e</td><td>SETMO</td><td>Set to minus one (<a href="https://www.righto.com/2023/07/undocumented-8086-instructions.html#fn:setmo" target="_blank" rel="noopener noreferrer">questionable</a>)</td></tr>
<tr><td>0f</td><td>SAR</td><td>Arithmetic shift right</td></tr>
<tr><td>10</td><td>PASS</td><td>Pass argument unchanged</td></tr>
<tr><td>11</td><td>XI</td><td>Instruction specifies ALU op</td></tr>
<tr><td>14</td><td>DAA</td><td>Decimal adjust after addition</td></tr>
<tr><td>15</td><td>DAS</td><td>Decimal adjust after subtraction</td></tr>
<tr><td>16</td><td>AAA</td><td>ASCII adjust after addition</td></tr>
<tr><td>17</td><td>AAS</td><td>ASCII adjust after subtraction</td></tr>
<tr><td>18</td><td>INC</td><td>Increment</td></tr>
<tr><td>19</td><td>DEC</td><td>Decrement</td></tr>
<tr><td>1a</td><td>COM1</td><td>1's complement</td></tr>
<tr><td>1b</td><td>NEG</td><td>Negate</td></tr>
<tr><td>1c</td><td>INC2</td><td>Increment by 2</td></tr>
<tr><td>1d</td><td>DEC2</td><td>Decrement by 2</td></tr>
</table><p></p>
<p>Also see Andrew Jenner's <a href="https://github.com/reenigne/reenigne/blob/master/8088/8086_microcode/8086_microcode.cpp" target="_blank" rel="noopener noreferrer">code</a>. <a href="#fnref:operations" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>You might wonder how this microcode handles the 8086's complicated addressing modes such as <code>[BX+DI]</code>.
The trick is that microcode subroutines implement the addressing modes.
For details, see my article on <a href="https://www.righto.com/2023/02/8086-modrm-addressing.html" target="_blank" rel="noopener noreferrer">8086 addressing microcode</a>. <a href="#fnref:addressing" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>The 8086's ALU has a separate circuit to implement shift-right.
The problem is that data in an ALU normally flows right-to-left as carries flow from lower bits to higher bits.
Shifting data to the right goes against this direction, so it requires a special path.
(Shifting to the left is straightforward; you can add a number to itself.)</p>
<p>The adjust operations (DAA, DAS, AAA, AAS) also use completely separate circuitry.
These operations generate correction factors for BCD (binary-coded decimal) arithmetic based on the value and flags.
The circuitry for these operations is located with the flags circuitry, separate from the rest of the ALU circuitry. <a href="#fnref:shift-right" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>In more detail, the 8086 stores bits 5-3 of the machine instruction in the "X" register.
For an XI operation, the X register bits become bits 2-0 of the ALU operation specification, while bit 3 comes from bit 6 of the
instruction, and bit 4 comes from the <a href="https://www.righto.com/2023/05/8086-processor-group-decode-rom.html" target="_blank" rel="noopener noreferrer">Group Decode ROM</a> for
certain instructions.
The point of this is that the instruction set is designed so bits of the instruction correspond to bits of the ALU operation
specifier, but the mapping is more complicated than you might expect.
The eight basic arithmetic/logic operations (ADD, SUB, OR, etc) have a straightforward mapping that is visible from
the <a href="http://www.mlsite.net/8086/" target="_blank" rel="noopener noreferrer">8086 opcode table</a>, but the mapping for other instructions isn't as obvious.
Moreover, sometimes the operation is specified in the first byte of the machine instruction, but sometimes it is specified
in the second byte, which is why the X register needs to store the relevant bits. <a href="#fnref:xi" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>The flip-flops are reset by a signal in the 8086, called "Second Clock". When a new machine instruction is started, the "First Clock" signal
is generated on the instruction's first byte and the "Second Clock" signal is generated on the instruction's second byte.
(Note that these signals are not necessarily on consecutive clock cycles, because a memory fetch may be required if the
instruction queue is empty.)
Why are the flip-flops reset on Second Clock and not First Clock? The 8086 has a small degree of pipelining, so the previous
micro-instruction may still be finishing up during First Clock of the next instruction. By Second Clock, it is safe to reset
the ALU state. <a href="#fnref:sc" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>For reference, the 27 outputs from the PLA are triggered by the following ALU micro-operations:</p>
<p>Output 0: RRCY (right rotate through carry) 
<br />Output 1: ROR (Rotate Right) 
<br />Output 2: BCD Adjustments: DAA (Decimal Adjust after Addition), DAS (Decimal Adjust after Subtraction), AAA (ASCII Adjust after Subtraction), or AAS (ASCII Adjust after Subtraction) 
<br />Output 3: SAR (Shift Arithmetic Right)
<br />Output 4: Left shift: ROL (Rotate Left), RCL (Rotate through Carry Left), SHL (Shift Left), or SETMO (Set Minus One)
<br />Output 5: Right shift: ROR (Rotate Right), RCR (Rotate through Carry Right), SHR (Shift Right), or SAR (Shift Arithmetic Right)
<br />Output 6: INC2 (increment by 2) 
<br />Output 7: ROL (Rotate Left) 
<br />Output 8: RCL (Rotate through Carry Left)
<br />Output 9: ADC (add with carry) 
<br />Output 10: DEC2 (decrement by 2) 
<br />Output 11: INC (increment) 
<br />Output 12: NEG (negate) 
<br />Output 13: ALU operation 12 (unused?)
<br />Output 14: SUB (Subtract), CMP (Compare), DAS (Decimal Adjust after Subtraction), AAS (ASCII Adjust after Subtraction)
<br />Output 15: SBB (Subtract with Borrow) 
<br />Output 16: ROL (Rotate Left) or RCL (Rotate through Carry Left)
<br />Output 17: ADD or ADC (Add with Carry)
<br />Output 18: DEC or DEC2 (Decrement by 1 or 2)
<br />Output 19: PASS (pass-through) or INC (Increment)
<br />Output 20: COM1 (1's Complement) or NEG (Negate) 
<br />Output 21: XOR 
<br />Output 22: OR 
<br />Output 23: AND 
<br />Output 24: SHL (Shift Left)
<br />Output 25: DAA or AAA (Decimal/ASCII Adjust after Addition)
<br />Output 26: CMP (Compare) <a href="#fnref:control" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>A Programmable Logic Array is a way of implementing logic gates in a structured grid. PLAs are often used in microprocessors because
they provide a dense way of implementing logic.
A PLA normally consists of two layers: an "OR" layer and an "AND" layer. Together, the layers produce "sum-of-products" outputs,
consisting of multiple terms OR'd together.
The ALU's PLA is a bit unusual because many outputs are taken directly from the OR layer, while only about 15 outputs from the
first layer are fed into the second layer. <a href="#fnref:pla" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
<li>
<p>The control signals pass through the driver circuit below.
The operation of this circuit puzzled me for years, since the transistor with its gate at +5V seems to be stuck on.
But I was looking at the book <a href="https://amzn.to/49JlB8M" target="_blank" rel="noopener noreferrer">DRAM Circuit Design</a> and spotted the same circuit, called 
the "Bootstrap Wordline Driver".
The purpose of this circuit is to boost the output to a higher voltage than a regular NMOS circuit, providing better performance.
The problem with NMOS circuitry is that NMOS transistors aren't very good at pulling a signal high: due to the properties of the
transistor, the output voltage is less than the gate voltage, lower by the threshold voltage V<sub>TH</sub>, half a volt or more.</p>
<p><a href="https://static.righto.com/images/8086-alu-notes/signal-drive.png" target="_blank" rel="noopener noreferrer"><img alt="The drive signals to the ALU gates are generated with this dynamic circuit." height="149" src="https://static.righto.com/images/8086-alu-notes/signal-drive-w250.png" title="The drive signals to the ALU gates are generated with this dynamic circuit." width="250" /></a></p><div>The drive signals to the ALU gates are generated with this dynamic circuit.</div><p></p>
<p>The bootstrap circuit takes advantage of capacitance to get more voltage out of the circuit.
Specifically, suppose the input is +5V, while the clock is high. Point A will be about 4.5V, losing half a volt due to the threshold.
Now, suppose the clock goes low, so the inverted clock driving the upper transistor goes high.
Due to capacitance in the second transistor, as the source and drain go high, the gate will
be pulled above its previous voltage, maybe gaining a couple of volts.
The high voltage on the gate produces a full-voltage output, avoiding
the drop due to V<sub>TH</sub>.
But why the transistor with its gate at +5V? This transistor acts somewhat like a diode, preventing the boosted voltage from flowing
backward through the input and dissipating.</p>
<p>The bootstrap circuit is used on the ALU's lookup table control signals for two reasons.
First, these control signals drive pass transistors. A pass transistor suffers from a voltage drop due to the threshold voltage,
so you want to start with a control signal with as high a voltage as possible.
Second, each control signal is connected to 16 transistors (one for each bit).
This is a large number of transistors to drive from one signal, since each transistor has gate capacitance.
Increasing the voltage helps overcome the R-C (resistor-capacitor) delay, improving performance.</p>
<p><a href="https://static.righto.com/images/8086-alu-notes/bootstrap-diagram.jpg" target="_blank" rel="noopener noreferrer"><img alt="A close-up of the bootstrap drive circuits, in the left half of the LUT PLA." height="200" src="https://static.righto.com/images/8086-alu-notes/bootstrap-diagram-w400.jpg" title="A close-up of the bootstrap drive circuits, in the left half of the LUT PLA." width="400" /></a></p><div>A close-up of the bootstrap drive circuits, in the left half of the LUT PLA.</div><p></p>
<p>The diagram above shows six bootstrap drivers on the die. At the left are the transistors that ground the signals when clock is
high. The +5V transistors are scattered around the image; two of them are labeled.
The six large transistors provide the output signal, controlled by clock'.
Note that these transistors are much larger than the other transistors because they must produce the high-current output,
while the other transistors have more of a supporting role.</p>
<p>(Bootstrap circuits go way back; Federico Faggin designed a bootstrap circuit for the <a href="https://www.righto.com/2020/10/how-bootstrap-load-made-historic-intel.html" target="_blank" rel="noopener noreferrer">Intel 8008</a> that he claimed "proved essential to the microprocessor realization.") <a href="#fnref:driver" target="_blank" rel="noopener noreferrer">↩</a></p>
</li>
</ol>
</div>
</div> <footer class="article-footer" data-astro-cid-wrgicudb> <div class="action-row" data-astro-cid-wrgicudb> <a href="http://www.righto.com/2026/01/notes-on-intel-8086-processors.html" target="_blank" rel="noopener noreferrer" class="read-original-btn" data-astro-cid-wrgicudb>
阅读原文 ↗
</a> </div> <div class="back-to-list" data-astro-cid-wrgicudb> <a href="/reading-list" class="back-link" data-astro-cid-wrgicudb>← 返回订阅列表</a> </div> </footer> </article> </div>  </main> <footer class="site-footer" aria-label="Site footer" data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <p class="footer-text" data-astro-cid-sz7xmlte>
&copy; 2026 AstroBlog
</p> <p class="footer-text" data-astro-cid-sz7xmlte>
Built with  <a href="https://astro.build/" target="_blank" rel="noopener noreferrer" class="footer-link" data-astro-cid-sz7xmlte>
Astro
</a> </p> </div> </footer>  </body></html> 